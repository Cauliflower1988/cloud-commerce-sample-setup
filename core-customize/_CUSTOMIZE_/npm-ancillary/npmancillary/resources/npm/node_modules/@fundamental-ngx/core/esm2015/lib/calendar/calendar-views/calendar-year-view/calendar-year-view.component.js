/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewEncapsulation, Output, Input, EventEmitter, ElementRef } from '@angular/core';
import { FdDate } from '../../models/fd-date';
import { takeUntil } from 'rxjs/operators';
import { CalendarService } from '../../calendar.service';
import { Subject } from 'rxjs';
/**
 * Component representing the YearView of the Calendar Component.
 */
export class CalendarYearViewComponent {
    /**
     * @hidden
     * @param {?} eRef
     * @param {?} calendarService
     */
    constructor(eRef, calendarService) {
        this.eRef = eRef;
        this.calendarService = calendarService;
        /**
         * Parameter storing the year of the present day.
         */
        this.currentYear = FdDate.getToday().year;
        /**
         * Parameter storing first shown year on list
         */
        this.firstYearInList = this.currentYear;
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * Event fired when a year is selected.
         */
        this.yearClicked = new EventEmitter();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.newFocusedYearId) {
            this.focusElement(this.newFocusedYearId);
            this.newFocusedYearId = null;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.firstYearInList = this.yearSelected;
        this.constructYearList();
        this.calendarService.onFocusIdChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => {
            this.newFocusedYearId = this.id + '-fd-year-' + index;
            this.focusElement(this.newFocusedYearId);
        }));
        this.calendarService.focusEscapeFunction = this.focusEscapeFunction;
        this.calendarService.onKeySelect
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => this.selectYear(this.calendarYearList[index])));
        this.calendarService.onListStartApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.loadPreviousYearList()));
        this.calendarService.onListEndApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.loadNextYearList()));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
    /**
     * Method that returns active cell, which means:
     * if there is any selected year, return selected year
     * if there is no selected year, but there is current year, return current year
     * if there is no current year, or selected, return first one
     * @private
     * @return {?}
     */
    getActiveYear() {
        /** @type {?} */
        const selectedYear = this.calendarYearList.find((/**
         * @param {?} year
         * @return {?}
         */
        year => year === this.yearSelected));
        if (selectedYear) {
            return selectedYear;
        }
        /** @type {?} */
        const currentYear = this.calendarYearList.find((/**
         * @param {?} year
         * @return {?}
         */
        year => year === this.currentYear));
        if (currentYear) {
            return currentYear;
        }
        return this.calendarYearList[0];
    }
    /**
     * Method for handling the keyboard navigation.
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    onKeydownYearHandler(event, index) {
        this.calendarService.onKeydownHandler(event, index);
    }
    /**
     * Method used to load the previous 12 years to be displayed.
     * @return {?}
     */
    loadNextYearList() {
        this.firstYearInList += 12;
        this.constructYearList();
    }
    /**
     * Method used to load the next 12 years to be displayed.
     * @return {?}
     */
    loadPreviousYearList() {
        this.firstYearInList -= 12;
        this.constructYearList();
    }
    /**
     * Method allowing focusing on elements within this component.
     * @param {?} elementSelector
     * @return {?}
     */
    focusElement(elementSelector) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const elementToFocus = this.eRef.nativeElement.querySelector('#' + elementSelector);
            if (elementToFocus) {
                this.eRef.nativeElement.querySelector('#' + elementSelector).focus();
            }
        }), 0);
    }
    /**
     * Method that sends the year to the parent component when it is clicked.
     * @param {?} selectedYear
     * @param {?=} event
     * @return {?}
     */
    selectYear(selectedYear, event) {
        if (event) {
            event.stopPropagation();
        }
        this.yearSelected = selectedYear;
        this.yearClicked.emit(this.yearSelected);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    constructYearList() {
        /** @type {?} */
        const displayedYearsAmount = 12;
        this.calendarYearList = [];
        for (let x = 0; x < displayedYearsAmount; ++x) {
            this.calendarYearList.push(this.firstYearInList + x);
        }
        this.activeYear = this.getActiveYear();
    }
}
CalendarYearViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-calendar-year-view',
                template: "<div class=\"fd-calendar__years\">\n    <ul class=\"fd-calendar__list\">\n        <li class=\"fd-calendar__item\"\n            *ngFor=\"let year of calendarYearList; let i = index\"\n            [ngClass]=\"{\n                'is-selected': (year == yearSelected),\n                'fd-calendar__item--current': (year == currentYear)\n            }\"\n            [attr.id]=\"id + '-fd-year-' + i\"\n            [attr.tabindex]=\"year === activeYear ? 0 : -1\"\n            (keydown)=\"onKeydownYearHandler($event, i)\"\n            (click)=\"selectYear(year, $event)\">\n            <span role=\"button\" class=\"fd-calendar__text\">\n                {{ year }}\n            </span>\n        </li>\n    </ul>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    '[attr.id]': 'id + "-year-view"'
                },
                styles: [""]
            }] }
];
/** @nocollapse */
CalendarYearViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CalendarService }
];
CalendarYearViewComponent.propDecorators = {
    id: [{ type: Input }],
    focusEscapeFunction: [{ type: Input }],
    yearSelected: [{ type: Input }],
    yearClicked: [{ type: Output }]
};
if (false) {
    /**
     * @hidden
     *  This variable is used to define which year from calendarYearList should be focusable by tab key
     * @type {?}
     */
    CalendarYearViewComponent.prototype.activeYear;
    /**
     * Parameter that stores the dozen of years that are currently being displayed.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.calendarYearList;
    /**
     * Parameter storing the year of the present day.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.currentYear;
    /**
     * Parameter storing first shown year on list
     * @type {?}
     */
    CalendarYearViewComponent.prototype.firstYearInList;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.onDestroy$;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.newFocusedYearId;
    /**
     * Parameter used in id of years used for help with focusing on the correct element during keyboard navigation.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.id;
    /**
     * Function that is called when the focus would escape the element.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.focusEscapeFunction;
    /**
     * Parameter holding the year that is currently selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearSelected;
    /**
     * Event fired when a year is selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearClicked;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.calendarService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmdW5kYW1lbnRhbC1uZ3gvY29yZS8iLCJzb3VyY2VzIjpbImxpYi9jYWxlbmRhci9jYWxlbmRhci12aWV3cy9jYWxlbmRhci15ZWFyLXZpZXcvY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQStCLE1BQU0sZUFBZSxDQUFDO0FBQzNJLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7QUFZL0IsTUFBTSxPQUFPLHlCQUF5Qjs7Ozs7O0lBdUNsQyxZQUFvQixJQUFnQixFQUFVLGVBQWdDO1FBQTFELFNBQUksR0FBSixJQUFJLENBQVk7UUFBVSxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7Ozs7UUE1QjlFLGdCQUFXLEdBQVcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQzs7OztRQUc3QyxvQkFBZSxHQUFXLElBQUksQ0FBQyxXQUFXLENBQUM7Ozs7UUFHMUIsZUFBVSxHQUFrQixJQUFJLE9BQU8sRUFBUSxDQUFDOzs7O1FBbUJ4RCxnQkFBVyxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO0lBSXhFLENBQUM7Ozs7O0lBR0Qsa0JBQWtCO1FBQ2QsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMs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SUwsS0FBSzswQkFJTCxNQUFNOzs7Ozs7OztJQTlCUCwrQ0FBbUI7Ozs7O0lBR25CLHFEQUEyQjs7Ozs7SUFHM0IsZ0RBQTZDOzs7OztJQUc3QyxvREFBMkM7Ozs7OztJQUczQywrQ0FBaUU7Ozs7OztJQUdqRSxxREFBaUM7Ozs7O0lBR2pDLHVDQUNXOzs7OztJQUdYLHdEQUM4Qjs7Ozs7SUFHOUIsaURBQ3FCOzs7OztJQUdyQixnREFDd0U7Ozs7O0lBRzVELHlDQUF3Qjs7Ozs7SUFBRSxvREFBd0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVmlld0VuY2Fwc3VsYXRpb24sIE91dHB1dCwgSW5wdXQsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGZERhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmQtZGF0ZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYWxlbmRhclNlcnZpY2UgfSBmcm9tICcuLi8uLi9jYWxlbmRhci5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLyoqIENvbXBvbmVudCByZXByZXNlbnRpbmcgdGhlIFllYXJWaWV3IG9mIHRoZSBDYWxlbmRhciBDb21wb25lbnQuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2ZkLWNhbGVuZGFyLXllYXItdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NhbGVuZGFyLXllYXItdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5pZF0nOiAnaWQgKyBcIi15ZWFyLXZpZXdcIidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhbGVuZGFyWWVhclZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkLCBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBUaGlzIHZhcmlhYmxlIGlzIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHllYXIgZnJvbSBjYWxlbmRhclllYXJMaXN0IHNob3VsZCBiZSBmb2N1c2FibGUgYnkgdGFiIGtleVxuICAgICAqL1xuICAgIGFjdGl2ZVllYXI6IG51bWJlcjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgdGhhdCBzdG9yZXMgdGhlIGRvemVuIG9mIHllYXJzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQuICovXG4gICAgY2FsZW5kYXJZZWFyTGlzdDogbnVtYmVyW107XG5cbiAgICAvKiogUGFyYW1ldGVyIHN0b3JpbmcgdGhlIHllYXIgb2YgdGhlIHByZXNlbnQgZGF5LiAqL1xuICAgIGN1cnJlbnRZZWFyOiBudW1iZXIgPSBGZERhdGUuZ2V0VG9kYXkoKS55ZWFyO1xuXG4gICAgLyoqIFBhcmFtZXRlciBzdG9yaW5nIGZpcnN0IHNob3duIHllYXIgb24gbGlzdCAqL1xuICAgIGZpcnN0WWVhckluTGlzdDogbnVtYmVyID0gdGhpcy5jdXJyZW50WWVhcjtcblxuICAgIC8qKiBBbiBSeEpTIFN1YmplY3QgdGhhdCB3aWxsIGtpbGwgdGhlIGRhdGEgc3RyZWFtIHVwb24gY29tcG9uZW504oCZcyBkZXN0cnVjdGlvbiAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb25EZXN0cm95JDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgbmV3Rm9jdXNlZFllYXJJZDogc3RyaW5nO1xuXG4gICAgLyoqIFBhcmFtZXRlciB1c2VkIGluIGlkIG9mIHllYXJzIHVzZWQgZm9yIGhlbHAgd2l0aCBmb2N1c2luZyBvbiB0aGUgY29ycmVjdCBlbGVtZW50IGR1cmluZyBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBmb2N1cyB3b3VsZCBlc2NhcGUgdGhlIGVsZW1lbnQuICovXG4gICAgQElucHV0KClcbiAgICBmb2N1c0VzY2FwZUZ1bmN0aW9uOiBGdW5jdGlvbjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgaG9sZGluZyB0aGUgeWVhciB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHllYXJTZWxlY3RlZDogbnVtYmVyO1xuXG4gICAgLyoqIEV2ZW50IGZpcmVkIHdoZW4gYSB5ZWFyIGlzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IHllYXJDbGlja2VkOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgY2FsZW5kYXJTZXJ2aWNlOiBDYWxlbmRhclNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubmV3Rm9jdXNlZFllYXJJZCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnQodGhpcy5uZXdGb2N1c2VkWWVhcklkKTtcbiAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZFllYXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0WWVhckluTGlzdCA9IHRoaXMueWVhclNlbGVjdGVkO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdFllYXJMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2Uub25Gb2N1c0lkQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZFllYXJJZCA9IHRoaXMuaWQgKyAnLWZkLXllYXItJyArIGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNFbGVtZW50KHRoaXMubmV3Rm9jdXNlZFllYXJJZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLmZvY3VzRXNjYXBlRnVuY3Rpb24gPSB0aGlzLmZvY3VzRXNjYXBlRnVuY3Rpb247XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2Uub25LZXlTZWxlY3RcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpbmRleCA9PiB0aGlzLnNlbGVjdFllYXIodGhpcy5jYWxlbmRhclllYXJMaXN0W2luZGV4XSkpXG4gICAgICAgIDtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbkxpc3RTdGFydEFwcHJvYWNoXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5sb2FkUHJldmlvdXNZZWFyTGlzdCgpKVxuICAgICAgICA7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2Uub25MaXN0RW5kQXBwcm9hY2hcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWROZXh0WWVhckxpc3QoKSlcbiAgICAgICAgO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgYWN0aXZlIGNlbGwsIHdoaWNoIG1lYW5zOlxuICAgICAqIGlmIHRoZXJlIGlzIGFueSBzZWxlY3RlZCB5ZWFyLCByZXR1cm4gc2VsZWN0ZWQgeWVhclxuICAgICAqIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGVkIHllYXIsIGJ1dCB0aGVyZSBpcyBjdXJyZW50IHllYXIsIHJldHVybiBjdXJyZW50IHllYXJcbiAgICAgKiBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHllYXIsIG9yIHNlbGVjdGVkLCByZXR1cm4gZmlyc3Qgb25lXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRBY3RpdmVZZWFyKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkWWVhcjogbnVtYmVyID0gdGhpcy5jYWxlbmRhclllYXJMaXN0LmZpbmQoeWVhciA9PiB5ZWFyID09PSB0aGlzLnllYXJTZWxlY3RlZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZFllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFllYXI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50WWVhcjogbnVtYmVyID0gdGhpcy5jYWxlbmRhclllYXJMaXN0LmZpbmQoeWVhciA9PiB5ZWFyID09PSB0aGlzLmN1cnJlbnRZZWFyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRZZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclllYXJMaXN0WzBdO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgZm9yIGhhbmRsaW5nIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIG9uS2V5ZG93blllYXJIYW5kbGVyKGV2ZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uS2V5ZG93bkhhbmRsZXIoZXZlbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHVzZWQgdG8gbG9hZCB0aGUgcHJldmlvdXMgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWROZXh0WWVhckxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3RZZWFySW5MaXN0ICs9IDEyO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdFllYXJMaXN0KCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB1c2VkIHRvIGxvYWQgdGhlIG5leHQgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWRQcmV2aW91c1llYXJMaXN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0WWVhckluTGlzdCAtPSAxMjtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RZZWFyTGlzdCgpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgYWxsb3dpbmcgZm9jdXNpbmcgb24gZWxlbWVudHMgd2l0aGluIHRoaXMgY29tcG9uZW50LiAqL1xuICAgIGZvY3VzRWxlbWVudChlbGVtZW50U2VsZWN0b3I6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzOiBIVE1MRWxlbWVudCA9IHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50VG9Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgc2VuZHMgdGhlIHllYXIgdG8gdGhlIHBhcmVudCBjb21wb25lbnQgd2hlbiBpdCBpcyBjbGlja2VkLiAqL1xuICAgIHNlbGVjdFllYXIoc2VsZWN0ZWRZZWFyOiBudW1iZXIsIGV2ZW50PzogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueWVhclNlbGVjdGVkID0gc2VsZWN0ZWRZZWFyO1xuICAgICAgICB0aGlzLnllYXJDbGlja2VkLmVtaXQodGhpcy55ZWFyU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RZZWFyTGlzdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzcGxheWVkWWVhcnNBbW91bnQ6IG51bWJlciA9IDEyO1xuICAgICAgICB0aGlzLmNhbGVuZGFyWWVhckxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBkaXNwbGF5ZWRZZWFyc0Ftb3VudDsgKyt4KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyWWVhckxpc3QucHVzaCh0aGlzLmZpcnN0WWVhckluTGlzdCArIHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlWWVhciA9IHRoaXMuZ2V0QWN0aXZlWWVhcigpO1xuICAgIH1cbn1cbiJdfQ==