/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, forwardRef, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';
import { FdDate } from '../calendar/models/fd-date';
import { CalendarService } from '../calendar/calendar.service';
import { CalendarComponent } from '../calendar/calendar.component';
import { DateFormatParser } from './format/date-parser';
/**
 * The datetime picker component is an opinionated composition of the fd-popover and
 * fd-calendar components to accomplish the UI pattern for picking a date.
 *
 * Supports Angular Forms.
 * ```html
 * <fd-date-picker [(ngModel)]="date"></fd-date-picker>
 * ```
 */
var DatePickerComponent = /** @class */ (function () {
    /** @hidden */
    function DatePickerComponent(dateAdapter) {
        this.dateAdapter = dateAdapter;
        /**
         * @hidden The value of the input
         */
        this.inputFieldDate = null;
        /**
         * @hidden Whether the date input is invalid
         */
        this.isInvalidDateInput = false;
        /**
         * @hidden Whether the date picker is open
         */
        this.isOpen = false;
        /**
         * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
         */
        this.type = 'single';
        /**
         * Date picker input placeholder string
         */
        this.placeholder = 'mm/dd/yyyy';
        /**
         * Whether this is the compact input date picker
         */
        this.compact = false;
        /**
         * The currently selected FdDates model start and end in range mode.
         */
        this.selectedRangeDate = { start: null, end: null };
        /**
         * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
         */
        this.startingDayOfWeek = 1;
        /**
         * Whether to validate the date picker input.
         */
        this.useValidation = true;
        /**
         * Aria label for the datepicker input.
         */
        this.dateInputLabel = 'Date input';
        /**
         * Aria label for the button to show/hide the calendar.
         */
        this.displayCalendarToggleLabel = 'Display calendar toggle';
        /**
         * Whether a null input is considered valid.
         */
        this.allowNull = true;
        /**
         * Actually shown active view one of 'day' | 'month' | 'year' in calendar component
         */
        this.activeView = 'day';
        /**
         *  The placement of the popover. It can be one of: top, top-start, top-end, bottom,
         *  bottom-start, bottom-end, right, right-start, right-end, left, left-start, left-end.
         */
        this.placement = 'bottom-start';
        /**
         * Fired when a new date is selected.
         */
        this.selectedDateChange = new EventEmitter();
        /**
         * Event thrown every time selected first or last date in range mode is changed
         */
        this.selectedRangeDateChange = new EventEmitter();
        /**
         * Event thrown every time calendar active view is changed
         */
        this.activeViewChange = new EventEmitter();
        /**
         * @hidden
         */
        this.onChange = (/**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
        });
        /**
         * @hidden
         */
        this.onTouched = (/**
         * @return {?}
         */
        function () {
        });
        /**
         * Function used to disable certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.disableFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.disableRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.disableRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.blockRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.blockRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.blockFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
    }
    /**
     * Method that handle calendar active view change and throws event.
     */
    /**
     * Method that handle calendar active view change and throws event.
     * @param {?} activeView
     * @return {?}
     */
    DatePickerComponent.prototype.handleCalendarActiveViewChange = /**
     * Method that handle calendar active view change and throws event.
     * @param {?} activeView
     * @return {?}
     */
    function (activeView) {
        this.activeViewChange.emit(activeView);
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    DatePickerComponent.prototype.closeFromCalendar = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.type === 'single') {
            this.closeCalendar();
        }
    };
    /** Opens the calendar */
    /**
     * Opens the calendar
     * @return {?}
     */
    DatePickerComponent.prototype.openCalendar = /**
     * Opens the calendar
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this.onTouched();
            this.isOpen = true;
        }
    };
    /** Toggles the calendar open or closed */
    /**
     * Toggles the calendar open or closed
     * @return {?}
     */
    DatePickerComponent.prototype.toggleCalendar = /**
     * Toggles the calendar open or closed
     * @return {?}
     */
    function () {
        this.onTouched();
        this.isOpen = !this.isOpen;
    };
    /** Closes the calendar if it is open */
    /**
     * Closes the calendar if it is open
     * @return {?}
     */
    DatePickerComponent.prototype.closeCalendar = /**
     * Closes the calendar if it is open
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this.isOpen = false;
        }
    };
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected single date changed
     */
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected single date changed
     * @param {?} date
     * @return {?}
     */
    DatePickerComponent.prototype.handleSingleDateChange = /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected single date changed
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date) {
            this.inputFieldDate = this.dateAdapter.format(date);
            this.selectedDate = date;
            this.selectedDateChange.emit(date);
            this.onChange(date);
            this.isInvalidDateInput = !this.isModelValid();
        }
    };
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected range date changed
     */
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected range date changed
     * @param {?} dates
     * @return {?}
     */
    DatePickerComponent.prototype.handleRangeDateChange = /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected range date changed
     * @param {?} dates
     * @return {?}
     */
    function (dates) {
        if (dates &&
            (!CalendarService.datesEqual(this.selectedRangeDate.start, dates.start) ||
                !CalendarService.datesEqual(this.selectedRangeDate.end, dates.end))) {
            this.inputFieldDate = this.dateAdapter.format(dates.start) + this.dateAdapter.rangeDelimiter
                + this.dateAdapter.format(dates.end);
            this.selectedRangeDate = { start: dates.start, end: dates.end };
            this.selectedRangeDateChange.emit(this.selectedRangeDate);
            this.onChange(this.selectedRangeDate);
            this.isInvalidDateInput = !this.isModelValid();
        }
    };
    /**
     * @hidden
     * Method that is triggered when the text input is confirmed to ba changed, by clicking enter, or blur
     */
    /**
     * @hidden
     * Method that is triggered when the text input is confirmed to ba changed, by clicking enter, or blur
     * @param {?} strDate
     * @return {?}
     */
    DatePickerComponent.prototype.handleInputChange = /**
     * @hidden
     * Method that is triggered when the text input is confirmed to ba changed, by clicking enter, or blur
     * @param {?} strDate
     * @return {?}
     */
    function (strDate) {
        this.dateStringUpdate(strDate);
    };
    /**
     * @hidden
     * Function that implements Validator Interface, adds validation support for forms
     */
    /**
     * @hidden
     * Function that implements Validator Interface, adds validation support for forms
     * @param {?} control
     * @return {?}
     */
    DatePickerComponent.prototype.validate = /**
     * @hidden
     * Function that implements Validator Interface, adds validation support for forms
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this.isModelValid() ? null : {
            dateValidation: {
                valid: false
            }
        };
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    DatePickerComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    DatePickerComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    DatePickerComponent.prototype.setDisabledState = /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     * Function that provides support for ControlValueAccessor that allows to use [(ngModel)] or forms
     */
    /**
     * @hidden
     * Function that provides support for ControlValueAccessor that allows to use [(ngModel)] or forms
     * @param {?} selected
     * @return {?}
     */
    DatePickerComponent.prototype.writeValue = /**
     * @hidden
     * Function that provides support for ControlValueAccessor that allows to use [(ngModel)] or forms
     * @param {?} selected
     * @return {?}
     */
    function (selected) {
        /** If written value is not defined, null, empty string */
        if (!selected) {
            this.inputFieldDate = '';
            return;
        }
        if (this.type === 'single') {
            /**
             * For single mode, if the date is invalid, model is changed, it refresh currently
             * input field text, but it does not refresh currently displayed day
             */
            selected = (/** @type {?} */ (selected));
            this.selectedDate = selected;
            if (this.isModelValid()) {
                this.inputFieldDate = this.dateAdapter.format(selected);
                this.refreshCurrentlyDisplayedCalendarDate(selected);
            }
            else {
                this.inputFieldDate = '';
            }
        }
        else {
            /**
             * For range mode, if the date is invalid, model is changed, but it does not refresh currently
             * displayed day view, or input field text
             */
            selected = (/** @type {?} */ (selected));
            if (selected.start) {
                this.selectedRangeDate = { start: selected.start, end: selected.end };
                if (this.isModelValid()) {
                    this.refreshCurrentlyDisplayedCalendarDate(selected.start);
                    this.inputFieldDate = this.dateAdapter.format(selected.start) +
                        this.dateAdapter.rangeDelimiter + this.dateAdapter.format(selected.end);
                }
                else {
                    this.inputFieldDate = '';
                }
            }
            else {
                this.inputFieldDate = '';
            }
        }
        this.isInvalidDateInput = !this.isModelValid();
    };
    /**
     * @hidden
     * Method, which is responsible for transforming string to date, depending on type or
     * validation the results are different. It also changes to state of isInvalidDateInput
     */
    /**
     * @hidden
     * Method, which is responsible for transforming string to date, depending on type or
     * validation the results are different. It also changes to state of isInvalidDateInput
     * @param {?} date
     * @return {?}
     */
    DatePickerComponent.prototype.dateStringUpdate = /**
     * @hidden
     * Method, which is responsible for transforming string to date, depending on type or
     * validation the results are different. It also changes to state of isInvalidDateInput
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** Case when there is single mode */
        if (this.type === 'single') {
            /** @type {?} */
            var fdDate = this.dateAdapter.parse(date);
            /**
             * Check if dates are equal, if dates are the same there is no need to make any changes
             * Date in model is changed no matter if the parsed date fro string is valid or not.
             */
            if (!CalendarService.datesEqual(fdDate, this.selectedDate)) {
                this.isInvalidDateInput = !fdDate.isDateValid();
                this.selectedDate = fdDate;
                this.onChange(this.selectedDate);
                this.selectedDateChange.emit(this.selectedDate);
                /** Check if date is valid, if it's not, there is no need to refresh calendar */
                if (!this.isInvalidDateInput) {
                    this.refreshCurrentlyDisplayedCalendarDate(this.selectedDate);
                }
            }
            /** Case when there is range mode */
        }
        else {
            /** @type {?} */
            var currentDates = date.split(this.dateAdapter.rangeDelimiter);
            /** @type {?} */
            var firstDate = this.dateAdapter.parse(currentDates[0]);
            /** @type {?} */
            var secondDate = this.dateAdapter.parse(currentDates[1]);
            /**
             * Check if dates are equal, if dates are the same there is no need to make any changes
             * Date in model is changed no matter if the parsed dates from string are valid or not.
             */
            if (!CalendarService.datesEqual(firstDate, this.selectedRangeDate.start) ||
                !CalendarService.datesEqual(secondDate, this.selectedRangeDate.end)) {
                this.isInvalidDateInput = !firstDate.isDateValid() || !secondDate.isDateValid();
                /** If the end date is before the start date, there is need to replace them  */
                if ((firstDate.getTimeStamp() > secondDate.getTimeStamp()) && secondDate.isDateValid()) {
                    this.selectedRangeDate = { start: secondDate, end: firstDate };
                }
                else {
                    this.selectedRangeDate = { start: firstDate, end: secondDate };
                }
                this.selectedRangeDateChange.emit(this.selectedRangeDate);
                this.onChange({ start: this.selectedRangeDate.start, end: this.selectedRangeDate.end });
                /** Check if dates are valid, if it's not, there is no need o refresh calendar */
                if (!this.isInvalidDateInput) {
                    this.refreshCurrentlyDisplayedCalendarDate(this.selectedRangeDate.start);
                }
            }
        }
        if (!date && this.allowNull) {
            this.isInvalidDateInput = false;
        }
    };
    /** Method that provides information if model selected date/dates have properly types and are valid */
    /**
     * Method that provides information if model selected date/dates have properly types and are valid
     * @return {?}
     */
    DatePickerComponent.prototype.isModelValid = /**
     * Method that provides information if model selected date/dates have properly types and are valid
     * @return {?}
     */
    function () {
        if (this.type === 'single') {
            return this.selectedDate &&
                this.selectedDate instanceof FdDate &&
                this.selectedDate.isDateValid();
        }
        else {
            return this.selectedRangeDate &&
                (this.selectedRangeDate.start &&
                    this.selectedRangeDate.start instanceof FdDate &&
                    this.selectedRangeDate.start.isDateValid()) && (this.selectedRangeDate.end &&
                this.selectedRangeDate.end instanceof FdDate &&
                this.selectedRangeDate.end.isDateValid());
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    DatePickerComponent.prototype.refreshCurrentlyDisplayedCalendarDate = /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.calendarComponent) {
            this.calendarComponent.setCurrentlyDisplayed(date);
        }
    };
    DatePickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fd-date-picker',
                    template: "<fd-popover [(isOpen)]=\"isOpen\"\n            (isOpenChange)=\"handleInputChange(datePicker.value)\"\n            [triggers]=\"[]\"\n            [placement]=\"placement\"\n            [closeOnEscapeKey]=\"true\"\n            [disabled]=\"disabled\">\n    <fd-popover-control>\n        <fd-input-group [compact]=\"compact\">\n            <input #datePicker\n                   class=\"fd-input\"\n                   fd-input-group-input\n                   type=\"text\"\n                   [attr.aria-label]=\"dateInputLabel\"\n                   [value]=\"inputFieldDate\"\n                   [placeholder]=\"placeholder\"\n                   (keyup.enter)=\"handleInputChange(datePicker.value)\"\n                   (click)=\"openCalendar()\"\n                   [disabled]=\"disabled\"\n                   [ngClass]=\"{ 'fd-input--compact': compact, 'is-invalid': isInvalidDateInput && useValidation }\">\n            <span fd-input-group-addon [button]=\"true\">\n                <button [disabled]=\"disabled\" fd-button [glyph]=\"'calendar'\"\n                        [options]=\"'light'\"\n                        [compact]=\"compact\"\n                        (click)=\"toggleCalendar()\" [attr.aria-label]=\"displayCalendarToggleLabel\"\n                        [attr.aria-expanded]=\"isOpen\">\n                </button>\n            </span>\n        </fd-input-group>\n    </fd-popover-control>\n    <fd-popover-body\n        [style.display]=\"'block'\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-hidden]=\"!isOpen\">\n        <fd-calendar (closeCalendar)=\"closeFromCalendar()\"\n                     [activeView]=\"activeView\"\n                     (activeViewChange)=\"handleCalendarActiveViewChange($event)\"\n                     [calType]=\"type\"\n                     [disableFunction]=\"disableFunction ? disableFunction : null\"\n                     [blockFunction]=\"blockFunction ? blockFunction : null\"\n                     [disableRangeStartFunction]=\"disableRangeStartFunction ? disableRangeStartFunction : null\"\n                     [disableRangeEndFunction]=\"disableRangeEndFunction ? disableRangeEndFunction : null\"\n                     [blockRangeStartFunction]=\"blockRangeStartFunction ? blockRangeStartFunction : null\"\n                     [blockRangeEndFunction]=\"blockRangeEndFunction ? blockRangeEndFunction : null\"\n                     [selectedDate]=\"selectedDate\"\n                     [selectedRangeDate]=\"selectedRangeDate\"\n                     (selectedRangeDateChange)=\"handleRangeDateChange($event)\"\n                     (selectedDateChange)=\"handleSingleDateChange($event)\"\n                     [startingDayOfWeek]=\"startingDayOfWeek\"></fd-calendar>\n    </fd-popover-body>\n</fd-popover>\n",
                    host: {
                        '(blur)': 'onTouched()',
                        '[class.fd-date-picker]': 'true',
                        '[class.fd-date-picker-custom]': 'true'
                    },
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DatePickerComponent; })),
                            multi: true
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DatePickerComponent; })),
                            multi: true
                        }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    styles: [".fd-date-picker-custom{display:inline-block}.fd-date-picker-custom fd-popover{display:block}"]
                }] }
    ];
    /** @nocollapse */
    DatePickerComponent.ctorParameters = function () { return [
        { type: DateFormatParser }
    ]; };
    DatePickerComponent.propDecorators = {
        calendarComponent: [{ type: ViewChild, args: [CalendarComponent, { static: false },] }],
        type: [{ type: Input }],
        placeholder: [{ type: Input }],
        compact: [{ type: Input }],
        selectedDate: [{ type: Input }],
        selectedRangeDate: [{ type: Input }],
        startingDayOfWeek: [{ type: Input }],
        useValidation: [{ type: Input }],
        dateInputLabel: [{ type: Input }],
        displayCalendarToggleLabel: [{ type: Input }],
        allowNull: [{ type: Input }],
        activeView: [{ type: Input }],
        placement: [{ type: Input }],
        disabled: [{ type: Input }],
        selectedDateChange: [{ type: Output }],
        selectedRangeDateChange: [{ type: Output }],
        activeViewChange: [{ type: Output }],
        disableFunction: [{ type: Input }],
        disableRangeStartFunction: [{ type: Input }],
        disableRangeEndFunction: [{ type: Input }],
        blockRangeStartFunction: [{ type: Input }],
        blockRangeEndFunction: [{ type: Input }],
        blockFunction: [{ type: Input }]
    };
    return DatePickerComponent;
}());
export { DatePickerComponent };
if (false) {
    /**
     * @hidden The value of the input
     * @type {?}
     */
    DatePickerComponent.prototype.inputFieldDate;
    /**
     * @hidden Whether the date input is invalid
     * @type {?}
     */
    DatePickerComponent.prototype.isInvalidDateInput;
    /**
     * @hidden Whether the date picker is open
     * @type {?}
     */
    DatePickerComponent.prototype.isOpen;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.calendarComponent;
    /**
     * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
     * @type {?}
     */
    DatePickerComponent.prototype.type;
    /**
     * Date picker input placeholder string
     * @type {?}
     */
    DatePickerComponent.prototype.placeholder;
    /**
     * Whether this is the compact input date picker
     * @type {?}
     */
    DatePickerComponent.prototype.compact;
    /**
     * The currently selected CalendarDay model
     * @type {?}
     */
    DatePickerComponent.prototype.selectedDate;
    /**
     * The currently selected FdDates model start and end in range mode.
     * @type {?}
     */
    DatePickerComponent.prototype.selectedRangeDate;
    /**
     * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
     * @type {?}
     */
    DatePickerComponent.prototype.startingDayOfWeek;
    /**
     * Whether to validate the date picker input.
     * @type {?}
     */
    DatePickerComponent.prototype.useValidation;
    /**
     * Aria label for the datepicker input.
     * @type {?}
     */
    DatePickerComponent.prototype.dateInputLabel;
    /**
     * Aria label for the button to show/hide the calendar.
     * @type {?}
     */
    DatePickerComponent.prototype.displayCalendarToggleLabel;
    /**
     * Whether a null input is considered valid.
     * @type {?}
     */
    DatePickerComponent.prototype.allowNull;
    /**
     * Actually shown active view one of 'day' | 'month' | 'year' in calendar component
     * @type {?}
     */
    DatePickerComponent.prototype.activeView;
    /**
     *  The placement of the popover. It can be one of: top, top-start, top-end, bottom,
     *  bottom-start, bottom-end, right, right-start, right-end, left, left-start, left-end.
     * @type {?}
     */
    DatePickerComponent.prototype.placement;
    /**
     * Whether the date picker is disabled.
     * @type {?}
     */
    DatePickerComponent.prototype.disabled;
    /**
     * Fired when a new date is selected.
     * @type {?}
     */
    DatePickerComponent.prototype.selectedDateChange;
    /**
     * Event thrown every time selected first or last date in range mode is changed
     * @type {?}
     */
    DatePickerComponent.prototype.selectedRangeDateChange;
    /**
     * Event thrown every time calendar active view is changed
     * @type {?}
     */
    DatePickerComponent.prototype.activeViewChange;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.onChange;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.onTouched;
    /**
     * Function used to disable certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableFunction;
    /**
     * Function used to disable certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableRangeStartFunction;
    /**
     * Function used to disable certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockRangeStartFunction;
    /**
     * Function used to block certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockFunction;
    /** @type {?} */
    DatePickerComponent.prototype.dateAdapter;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLEtBQUssRUFDTCxNQUFNLEVBQUUsU0FBUyxFQUNqQixpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUF5QyxhQUFhLEVBQUUsaUJBQWlCLEVBQWEsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwSCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRW5FLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDOzs7Ozs7Ozs7O0FBV3hEO0lBbVBJLGNBQWM7SUFDZCw2QkFDVyxXQUE2QjtRQUE3QixnQkFBVyxHQUFYLFdBQVcsQ0FBa0I7Ozs7UUEzTnhDLG1CQUFjLEdBQUcsSUFBSSxDQUFDOzs7O1FBR3RCLHVCQUFrQixHQUFZLEtBQUssQ0FBQzs7OztRQUdwQyxXQUFNLEdBQVksS0FBSyxDQUFDOzs7O1FBUXhCLFNBQUksR0FBaUIsUUFBUSxDQUFDOzs7O1FBSTlCLGdCQUFXLEdBQVcsWUFBWSxDQUFDOzs7O1FBSW5DLFlBQU8sR0FBWSxLQUFLLENBQUM7Ozs7UUFRbEIsc0JBQWlCLEdBQWdCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUM7Ozs7UUFJbkUsc0JBQWlCLEdBQWUsQ0FBQyxDQUFDOzs7O1FBSWxDLGtCQUFhLEdBQVksSUFBSSxDQUFDOzs7O1FBSTlC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Z0NBSUwsS0FBSztpQ0FJTCxLQUFLOzZDQUlMLEtBQUs7NEJBSUwsS0FBSzs2QkFJTCxLQUFLOzRCQU9MLEtBQUs7MkJBSUwsS0FBSztxQ0FJTCxNQUFNOzBDQUlOLE1BQU07bUNBSU4sTUFBTTtrQ0FlTixLQUFLOzRDQVNMLEtBQUs7MENBU0wsS0FBSzswQ0FTTCxLQUFLO3dDQVNMLEtBQUs7Z0NBU0wsS0FBSzs7SUFnUVYsMEJBQUM7Q0FBQSxBQWxhRCxJQWthQztTQTNZWSxtQkFBbUI7Ozs7OztJQUc1Qiw2Q0FBc0I7Ozs7O0lBR3RCLGlEQUFvQzs7Ozs7SUFHcEMscUNBQXdCOzs7OztJQUd4QixnREFDcUM7Ozs7O0lBR3JDLG1DQUM4Qjs7Ozs7SUFHOUIsMENBQ21DOzs7OztJQUduQyxzQ0FDeUI7Ozs7O0lBR3pCLDJDQUNxQjs7Ozs7SUFHckIsZ0RBQ21FOzs7OztJQUduRSxnREFDa0M7Ozs7O0lBR2xDLDRDQUM4Qjs7Ozs7SUFHOUIsNkNBQ3NDOzs7OztJQUd0Qyx5REFDK0Q7Ozs7O0lBRy9ELHdDQUMwQjs7Ozs7SUFHMUIseUNBQzBDOzs7Ozs7SUFNMUMsd0NBQ3NDOzs7OztJQUd0Qyx1Q0FDa0I7Ozs7O0lBR2xCLGlEQUNzRjs7Ozs7SUFHdEYsc0RBQ3FHOzs7OztJQUdyRywrQ0FDb0c7Ozs7O0lBR3BHLHVDQUNFOzs7OztJQUdGLHdDQUNFOzs7Ozs7SUFNRiw4Q0FHRTs7Ozs7O0lBTUYsd0RBR0U7Ozs7OztJQU1GLHNEQUdFOzs7Ozs7SUFNRixzREFHRTs7Ozs7O0lBTUYsb0RBR0U7Ozs7OztJQU1GLDRDQUdFOztJQWdGRSwwQ0FBb0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENhbGVuZGFyVHlwZSwgRGF5c09mV2VlaywgRmRDYWxlbmRhclZpZXcgfSBmcm9tICcuLi9jYWxlbmRhci9jYWxlbmRhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFBsYWNlbWVudCB9IGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgeyBGZERhdGUgfSBmcm9tICcuLi9jYWxlbmRhci9tb2RlbHMvZmQtZGF0ZSc7XG5pbXBvcnQgeyBDYWxlbmRhclNlcnZpY2UgfSBmcm9tICcuLi9jYWxlbmRhci9jYWxlbmRhci5zZXJ2aWNlJztcbmltcG9ydCB7IENhbGVuZGFyQ29tcG9uZW50IH0gZnJvbSAnLi4vY2FsZW5kYXIvY2FsZW5kYXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZkUmFuZ2VEYXRlIH0gZnJvbSAnLi4vY2FsZW5kYXIvbW9kZWxzL2ZkLXJhbmdlLWRhdGUnO1xuaW1wb3J0IHsgRGF0ZUZvcm1hdFBhcnNlciB9IGZyb20gJy4vZm9ybWF0L2RhdGUtcGFyc2VyJztcblxuLyoqXG4gKiBUaGUgZGF0ZXRpbWUgcGlja2VyIGNvbXBvbmVudCBpcyBhbiBvcGluaW9uYXRlZCBjb21wb3NpdGlvbiBvZiB0aGUgZmQtcG9wb3ZlciBhbmRcbiAqIGZkLWNhbGVuZGFyIGNvbXBvbmVudHMgdG8gYWNjb21wbGlzaCB0aGUgVUkgcGF0dGVybiBmb3IgcGlja2luZyBhIGRhdGUuXG4gKlxuICogU3VwcG9ydHMgQW5ndWxhciBGb3Jtcy5cbiAqIGBgYGh0bWxcbiAqIDxmZC1kYXRlLXBpY2tlciBbKG5nTW9kZWwpXT1cImRhdGVcIj48L2ZkLWRhdGUtcGlja2VyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZmQtZGF0ZS1waWNrZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZGF0ZS1waWNrZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBob3N0OiB7XG4gICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknLFxuICAgICAgICAnW2NsYXNzLmZkLWRhdGUtcGlja2VyXSc6ICd0cnVlJyxcbiAgICAgICAgJ1tjbGFzcy5mZC1kYXRlLXBpY2tlci1jdXN0b21dJzogJ3RydWUnXG4gICAgfSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlUGlja2VyQ29tcG9uZW50KSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlUGlja2VyQ29tcG9uZW50KSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gICAgLyoqIEBoaWRkZW4gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICAgIGlucHV0RmllbGREYXRlID0gbnVsbDtcblxuICAgIC8qKiBAaGlkZGVuIFdoZXRoZXIgdGhlIGRhdGUgaW5wdXQgaXMgaW52YWxpZCAqL1xuICAgIGlzSW52YWxpZERhdGVJbnB1dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEBoaWRkZW4gV2hldGhlciB0aGUgZGF0ZSBwaWNrZXIgaXMgb3BlbiAqL1xuICAgIGlzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKENhbGVuZGFyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBjYWxlbmRhckNvbXBvbmVudDogQ2FsZW5kYXJDb21wb25lbnQ7XG5cbiAgICAvKiogVGhlIHR5cGUgb2YgY2FsZW5kYXIsICdzaW5nbGUnIGZvciBzaW5nbGUgZGF0ZSBzZWxlY3Rpb24gb3IgJ3JhbmdlJyBmb3IgYSByYW5nZSBvZiBkYXRlcy4gKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IENhbGVuZGFyVHlwZSA9ICdzaW5nbGUnO1xuXG4gICAgLyoqIERhdGUgcGlja2VyIGlucHV0IHBsYWNlaG9sZGVyIHN0cmluZyAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICdtbS9kZC95eXl5JztcblxuICAgIC8qKiBXaGV0aGVyIHRoaXMgaXMgdGhlIGNvbXBhY3QgaW5wdXQgZGF0ZSBwaWNrZXIgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbXBhY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIENhbGVuZGFyRGF5IG1vZGVsICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZERhdGU6IEZkRGF0ZTtcblxuICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIEZkRGF0ZXMgbW9kZWwgc3RhcnQgYW5kIGVuZCBpbiByYW5nZSBtb2RlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkUmFuZ2VEYXRlOiBGZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgLyoqIFRoZSBkYXkgb2YgdGhlIHdlZWsgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBvbi4gMSByZXByZXNlbnRzIFN1bmRheSwgMiBpcyBNb25kYXksIDMgaXMgVHVlc2RheSwgYW5kIHNvIG9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RhcnRpbmdEYXlPZldlZWs6IERheXNPZldlZWsgPSAxO1xuXG4gICAgLyoqIFdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIGRhdGUgcGlja2VyIGlucHV0LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlVmFsaWRhdGlvbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogQXJpYSBsYWJlbCBmb3IgdGhlIGRhdGVwaWNrZXIgaW5wdXQuICovXG4gICAgQElucHV0KClcbiAgICBkYXRlSW5wdXRMYWJlbDogc3RyaW5nID0gJ0RhdGUgaW5wdXQnO1xuXG4gICAgLyoqIEFyaWEgbGFiZWwgZm9yIHRoZSBidXR0b24gdG8gc2hvdy9oaWRlIHRoZSBjYWxlbmRhci4gKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlDYWxlbmRhclRvZ2dsZUxhYmVsOiBzdHJpbmcgPSAnRGlzcGxheSBjYWxlbmRhciB0b2dnbGUnO1xuXG4gICAgLyoqIFdoZXRoZXIgYSBudWxsIGlucHV0IGlzIGNvbnNpZGVyZWQgdmFsaWQuICovXG4gICAgQElucHV0KClcbiAgICBhbGxvd051bGw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEFjdHVhbGx5IHNob3duIGFjdGl2ZSB2aWV3IG9uZSBvZiAnZGF5JyB8ICdtb250aCcgfCAneWVhcicgaW4gY2FsZW5kYXIgY29tcG9uZW50Ki9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBhY3RpdmVWaWV3OiBGZENhbGVuZGFyVmlldyA9ICdkYXknO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcG92ZXIuIEl0IGNhbiBiZSBvbmUgb2Y6IHRvcCwgdG9wLXN0YXJ0LCB0b3AtZW5kLCBib3R0b20sXG4gICAgICogIGJvdHRvbS1zdGFydCwgYm90dG9tLWVuZCwgcmlnaHQsIHJpZ2h0LXN0YXJ0LCByaWdodC1lbmQsIGxlZnQsIGxlZnQtc3RhcnQsIGxlZnQtZW5kLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGxhY2VtZW50OiBQbGFjZW1lbnQgPSAnYm90dG9tLXN0YXJ0JztcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBkYXRlIHBpY2tlciBpcyBkaXNhYmxlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIEZpcmVkIHdoZW4gYSBuZXcgZGF0ZSBpcyBzZWxlY3RlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VsZWN0ZWREYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmREYXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmREYXRlPigpO1xuXG4gICAgLyoqIEV2ZW50IHRocm93biBldmVyeSB0aW1lIHNlbGVjdGVkIGZpcnN0IG9yIGxhc3QgZGF0ZSBpbiByYW5nZSBtb2RlIGlzIGNoYW5nZWQgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGZFJhbmdlRGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZkUmFuZ2VEYXRlPigpO1xuXG4gICAgLyoqIEV2ZW50IHRocm93biBldmVyeSB0aW1lIGNhbGVuZGFyIGFjdGl2ZSB2aWV3IGlzIGNoYW5nZWQgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgYWN0aXZlVmlld0NoYW5nZTogRXZlbnRFbWl0dGVyPEZkQ2FsZW5kYXJWaWV3PiA9IG5ldyBFdmVudEVtaXR0ZXI8RmRDYWxlbmRhclZpZXc+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG9uQ2hhbmdlOiBhbnkgPSAoc2VsZWN0ZWQ6IGFueSkgPT4ge1xuICAgIH07XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG9uVG91Y2hlZDogYW55ID0gKCkgPT4ge1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRpc2FibGUgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIuXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBkaXNhYmxlIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyIGZvciB0aGUgcmFuZ2Ugc3RhcnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlUmFuZ2VTdGFydEZ1bmN0aW9uID0gZnVuY3Rpb24oZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRpc2FibGUgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBlbmQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlUmFuZ2VFbmRGdW5jdGlvbiA9IGZ1bmN0aW9uKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBibG9jayBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIHN0YXJ0IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmxvY2tSYW5nZVN0YXJ0RnVuY3Rpb24gPSBmdW5jdGlvbihmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gYmxvY2sgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBlbmQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBibG9ja1JhbmdlRW5kRnVuY3Rpb24gPSBmdW5jdGlvbihmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gYmxvY2sgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIuXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJsb2NrRnVuY3Rpb24gPSBmdW5jdGlvbihmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGhhbmRsZSBjYWxlbmRhciBhY3RpdmUgdmlldyBjaGFuZ2UgYW5kIHRocm93cyBldmVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlQ2FsZW5kYXJBY3RpdmVWaWV3Q2hhbmdlKGFjdGl2ZVZpZXc6IEZkQ2FsZW5kYXJWaWV3KTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlld0NoYW5nZS5lbWl0KGFjdGl2ZVZpZXcpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGNsb3NlRnJvbUNhbGVuZGFyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNhbGVuZGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogT3BlbnMgdGhlIGNhbGVuZGFyICovXG4gICAgb3BlbkNhbGVuZGFyKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlcyB0aGUgY2FsZW5kYXIgb3BlbiBvciBjbG9zZWQgKi9cbiAgICBwdWJsaWMgdG9nZ2xlQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gIXRoaXMuaXNPcGVuO1xuICAgIH1cblxuICAgIC8qKiBDbG9zZXMgdGhlIGNhbGVuZGFyIGlmIGl0IGlzIG9wZW4gKi9cbiAgICBwdWJsaWMgY2xvc2VDYWxlbmRhcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCB0aGF0IGlzIHRyaWdnZXJlZCBieSBldmVudHMgZnJvbSBjYWxlbmRhciBjb21wb25lbnQsIHdoZW4gdGhlcmUgaXMgc2VsZWN0ZWQgc2luZ2xlIGRhdGUgY2hhbmdlZFxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVTaW5nbGVEYXRlQ2hhbmdlKGRhdGU6IEZkRGF0ZSk6IHZvaWQge1xuICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmlzSW52YWxpZERhdGVJbnB1dCA9ICF0aGlzLmlzTW9kZWxWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCB0aGF0IGlzIHRyaWdnZXJlZCBieSBldmVudHMgZnJvbSBjYWxlbmRhciBjb21wb25lbnQsIHdoZW4gdGhlcmUgaXMgc2VsZWN0ZWQgcmFuZ2UgZGF0ZSBjaGFuZ2VkXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZVJhbmdlRGF0ZUNoYW5nZShkYXRlczogRmRSYW5nZURhdGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRhdGVzICYmXG4gICAgICAgICAgICAoIUNhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQsIGRhdGVzLnN0YXJ0KSB8fFxuICAgICAgICAgICAgICAgICFDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCwgZGF0ZXMuZW5kKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZXMuc3RhcnQpICsgdGhpcy5kYXRlQWRhcHRlci5yYW5nZURlbGltaXRlclxuICAgICAgICAgICAgICAgICsgdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZXMuZW5kKVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IGRhdGVzLnN0YXJ0LCBlbmQ6IGRhdGVzLmVuZCB9O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZUNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkRGF0ZUlucHV0ID0gIXRoaXMuaXNNb2RlbFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHRleHQgaW5wdXQgaXMgY29uZmlybWVkIHRvIGJhIGNoYW5nZWQsIGJ5IGNsaWNraW5nIGVudGVyLCBvciBibHVyXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUlucHV0Q2hhbmdlKHN0ckRhdGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVTdHJpbmdVcGRhdGUoc3RyRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGRhdGVBZGFwdGVyOiBEYXRlRm9ybWF0UGFyc2VyXG4gICAgKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaW1wbGVtZW50cyBWYWxpZGF0b3IgSW50ZXJmYWNlLCBhZGRzIHZhbGlkYXRpb24gc3VwcG9ydCBmb3IgZm9ybXNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH0ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc01vZGVsVmFsaWQoKSA/IG51bGwgOiB7XG4gICAgICAgICAgICBkYXRlVmFsaWRhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoc2VsZWN0ZWQ6IGFueSkgPT4geyB2b2lkIH0pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHN1cHBvcnQgZm9yIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHRoYXQgYWxsb3dzIHRvIHVzZSBbKG5nTW9kZWwpXSBvciBmb3Jtc1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUoc2VsZWN0ZWQ6IEZkUmFuZ2VEYXRlIHwgRmREYXRlKTogdm9pZCB7XG4gICAgICAgIC8qKiBJZiB3cml0dGVuIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCBudWxsLCBlbXB0eSBzdHJpbmcgKi9cbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBzaW5nbGUgbW9kZSwgaWYgdGhlIGRhdGUgaXMgaW52YWxpZCwgbW9kZWwgaXMgY2hhbmdlZCwgaXQgcmVmcmVzaCBjdXJyZW50bHlcbiAgICAgICAgICAgICAqIGlucHV0IGZpZWxkIHRleHQsIGJ1dCBpdCBkb2VzIG5vdCByZWZyZXNoIGN1cnJlbnRseSBkaXNwbGF5ZWQgZGF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdGVkID0gPEZkRGF0ZT5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01vZGVsVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLmZvcm1hdChzZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciByYW5nZSBtb2RlLCBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkLCBtb2RlbCBpcyBjaGFuZ2VkLCBidXQgaXQgZG9lcyBub3QgcmVmcmVzaCBjdXJyZW50bHlcbiAgICAgICAgICAgICAqIGRpc3BsYXllZCBkYXkgdmlldywgb3IgaW5wdXQgZmllbGQgdGV4dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWxlY3RlZCA9IDxGZFJhbmdlRGF0ZT5zZWxlY3RlZDtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IHNlbGVjdGVkLnN0YXJ0LCBlbmQ6IHNlbGVjdGVkLmVuZCB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNNb2RlbFZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKHNlbGVjdGVkLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHNlbGVjdGVkLnN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGVBZGFwdGVyLnJhbmdlRGVsaW1pdGVyICsgdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQoc2VsZWN0ZWQuZW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgPSAhdGhpcy5pc01vZGVsVmFsaWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgdHJhbnNmb3JtaW5nIHN0cmluZyB0byBkYXRlLCBkZXBlbmRpbmcgb24gdHlwZSBvclxuICAgICAqIHZhbGlkYXRpb24gdGhlIHJlc3VsdHMgYXJlIGRpZmZlcmVudC4gSXQgYWxzbyBjaGFuZ2VzIHRvIHN0YXRlIG9mIGlzSW52YWxpZERhdGVJbnB1dFxuICAgICAqL1xuICAgIGRhdGVTdHJpbmdVcGRhdGUoZGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8qKiBDYXNlIHdoZW4gdGhlcmUgaXMgc2luZ2xlIG1vZGUgKi9cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3NpbmdsZScpIHtcblxuICAgICAgICAgICAgY29uc3QgZmREYXRlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShkYXRlKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiBkYXRlcyBhcmUgZXF1YWwsIGlmIGRhdGVzIGFyZSB0aGUgc2FtZSB0aGVyZSBpcyBubyBuZWVkIHRvIG1ha2UgYW55IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERhdGUgaW4gbW9kZWwgaXMgY2hhbmdlZCBubyBtYXR0ZXIgaWYgdGhlIHBhcnNlZCBkYXRlIGZybyBzdHJpbmcgaXMgdmFsaWQgb3Igbm90LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIUNhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZkRGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgPSAhZmREYXRlLmlzRGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBmZERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAvKiogQ2hlY2sgaWYgZGF0ZSBpcyB2YWxpZCwgaWYgaXQncyBub3QsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVmcmVzaCBjYWxlbmRhciAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludmFsaWREYXRlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKHRoaXMuc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLyoqIENhc2Ugd2hlbiB0aGVyZSBpcyByYW5nZSBtb2RlICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGF0ZXMgPSBkYXRlLnNwbGl0KHRoaXMuZGF0ZUFkYXB0ZXIucmFuZ2VEZWxpbWl0ZXIpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3REYXRlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShjdXJyZW50RGF0ZXNbMF0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kRGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2UoY3VycmVudERhdGVzWzFdKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiBkYXRlcyBhcmUgZXF1YWwsIGlmIGRhdGVzIGFyZSB0aGUgc2FtZSB0aGVyZSBpcyBubyBuZWVkIHRvIG1ha2UgYW55IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERhdGUgaW4gbW9kZWwgaXMgY2hhbmdlZCBubyBtYXR0ZXIgaWYgdGhlIHBhcnNlZCBkYXRlcyBmcm9tIHN0cmluZyBhcmUgdmFsaWQgb3Igbm90LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIUNhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZpcnN0RGF0ZSwgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCkgfHxcbiAgICAgICAgICAgICAgICAhQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoc2Vjb25kRGF0ZSwgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQpKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmlzSW52YWxpZERhdGVJbnB1dCA9ICFmaXJzdERhdGUuaXNEYXRlVmFsaWQoKSB8fCAhc2Vjb25kRGF0ZS5pc0RhdGVWYWxpZCgpO1xuXG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBlbmQgZGF0ZSBpcyBiZWZvcmUgdGhlIHN0YXJ0IGRhdGUsIHRoZXJlIGlzIG5lZWQgdG8gcmVwbGFjZSB0aGVtICAqL1xuICAgICAgICAgICAgICAgIGlmICgoZmlyc3REYXRlLmdldFRpbWVTdGFtcCgpID4gc2Vjb25kRGF0ZS5nZXRUaW1lU3RhbXAoKSkgJiYgc2Vjb25kRGF0ZS5pc0RhdGVWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgPSB7IHN0YXJ0OiBzZWNvbmREYXRlLCBlbmQ6IGZpcnN0RGF0ZSB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgPSB7IHN0YXJ0OiBmaXJzdERhdGUsIGVuZDogc2Vjb25kRGF0ZSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHsgc3RhcnQ6IHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQsIGVuZDogdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQgfSk7XG5cbiAgICAgICAgICAgICAgICAvKiogQ2hlY2sgaWYgZGF0ZXMgYXJlIHZhbGlkLCBpZiBpdCdzIG5vdCwgdGhlcmUgaXMgbm8gbmVlZCBvIHJlZnJlc2ggY2FsZW5kYXIgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnZhbGlkRGF0ZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEN1cnJlbnRseURpc3BsYXllZENhbGVuZGFyRGF0ZSh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGUgJiYgdGhpcy5hbGxvd051bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkRGF0ZUlucHV0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgcHJvdmlkZXMgaW5mb3JtYXRpb24gaWYgbW9kZWwgc2VsZWN0ZWQgZGF0ZS9kYXRlcyBoYXZlIHByb3Blcmx5IHR5cGVzIGFuZCBhcmUgdmFsaWQgKi9cbiAgICBwdWJsaWMgaXNNb2RlbFZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWREYXRlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgaW5zdGFuY2VvZiBGZERhdGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZS5pc0RhdGVWYWxpZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiZcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCBpbnN0YW5jZW9mIEZkRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LmlzRGF0ZVZhbGlkKClcbiAgICAgICAgICAgICAgICApICYmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQgaW5zdGFuY2VvZiBGZERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQuaXNEYXRlVmFsaWQoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgcmVmcmVzaEN1cnJlbnRseURpc3BsYXllZENhbGVuZGFyRGF0ZShkYXRlOiBGZERhdGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJDb21wb25lbnQuc2V0Q3VycmVudGx5RGlzcGxheWVkKGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iXX0=