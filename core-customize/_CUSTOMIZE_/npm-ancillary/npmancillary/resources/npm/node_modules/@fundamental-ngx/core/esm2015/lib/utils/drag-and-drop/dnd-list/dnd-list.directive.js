/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ContentChildren, Directive, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { DndContainerDirective } from '../dnd-container/dnd-container.directive';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/**
 * @record
 */
export function ElementChord() { }
if (false) {
    /** @type {?} */
    ElementChord.prototype.x;
    /** @type {?} */
    ElementChord.prototype.y;
    /** @type {?} */
    ElementChord.prototype.position;
}
export class DndListDirective {
    constructor() {
        /**
         * Defines if the distance between elements should be counted only by vertical distance
         */
        this.listMode = false;
        /**
         * Event that is thrown, when the item is dropped
         */
        this.itemsChange = new EventEmitter();
        /**
         * @hidden
         */
        this.draggedItemIndex = 1000000;
        /**
         * @hidden
         */
        this.closestLinkIndex = null;
        /**
         * @hidden
         */
        this.closestLinkPosition = null;
        /**
         * An RxJS Subject that will kill the current data stream (for unsubscribing)
         */
        this.refresh$ = new Subject();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.refreshQueryList();
        this.dndContainerItems.changes.subscribe((/**
         * @return {?}
         */
        () => this.refreshQueryList()));
    }
    /**
     * Method called, when the item is being moved by 1 px
     * @param {?} event
     * @return {?}
     */
    onMove(event) {
        /** @type {?} */
        const distances = [];
        /**
         * Taking mouse position
         * @type {?}
         */
        const mousePosition = event.pointerPosition;
        /** Counting the distances by the mileage of the corner of element and cursor position */
        this.elementChords.forEach((/**
         * @param {?} linkChord
         * @return {?}
         */
        linkChord => {
            /** @type {?} */
            const distance = Math.hypot(linkChord.x - mousePosition.x, linkChord.y - mousePosition.y);
            distances.push(distance);
        }));
        /**
         * Checking closest element
         * @type {?}
         */
        const closeLinkIndex = distances.indexOf(Math.min(...distances));
        /** If the closest element is different than the old one, new one is picked. It prevents from performance issues */
        if (closeLinkIndex !== this.closestLinkIndex) {
            this.closestLinkIndex = closeLinkIndex;
            this.closestLinkPosition = this.elementChords[closeLinkIndex].position;
            /** Generating line, that shows where the element will be placed, on drop */
            this.generateLine(this.closestLinkIndex, this.closestLinkPosition);
        }
    }
    /**
     * Method called, when element is started to be dragged
     * @param {?} ind
     * @return {?}
     */
    dragStart(ind) {
        this.draggedItemIndex = ind;
        /** @type {?} */
        const draggedItemElement = this.dndContainerItems.toArray()[ind].element;
        /** Counting all of the elements's chords */
        this.elementChords = this.dndContainerItems.toArray().map((/**
         * @param {?} link
         * @return {?}
         */
        (link) => {
            return link.getElementChord(this.isBefore(draggedItemElement, link.element), this.listMode);
        }));
    }
    /**
     * Method called, when element is released
     * @return {?}
     */
    dragEnd() {
        /** @type {?} */
        const draggedItemIndex = this.draggedItemIndex;
        /** @type {?} */
        const replacedItemIndex = this.closestLinkIndex;
        /** @type {?} */
        const draggedItem = this.items[draggedItemIndex];
        if (draggedItemIndex < replacedItemIndex) {
            for (let i = draggedItemIndex; i < replacedItemIndex; i++) {
                this.items[i] = this.items[i + 1];
            }
        }
        else {
            for (let i = draggedItemIndex; i > replacedItemIndex; i--) {
                this.items[i] = this.items[i - 1];
            }
        }
        /** Replacing items */
        this.items[replacedItemIndex] = draggedItem;
        this.itemsChange.emit(this.items);
        this.removeAllLines();
        /** Reset */
        this.elementChords = [];
        this.closestLinkIndex = null;
        this.closestLinkPosition = null;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    removeAllLines() {
        this.dndContainerItems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => item.removeLine()));
    }
    /**
     * @hidden
     * @private
     * @param {?} closestLinkIndex
     * @param {?} linkPosition
     * @return {?}
     */
    generateLine(closestLinkIndex, linkPosition) {
        this.removeAllLines();
        this.dndContainerItems.toArray()[closestLinkIndex].createLine(linkPosition, this.listMode);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    refreshQueryList() {
        this.refresh$.next();
        this.dndContainerItems.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.moved.pipe(takeUntil(this.refresh$)).subscribe((/**
             * @param {?} eventMove
             * @return {?}
             */
            eventMove => this.onMove(eventMove)));
            item.started.pipe(takeUntil(this.refresh$)).subscribe((/**
             * @return {?}
             */
            () => this.dragStart(index)));
            item.released.pipe(takeUntil(this.refresh$)).subscribe((/**
             * @return {?}
             */
            () => this.dragEnd()));
        }));
    }
    /**
     * @hidden
     * Return information if element is placed before the dragged element
     * @private
     * @param {?} draggedElement
     * @param {?} targetElement
     * @return {?}
     */
    isBefore(draggedElement, targetElement) {
        /**
         * Sometimes the element are not straight in one column, that's why offset is needed
         * @type {?}
         */
        const VERTICAL_OFFSET = 20;
        /**
         * Distances from the top of screen
         * @type {?}
         */
        const draggedElementBound = (/** @type {?} */ (draggedElement.nativeElement.getBoundingClientRect()));
        /** @type {?} */
        const targetElementBound = (/** @type {?} */ (targetElement.nativeElement.getBoundingClientRect()));
        if (draggedElementBound.y - targetElementBound.y > VERTICAL_OFFSET) {
            /** If element is higher than the dragged element, it's for sure before */
            return true;
        }
        else if (targetElementBound.y - draggedElementBound.y > VERTICAL_OFFSET) {
            /** If element is lower than the dragged element, it's for sure after */
            return false;
        }
        else {
            /** If elements are in same level, the horizontal position decides if it's before/after */
            return draggedElementBound.x - targetElementBound.x > 0;
        }
    }
}
DndListDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[fd-dnd-list]',
            },] }
];
DndListDirective.propDecorators = {
    dndContainerItems: [{ type: ContentChildren, args: [DndContainerDirective,] }],
    listMode: [{ type: Input }],
    items: [{ type: Input }],
    itemsChange: [{ type: Output }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    DndListDirective.prototype.dndContainerItems;
    /**
     * Defines if the distance between elements should be counted only by vertical distance
     * @type {?}
     */
    DndListDirective.prototype.listMode;
    /**
     * Array of items, that will be sorted
     * @type {?}
     */
    DndListDirective.prototype.items;
    /**
     * Event that is thrown, when the item is dropped
     * @type {?}
     */
    DndListDirective.prototype.itemsChange;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.elementChords;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.draggedItemIndex;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.closestLinkIndex;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.closestLinkPosition;
    /**
     * An RxJS Subject that will kill the current data stream (for unsubscribing)
     * @type {?}
     * @private
     */
    DndListDirective.prototype.refresh$;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG5kLWxpc3QuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL2RyYWctYW5kLWRyb3AvZG5kLWxpc3QvZG5kLWxpc3QuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQW9CLGVBQWUsRUFBRSxTQUFTLEVBQWMsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXpJLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBSzNDLGtDQUlDOzs7SUFIRyx5QkFBVTs7SUFDVix5QkFBVTs7SUFDVixnQ0FBdUI7O0FBTzNCLE1BQU0sT0FBTyxnQkFBZ0I7SUFKN0I7Ozs7UUFZSSxhQUFRLEdBQVksS0FBSyxDQUFDOzs7O1FBUWpCLGdCQUFXLEdBQTZCLElBQUksWUFBWSxFQUFPLENBQUM7Ozs7UUFNakUscUJBQWdCLEdBQVcsT0FBTyxDQUFDOzs7O1FBR25DLHFCQUFnQixHQUFXLElBQUksQ0FBQzs7OztRQUdoQyx3QkFBbUIsR0FBdUIsSUFBSSxDQUFDOzs7O1FBR3RDLGFBQVEsR0FBa0IsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQXlIbkUsQ0FBQzs7Ozs7SUF0SFUsa0JBQWtCO1FBQ3JCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsU0FBUzs7O1FBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUMsQ0FBQztJQUM1RSxDQUFDOzs7Ozs7SUFHRCxNQUFNLENBQUMsS0FBa0I7O2NBQ2YsU0FBUyxHQUFr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QUNqRixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7Ozs7OztJQU1PLFFBQVEsQ0FBQyxjQUEwQixFQUFFLGFBQXlCOzs7OztjQUc1RCxlQUFlLEdBQVcsRUFBRTs7Ozs7Y0FHNUIsbUJBQW1CLEdBQUcsbUJBQVMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxFQUFBOztjQUNuRixrQkFBa0IsR0FBRyxtQkFBUyxhQUFhLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLEVBQUE7UUFFdkYsSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxHQUFHLGVBQWUsRUFBRTtZQUNoRSwwRUFBMEU7WUFDMUUsT0FBTyxJQUFJLENBQUM7U0FDZjthQUFNLElBQUksa0JBQWtCLENBQUMsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLENBQUMsR0FBRyxlQUFlLEVBQUU7WUFDdkUsd0VBQXdFO1lBQ3hFLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO2FBQU07WUFDSCwwRkFBMEY7WUFDMUYsT0FBTyxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMzRDtJQUNMLENBQUM7OztZQTNKSixTQUFTLFNBQUM7O2dCQUVULFFBQVEsRUFBRSxlQUFlO2FBQzFCOzs7Z0NBSUksZUFBZSxTQUFDLHFCQUFxQjt1QkFJckMsS0FBSztvQkFJTCxLQUFLOzBCQUlMLE1BQU07Ozs7Ozs7SUFaUCw2Q0FDb0Q7Ozs7O0lBR3BELG9DQUMwQjs7Ozs7SUFHMUIsaUNBQ3lCOzs7OztJQUd6Qix1Q0FDeUU7Ozs7OztJQUd6RSx5Q0FBc0M7Ozs7OztJQUd0Qyw0Q0FBMkM7Ozs7OztJQUczQyw0Q0FBd0M7Ozs7OztJQUd4QywrQ0FBdUQ7Ozs7OztJQUd2RCxvQ0FBK0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrRHJhZywgQ2RrRHJhZ01vdmUgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7IERuZENvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4uL2RuZC1jb250YWluZXIvZG5kLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5cbmV4cG9ydCB0eXBlIExpbmtQb3NpdGlvbiA9ICdhZnRlcicgfCAnYmVmb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50Q2hvcmQge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgcG9zaXRpb246IExpbmtQb3NpdGlvbjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICBzZWxlY3RvcjogJ1tmZC1kbmQtbGlzdF0nLFxufSlcbmV4cG9ydCBjbGFzcyBEbmRMaXN0RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oRG5kQ29udGFpbmVyRGlyZWN0aXZlKVxuICAgIGRuZENvbnRhaW5lckl0ZW1zOiBRdWVyeUxpc3Q8RG5kQ29udGFpbmVyRGlyZWN0aXZlPjtcblxuICAgIC8qKiBEZWZpbmVzIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVsZW1lbnRzIHNob3VsZCBiZSBjb3VudGVkIG9ubHkgYnkgdmVydGljYWwgZGlzdGFuY2UgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3RNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQXJyYXkgb2YgaXRlbXMsIHRoYXQgd2lsbCBiZSBzb3J0ZWQgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpdGVtczogQXJyYXk8YW55PjtcblxuICAgIC8qKiBFdmVudCB0aGF0IGlzIHRocm93biwgd2hlbiB0aGUgaXRlbSBpcyBkcm9wcGVkICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgaXRlbXNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxBcnJheTxhbnk+PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIGVsZW1lbnRDaG9yZHM6IEVsZW1lbnRDaG9yZFtdO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIGRyYWdnZWRJdGVtSW5kZXg6IG51bWJlciA9IDEwMDAwMDA7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgY2xvc2VzdExpbmtJbmRleDogbnVtYmVyID0gbnVsbDtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJpdmF0ZSBjbG9zZXN0TGlua1Bvc2l0aW9uOiAnYmVmb3JlJyB8ICdhZnRlcicgPSBudWxsO1xuXG4gICAgLyoqIEFuIFJ4SlMgU3ViamVjdCB0aGF0IHdpbGwga2lsbCB0aGUgY3VycmVudCBkYXRhIHN0cmVhbSAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVmcmVzaCQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlZnJlc2hRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5kbmRDb250YWluZXJJdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlZnJlc2hRdWVyeUxpc3QoKSk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCBjYWxsZWQsIHdoZW4gdGhlIGl0ZW0gaXMgYmVpbmcgbW92ZWQgYnkgMSBweCAqL1xuICAgIG9uTW92ZShldmVudDogQ2RrRHJhZ01vdmUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VzOiBBcnJheTxudW1iZXI+ID0gW107XG5cbiAgICAgICAgLyoqIFRha2luZyBtb3VzZSBwb3NpdGlvbiAqL1xuICAgICAgICBjb25zdCBtb3VzZVBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgICAgICB5OiBudW1iZXI7XG4gICAgICAgIH0gPSBldmVudC5wb2ludGVyUG9zaXRpb247XG5cbiAgICAgICAgLyoqIENvdW50aW5nIHRoZSBkaXN0YW5jZXMgYnkgdGhlIG1pbGVhZ2Ugb2YgdGhlIGNvcm5lciBvZiBlbGVtZW50IGFuZCBjdXJzb3IgcG9zaXRpb24gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50Q2hvcmRzLmZvckVhY2gobGlua0Nob3JkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChsaW5rQ2hvcmQueCAtIG1vdXNlUG9zaXRpb24ueCwgbGlua0Nob3JkLnkgLSBtb3VzZVBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goZGlzdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiogQ2hlY2tpbmcgY2xvc2VzdCBlbGVtZW50ICovXG4gICAgICAgIGNvbnN0IGNsb3NlTGlua0luZGV4OiBudW1iZXIgPSBkaXN0YW5jZXMuaW5kZXhPZihNYXRoLm1pbiguLi5kaXN0YW5jZXMpKTtcblxuICAgICAgICAvKiogSWYgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkIG9uZSwgbmV3IG9uZSBpcyBwaWNrZWQuIEl0IHByZXZlbnRzIGZyb20gcGVyZm9ybWFuY2UgaXNzdWVzICovXG4gICAgICAgIGlmIChjbG9zZUxpbmtJbmRleCAhPT0gdGhpcy5jbG9zZXN0TGlua0luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3Nlc3RMaW5rSW5kZXggPSBjbG9zZUxpbmtJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VzdExpbmtQb3NpdGlvbiA9IHRoaXMuZWxlbWVudENob3Jkc1tjbG9zZUxpbmtJbmRleF0ucG9zaXRpb247XG4gICAgICAgICAgICAvKiogR2VuZXJhdGluZyBsaW5lLCB0aGF0IHNob3dzIHdoZXJlIHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkLCBvbiBkcm9wICovXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlTGluZSh0aGlzLmNsb3Nlc3RMaW5rSW5kZXgsIHRoaXMuY2xvc2VzdExpbmtQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGNhbGxlZCwgd2hlbiBlbGVtZW50IGlzIHN0YXJ0ZWQgdG8gYmUgZHJhZ2dlZCAqL1xuICAgIGRyYWdTdGFydChpbmQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtSW5kZXggPSBpbmQ7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtRWxlbWVudCA9IHRoaXMuZG5kQ29udGFpbmVySXRlbXMudG9BcnJheSgpW2luZF0uZWxlbWVudDtcbiAgICAgICAgLyoqIENvdW50aW5nIGFsbCBvZiB0aGUgZWxlbWVudHMncyBjaG9yZHMgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50Q2hvcmRzID0gdGhpcy5kbmRDb250YWluZXJJdGVtcy50b0FycmF5KCkubWFwKChsaW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluay5nZXRFbGVtZW50Q2hvcmQodGhpcy5pc0JlZm9yZShkcmFnZ2VkSXRlbUVsZW1lbnQsIGxpbmsuZWxlbWVudCksIHRoaXMubGlzdE1vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGNhbGxlZCwgd2hlbiBlbGVtZW50IGlzIHJlbGVhc2VkICovXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbUluZGV4ID0gdGhpcy5kcmFnZ2VkSXRlbUluZGV4O1xuICAgICAgICBjb25zdCByZXBsYWNlZEl0ZW1JbmRleCA9IHRoaXMuY2xvc2VzdExpbmtJbmRleDtcbiAgICAgICAgY29uc3QgZHJhZ2dlZEl0ZW0gPSB0aGlzLml0ZW1zW2RyYWdnZWRJdGVtSW5kZXhdO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkSXRlbUluZGV4IDwgcmVwbGFjZWRJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkcmFnZ2VkSXRlbUluZGV4OyBpIDwgcmVwbGFjZWRJdGVtSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0gPSB0aGlzLml0ZW1zW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkcmFnZ2VkSXRlbUluZGV4OyBpID4gcmVwbGFjZWRJdGVtSW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0gPSB0aGlzLml0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBSZXBsYWNpbmcgaXRlbXMgKi9cbiAgICAgICAgdGhpcy5pdGVtc1tyZXBsYWNlZEl0ZW1JbmRleF0gPSBkcmFnZ2VkSXRlbTtcblxuICAgICAgICB0aGlzLml0ZW1zQ2hhbmdlLmVtaXQodGhpcy5pdGVtcyk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaW5lcygpO1xuXG4gICAgICAgIC8qKiBSZXNldCAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRDaG9yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZXN0TGlua0luZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9zZXN0TGlua1Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgcmVtb3ZlQWxsTGluZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZG5kQ29udGFpbmVySXRlbXMuZm9yRWFjaChpdGVtID0+IGl0ZW0ucmVtb3ZlTGluZSgpKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVMaW5lKGNsb3Nlc3RMaW5rSW5kZXg6IG51bWJlciwgbGlua1Bvc2l0aW9uOiBMaW5rUG9zaXRpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaW5lcygpO1xuICAgICAgICB0aGlzLmRuZENvbnRhaW5lckl0ZW1zLnRvQXJyYXkoKVtjbG9zZXN0TGlua0luZGV4XS5jcmVhdGVMaW5lKGxpbmtQb3NpdGlvbiwgdGhpcy5saXN0TW9kZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIHJlZnJlc2hRdWVyeUxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVmcmVzaCQubmV4dCgpO1xuICAgICAgICB0aGlzLmRuZENvbnRhaW5lckl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtLm1vdmVkLnBpcGUodGFrZVVudGlsKHRoaXMucmVmcmVzaCQpKS5zdWJzY3JpYmUoZXZlbnRNb3ZlID0+IHRoaXMub25Nb3ZlKGV2ZW50TW92ZSkpO1xuICAgICAgICAgICAgaXRlbS5zdGFydGVkLnBpcGUodGFrZVVudGlsKHRoaXMucmVmcmVzaCQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcmFnU3RhcnQoaW5kZXgpKTtcbiAgICAgICAgICAgIGl0ZW0ucmVsZWFzZWQucGlwZSh0YWtlVW50aWwodGhpcy5yZWZyZXNoJCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyYWdFbmQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBAaGlkZGVuXG4gICAgICogUmV0dXJuIGluZm9ybWF0aW9uIGlmIGVsZW1lbnQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgZHJhZ2dlZCBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0JlZm9yZShkcmFnZ2VkRWxlbWVudDogRWxlbWVudFJlZiwgdGFyZ2V0RWxlbWVudDogRWxlbWVudFJlZik6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8qKiBTb21ldGltZXMgdGhlIGVsZW1lbnQgYXJlIG5vdCBzdHJhaWdodCBpbiBvbmUgY29sdW1uLCB0aGF0J3Mgd2h5IG9mZnNldCBpcyBuZWVkZWQgKi9cbiAgICAgICAgY29uc3QgVkVSVElDQUxfT0ZGU0VUOiBudW1iZXIgPSAyMDtcblxuICAgICAgICAvKiogRGlzdGFuY2VzIGZyb20gdGhlIHRvcCBvZiBzY3JlZW4gKi9cbiAgICAgICAgY29uc3QgZHJhZ2dlZEVsZW1lbnRCb3VuZCA9IDxET01SZWN0PmRyYWdnZWRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRCb3VuZCA9IDxET01SZWN0PnRhcmdldEVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRCb3VuZC55IC0gdGFyZ2V0RWxlbWVudEJvdW5kLnkgPiBWRVJUSUNBTF9PRkZTRVQpIHtcbiAgICAgICAgICAgIC8qKiBJZiBlbGVtZW50IGlzIGhpZ2hlciB0aGFuIHRoZSBkcmFnZ2VkIGVsZW1lbnQsIGl0J3MgZm9yIHN1cmUgYmVmb3JlICovXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRFbGVtZW50Qm91bmQueSAtIGRyYWdnZWRFbGVtZW50Qm91bmQueSA+IFZFUlRJQ0FMX09GRlNFVCkge1xuICAgICAgICAgICAgLyoqIElmIGVsZW1lbnQgaXMgbG93ZXIgdGhhbiB0aGUgZHJhZ2dlZCBlbGVtZW50LCBpdCdzIGZvciBzdXJlIGFmdGVyICovXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiogSWYgZWxlbWVudHMgYXJlIGluIHNhbWUgbGV2ZWwsIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIGRlY2lkZXMgaWYgaXQncyBiZWZvcmUvYWZ0ZXIgKi9cbiAgICAgICAgICAgIHJldHVybiBkcmFnZ2VkRWxlbWVudEJvdW5kLnggLSB0YXJnZXRFbGVtZW50Qm91bmQueCA+IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=