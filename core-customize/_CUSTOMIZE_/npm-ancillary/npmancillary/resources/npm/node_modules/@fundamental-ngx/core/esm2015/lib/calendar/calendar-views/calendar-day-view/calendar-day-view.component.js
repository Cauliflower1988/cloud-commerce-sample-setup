/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, HostBinding, Input, Output, ViewEncapsulation } from '@angular/core';
import { CalendarI18n } from '../../i18n/calendar-i18n';
import { FdDate } from '../../models/fd-date';
import { CalendarService } from '../../calendar.service';
/**
 * Component representing the day view of the calendar.
 */
export class CalendarDayViewComponent {
    /**
     * @hidden
     * @param {?} calendarI18n
     * @param {?} eRef
     */
    constructor(calendarI18n, eRef) {
        this.calendarI18n = calendarI18n;
        this.eRef = eRef;
        /**
         * @hidden
         */
        this.newFocusedDayId = '';
        /**
         * @hidden
         */
        this.fdCalendarDateViewClass = true;
        /**
         * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
         */
        this.calType = 'single';
        /**
         * Event emitted always, when model is changed in range mode
         */
        this.selectedRangeDateChange = new EventEmitter();
        /**
         * Event emitted always, when next month is selected, by focus
         */
        this.nextMonthSelect = new EventEmitter();
        /**
         * Event emitted always, when previous month is selected, by focus
         */
        this.previousMonthSelect = new EventEmitter();
        /**
         * Event emitted always, when model is changed in single mode
         */
        this.selectedDateChange = new EventEmitter();
        /**
         * Function used to disable certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.disableFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.disableRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.disableRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.blockRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.blockRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.blockFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
    }
    /**
     * Function for selecting a date on the calendar. Typically called when a date is clicked, but can also be called programmatically.
     * @param {?} day CalendarDay object to be selected.
     * @param {?=} event
     * @return {?}
     */
    selectDate(day, event) {
        if (event) {
            /**
             * There are some problems with popup integration. After clicking inside day component, the popover closes.
             */
            event.stopPropagation();
            event.preventDefault();
            this.newFocusedDayId = day.id;
            this.focusElement(this.newFocusedDayId);
        }
        if (!day.blocked && !day.disabled) {
            if (this.calType === 'single') {
                this.selectedDate = day.date;
                this.selectedDateChange.emit(day.date);
                this.buildDayViewGrid();
            }
            else {
                if (this.selectCounter === 0 || this.selectCounter === 2) {
                    this.selectedRangeDate = { start: day.date, end: null };
                    this.selectedRangeDateChange.emit(this.selectedRangeDate);
                    this.buildDayViewGrid();
                }
                else if (this.selectCounter === 1) {
                    // Check if date picked is higher than already chosen, otherwise just reverse them
                    if (this.selectedRangeDate.start.getTimeStamp() < day.date.getTimeStamp()) {
                        this.selectedRangeDate = { start: this.selectedRangeDate.start, end: day.date };
                    }
                    else {
                        this.selectedRangeDate = { start: day.date, end: this.selectedRangeDate.start };
                    }
                    this.selectedRangeDateChange.emit(this.selectedRangeDate);
                    this.buildDayViewGrid();
                }
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.buildDayViewGrid();
    }
    /**
     * @hidden
     *  Amount of selected days
     *  0, when none,
     *  1, when only startDate, or endDate same as startDate,
     *  2, when both
     * @return {?}
     */
    get selectCounter() {
        if (!this.selectedRangeDate || !this.selectedRangeDate.start) {
            return 0;
        }
        else if (this.selectedRangeDate.start &&
            (!this.selectedRangeDate.end ||
                CalendarService.datesEqual(this.selectedRangeDate.start, this.selectedRangeDate.end))) {
            return 1;
        }
        else if (this.selectedRangeDate.start && this.selectedRangeDate.end) {
            return 2;
        }
    }
    /**
     * @hidden
     * Method that handles day cells keydown events,
     * @param {?} event KeyboardEvent
     * @param {?} cell CalendarDay
     * @param {?} grid with specified column and row as a x and y
     * @return {?}
     */
    onKeydownDayHandler(event, cell, grid) {
        if (event.code === 'Tab' && !event.shiftKey) {
            if (this.focusEscapeFunction) {
                event.preventDefault();
                this.focusEscapeFunction();
            }
        }
        else {
            switch (event.code) {
                case ('Space'):
                case ('Enter'): {
                    event.preventDefault();
                    this.selectDate(cell);
                    this.newFocusedDayId = cell.id;
                    break;
                }
                case ('ArrowUp'): {
                    event.preventDefault();
                    if (grid.y > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y - 1][grid.x].id;
                    }
                    else {
                        this.selectPreviousMonth();
                        this.newFocusedDayId = this.dayViewGrid[this.dayViewGrid.length - 1][grid.x].id;
                    }
                    break;
                }
                case ('ArrowDown'): {
                    event.preventDefault();
                    if (grid.y < this.dayViewGrid.length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y + 1][grid.x].id;
                    }
                    else {
                        this.selectNextMonth();
                        this.newFocusedDayId = this.dayViewGrid[0][grid.x].id;
                    }
                    break;
                }
                case ('ArrowLeft'): {
                    event.preventDefault();
                    if (grid.x > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y][grid.x - 1].id;
                    }
                    else if (grid.y > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y - 1][this.dayViewGrid[0].length - 1].id;
                    }
                    else {
                        this.selectPreviousMonth();
                        this.newFocusedDayId =
                            this.dayViewGrid[this.dayViewGrid.length - 1][this.dayViewGrid[0].length - 1].id;
                    }
                    break;
                }
                case ('ArrowRight'): {
                    event.preventDefault();
                    if (grid.x < this.dayViewGrid[0].length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y][grid.x + 1].id;
                    }
                    else if (grid.y < this.dayViewGrid.length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y + 1][0].id;
                    }
                    else {
                        this.selectNextMonth();
                        this.newFocusedDayId = this.dayViewGrid[0][0].id;
                    }
                    break;
                }
            }
        }
        if (this.newFocusedDayId) {
            this.focusElement(this.newFocusedDayId);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnChanges() {
        this.buildDayViewGrid();
    }
    /**
     * @hidden
     *  Method that allow to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    focusElement(elementSelector) {
        if (this.newFocusedDayId) {
            this.newFocusedDayId = '';
            setTimeout((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const elementToFocus = this.eRef.nativeElement.querySelector('#' + elementSelector);
                if (elementToFocus) {
                    elementToFocus.focus();
                }
            }), 0);
        }
    }
    /**
     * Active day means that with tabindex = 0, it's selected day or today or first day
     * @return {?}
     */
    focusActiveDay() {
        this.newFocusedDayId = this.getActiveCell(this.calendarDayList.filter((/**
         * @param {?} cell
         * @return {?}
         */
        cell => cell.monthStatus === 'current'))).id;
        this.focusElement(this.newFocusedDayId);
    }
    /**
     * Function that gives array of all displayed CalendarDays
     * @return {?}
     */
    get calendarDayList() {
        return this.dayViewGrid.reduce((/**
         * @param {?} totalCalendarRows
         * @param {?} calendarRow
         * @return {?}
         */
        (totalCalendarRows, calendarRow) => {
            if (!calendarRow) {
                calendarRow = [];
            }
            return totalCalendarRows.concat(calendarRow);
        }));
    }
    /**
     * Method that selects previous month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    selectPreviousMonth() {
        if (this.currentlyDisplayed.month > 1) {
            this.currentlyDisplayed = Object.assign({}, this.currentlyDisplayed, { month: this.currentlyDisplayed.month - 1 });
        }
        else {
            this.currentlyDisplayed = { year: this.currentlyDisplayed.year - 1, month: 12 };
        }
        this.buildDayViewGrid();
        this.previousMonthSelect.emit();
    }
    /**
     * Method that selects next month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    selectNextMonth() {
        if (this.currentlyDisplayed.month > 1) {
            this.currentlyDisplayed = Object.assign({}, this.currentlyDisplayed, { month: this.currentlyDisplayed.month + 1 });
        }
        else {
            this.currentlyDisplayed = { year: this.currentlyDisplayed.year + 1, month: 1 };
        }
        this.buildDayViewGrid();
        this.nextMonthSelect.emit();
    }
    /**
     * Method that creates array of CalendarDay models which will be shown on day grid,
     * depending on current month and year.
     * @private
     * @return {?}
     */
    populateCalendar() {
        /** @type {?} */
        let calendar = [];
        calendar = this.getPreviousMonthDays(calendar);
        calendar = calendar.concat(this.getCurrentMonthDays());
        calendar = this.getNextMonthDays(calendar);
        calendar.forEach((/**
         * @param {?} call
         * @param {?} index
         * @return {?}
         */
        (call, index) => call.id = this.id + '-fd-day-' + (Math.floor(index / 7) + 1) + '' + (index % 7)));
        return calendar;
    }
    /**
     * Method that builds 2 dimensions day view grid, also sets up currently displayed month, or year,
     * when there is not any.
     * @private
     * @return {?}
     */
    buildDayViewGrid() {
        if (!this.currentlyDisplayed) {
            if (this.selectedDate) {
                this.currentlyDisplayed = { month: this.selectedDate.month, year: this.selectedDate.year };
            }
            else {
                this.currentlyDisplayed = { month: FdDate.getToday().month, year: FdDate.getToday().year };
            }
        }
        /** @type {?} */
        const calendarDays = this.populateCalendar();
        /** @type {?} */
        const dayViewGrid = [];
        while (calendarDays.length > 0) {
            dayViewGrid.push(calendarDays.splice(0, 7));
        }
        this.dayViewGrid = dayViewGrid;
        return;
    }
    /**
     * Method which provides array of CalendarDay, which contains every single day of currently shown month/year.
     * @private
     * @return {?}
     */
    getCurrentMonthDays() {
        /** @type {?} */
        const month = this.currentlyDisplayed.month;
        /** @type {?} */
        const year = this.currentlyDisplayed.year;
        /** @type {?} */
        const calendarDays = [];
        /** @type {?} */
        const amountOfDaysInCurrentMonth = CalendarService.getDaysInMonth(month, year);
        for (let dayNumber = 1; dayNumber <= amountOfDaysInCurrentMonth; dayNumber++) {
            /** @type {?} */
            const fdDate = new FdDate(year, month, dayNumber);
            calendarDays.push(Object.assign({}, this.getDay(fdDate), { monthStatus: 'current', today: CalendarService.datesEqual(FdDate.getToday(), fdDate) }));
        }
        this.getActiveCell(calendarDays).isTabIndexed = true;
        return calendarDays;
    }
    /**
     * Method that returns active cell, which means:
     * if there is any selected day, return selected day
     * if there is no selected day, but there is today day, return today day
     * if there is no today, or selected, return first one
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    getActiveCell(calendarDays) {
        if (calendarDays.find((/**
         * @param {?} cell
         * @return {?}
         */
        cell => cell.selected))) {
            return calendarDays.find((/**
             * @param {?} cell
             * @return {?}
             */
            cell => cell.selected));
        }
        else if (calendarDays.find((/**
         * @param {?} cell
         * @return {?}
         */
        cell => cell.today))) {
            return calendarDays.find((/**
             * @param {?} cell
             * @return {?}
             */
            cell => cell.today));
        }
        else {
            return calendarDays[0];
        }
    }
    /**
     * Method which provides array of CalendarDay, which contains last 0-6 days of previous month/year. Theses days
     * fills the gap between starting startingDayOfWeek and first day of current month
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    getPreviousMonthDays(calendarDays) {
        /** @type {?} */
        const month = this.currentlyDisplayed.month > 1 ? this.currentlyDisplayed.month - 1 : 12;
        /** @type {?} */
        const year = this.currentlyDisplayed.month > 1 ? this.currentlyDisplayed.year : this.currentlyDisplayed.year - 1;
        /** @type {?} */
        const amountOfDaysInCurrentMonth = CalendarService.getDaysInMonth(month, year);
        /** @type {?} */
        const prevMonthLastDate = new FdDate(year, month, amountOfDaysInCurrentMonth);
        /** @type {?} */
        const prevMonthLastDay = amountOfDaysInCurrentMonth;
        /** @type {?} */
        let prevMonthLastWeekDay = prevMonthLastDate.getDay() - this.startingDayOfWeek;
        /** Checking if there are some days cut by startingDayOfWeek option
         *  If yes, there is whole week added, to avoid hiding
         */
        if (prevMonthLastWeekDay < 0) {
            prevMonthLastWeekDay = prevMonthLastWeekDay + 7;
        }
        if (prevMonthLastWeekDay < 6) {
            while (prevMonthLastWeekDay >= 0) {
                /** @type {?} */
                const prevMonthDay = prevMonthLastDay - prevMonthLastWeekDay;
                /** @type {?} */
                const fdDate = new FdDate(year, month, prevMonthDay);
                calendarDays.push(Object.assign({}, this.getDay(fdDate), { monthStatus: 'previous' }));
                prevMonthLastWeekDay--;
            }
        }
        return calendarDays;
    }
    /**
     * Method which provides array of CalendarDay, which contains first days of next month/year. Theses days
     * fills the gap between last day of current day and end of 6-weeks calendar grid.
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    getNextMonthDays(calendarDays) {
        /** @type {?} */
        const month = this.currentlyDisplayed.month < 12 ? this.currentlyDisplayed.month + 1 : 1;
        /** @type {?} */
        const year = this.currentlyDisplayed.month < 12 ? this.currentlyDisplayed.year : this.currentlyDisplayed.year + 1;
        // The calendar grid can have 6 (42 days) weeks
        /** @type {?} */
        const nextMonthDisplayedDays = 42 - calendarDays.length;
        for (let nextD = 1; nextD <= nextMonthDisplayedDays; nextD++) {
            /** @type {?} */
            const fdDate = new FdDate(year, month, nextD);
            calendarDays.push(Object.assign({}, this.getDay(fdDate), { monthStatus: 'next' }));
        }
        return calendarDays;
    }
    /**
     * Method that generates whole day model basing on fdDate, disabling functions, block functions, and actually
     * chosen range / single date.
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    getDay(fdDate) {
        /** @type {?} */
        const day = {
            date: fdDate,
            weekDay: fdDate.getDay(),
            disabled: this.disableFunction(fdDate),
            blocked: this.blockFunction(fdDate),
            selected: ((this.calType === 'single' && CalendarService.datesEqual(fdDate, this.selectedDate)) ||
                (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.start)) ||
                (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.end))),
            selectedFirst: (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.start)),
            selectedLast: (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.end)),
            selectedRange: (this.selectedRangeDate && ((this.selectedRangeDate.start && (this.selectedRangeDate.start.getTimeStamp() < fdDate.getTimeStamp())) &&
                (this.selectedRangeDate.end && (this.selectedRangeDate.end.getTimeStamp() > fdDate.getTimeStamp())))),
            ariaLabel: this.calendarI18n.getDayAriaLabel(fdDate.toDate())
        };
        if (this.calType === 'range' && (this.selectCounter === 0 || this.selectCounter === 2)) {
            if (this.disableRangeStartFunction && !day.disabled) {
                day.disabled = this.disableRangeStartFunction(day.date);
            }
            if (this.blockRangeStartFunction && !day.blocked) {
                day.blocked = this.blockRangeStartFunction(day.date);
            }
        }
        else if (this.selectCounter === 1) {
            if (this.disableRangeEndFunction && !day.disabled) {
                day.disabled = this.disableRangeEndFunction(day.date);
            }
            if (this.blockRangeEndFunction && !day.blocked) {
                day.blocked = this.blockRangeEndFunction(day.date);
            }
        }
        return day;
    }
    /**
     * Method that returns first letter of every weekday, basing on CalendarI18nDefault. Can be changed by user by
     * providing other class which implements CalendarI18n
     * @return {?}
     */
    get shortWeekDays() {
        return this.calendarI18n.getAllShortWeekdays()
            .slice(this.startingDayOfWeek - 1)
            .concat(this.calendarI18n.getAllShortWeekdays().slice(0, this.startingDayOfWeek - 1))
            .map((/**
         * @param {?} weekday
         * @return {?}
         */
        weekday => weekday[0].toLocaleUpperCase()));
    }
}
CalendarDayViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-calendar-day-view',
                template: "<table class=\"fd-calendar__table\" role=\"grid\">\n    <thead class=\"fd-calendar__group\">\n    <tr class=\"fd-calendar__row\">\n        <th class=\"fd-calendar__column-header\" *ngFor=\"let day of shortWeekDays\">\n            <span class=\"fd-calendar__day-of-week\">{{day}}</span>\n        </th>\n    </tr>\n    </thead>\n    <tbody class=\"fd-calendar__group\">\n        <tr class=\"fd-calendar__row\"\n            *ngFor=\"let row of dayViewGrid; let rowIndex = index;\">\n\n            <td class=\"fd-calendar__item\"\n                role=\"gridcell\"\n                [attr.aria-label]=\"cell.ariaLabel\"\n                *ngFor=\"let cell of row; let cellIndex = index;\"\n                [ngClass]=\"{\n                    'fd-calendar__item--other-month': cell.monthStatus !== 'current',\n                    'is-selected': cell.selected,\n                    'is-selected-range-last': cell.selectedLast && !cell.selectedFirst,\n                    'is-selected-range-first': cell.selectedFirst && selectCounter == 2,\n                    'is-selected-range': cell.selectedRange && !cell.selectedFirst && !cell.selectedLast,\n                    'fd-calendar__item--current': cell.today,\n                    'is-disabled': cell.disabled,\n                    'is-blocked': cell.blocked\n                }\"\n                [attr.id]=\"cell.id\"\n                [attr.tabindex]=\"cell.isTabIndexed ? 0 : -1\"\n                (click)=\"selectDate(cell, $event)\"\n                (keydown)=\"onKeydownDayHandler($event, cell, { x: cellIndex, y: rowIndex })\"\n            >\n                <span class=\"fd-calendar__text\" role=\"button\">{{cell.date.day}}</span>\n            </td>\n        </tr>\n    </tbody>\n</table>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    '[attr.id]': 'id + "-day-view"'
                },
                styles: [""]
            }] }
];
/** @nocollapse */
CalendarDayViewComponent.ctorParameters = () => [
    { type: CalendarI18n },
    { type: ElementRef }
];
CalendarDayViewComponent.propDecorators = {
    fdCalendarDateViewClass: [{ type: HostBinding, args: ['class.fd-calendar__dates',] }],
    currentlyDisplayed: [{ type: Input }],
    selectedDate: [{ type: Input }],
    selectedRangeDate: [{ type: Input }],
    startingDayOfWeek: [{ type: Input }],
    calType: [{ type: Input }],
    id: [{ type: Input }],
    focusEscapeFunction: [{ type: Input }],
    selectedRangeDateChange: [{ type: Output }],
    nextMonthSelect: [{ type: Output }],
    previousMonthSelect: [{ type: Output }],
    selectedDateChange: [{ type: Output }],
    disableFunction: [{ type: Input }],
    disableRangeStartFunction: [{ type: Input }],
    disableRangeEndFunction: [{ type: Input }],
    blockRangeStartFunction: [{ type: Input }],
    blockRangeEndFunction: [{ type: Input }],
    blockFunction: [{ type: Input }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    CalendarDayViewComponent.prototype.newFocusedDayId;
    /**
     * Actual day grid with previous/current/next month days
     * @type {?}
     */
    CalendarDayViewComponent.prototype.dayViewGrid;
    /**
     * @hidden
     * @type {?}
     */
    CalendarDayViewComponent.prototype.fdCalendarDateViewClass;
    /**
     * Currently displayed month and year for days
     * @type {?}
     */
    CalendarDayViewComponent.prototype.currentlyDisplayed;
    /**
     * The currently selected FdDate model in single mode.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedDate;
    /**
     * The currently selected FdDates model start and end in range mode.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedRangeDate;
    /**
     * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.startingDayOfWeek;
    /**
     * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.calType;
    /**
     * Id of the calendar. If none is provided, one will be generated.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.id;
    /**
     * Function that allows to specify which function would be called, when focus wants to escape
     * @type {?}
     */
    CalendarDayViewComponent.prototype.focusEscapeFunction;
    /**
     * Event emitted always, when model is changed in range mode
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedRangeDateChange;
    /**
     * Event emitted always, when next month is selected, by focus
     * @type {?}
     */
    CalendarDayViewComponent.prototype.nextMonthSelect;
    /**
     * Event emitted always, when previous month is selected, by focus
     * @type {?}
     */
    CalendarDayViewComponent.prototype.previousMonthSelect;
    /**
     * Event emitted always, when model is changed in single mode
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedDateChange;
    /**
     * Function used to disable certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableFunction;
    /**
     * Function used to disable certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableRangeStartFunction;
    /**
     * Function used to disable certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockRangeStartFunction;
    /**
     * Function used to block certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockFunction;
    /**
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.calendarI18n;
    /**
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.eRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItZGF5LXZpZXcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2NhbGVuZGFyL2NhbGVuZGFyLXZpZXdzL2NhbGVuZGFyLWRheS12aWV3L2NhbGVuZGFyLWRheS12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEVBRUwsTUFBTSxFQUNOLGlCQUFpQixFQUNwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBSTlDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7OztBQWF6RCxNQUFNLE9BQU8sd0JBQXdCOzs7Ozs7SUE4R2pDLFlBQ1ksWUFBMEIsRUFDMUIsSUFBZ0I7UUFEaEIsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIsU0FBSSxHQUFKLElBQUksQ0FBWTs7OztRQTdHNUIsb0JBQWUsR0FBVyxFQUFFLENBQUM7Ozs7UUFPdEIsNEJBQXVCLEdBQVksSUFBSSxDQUFDOzs7O1FBb0IvQyxZQUFPLEdBQWlCLFFBQVEsQ0FBQzs7OztRQVdqQiw0QkFBdUIsR0FBOEIsSUFBSSxZQUFZLEVBQWUsQ0FBQzs7OztRQUlyRixvQkFBZSxHQUF1QixJQUFJLFlBQVksRUFBUSxDQUFDOzs7O1FBSS9ELHdCQUFtQixHQUF1QixJQUFJLFlBQVksRUFBUSxDQUFDOzs7O1FBSW5FLHVCQUFrQixHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDOzs7OztRQU90RixvQkFBZTs7OztRQUFHLFVBQVUsTUFBYztZQUN0QyxPQUFPLEtBQUssQ0FBQztRQUNqQixDQUFDLEVBQUM7Ozs7O1FBT0Ys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QUFvQzs7Ozs7SUFHcEMsMkRBQytDOzs7OztJQUcvQyxzREFDMkM7Ozs7O0lBRzNDLGdEQUM0Qjs7Ozs7SUFHNUIscURBQ3NDOzs7OztJQUd0QyxxREFDcUM7Ozs7O0lBR3JDLDJDQUNpQzs7Ozs7SUFHakMsc0NBQW9COzs7OztJQUdwQix1REFDOEI7Ozs7O0lBRzlCLDJEQUNxRzs7Ozs7SUFHckcsbURBQytFOzs7OztJQUcvRSx1REFDbUY7Ozs7O0lBR25GLHNEQUNzRjs7Ozs7O0lBTXRGLG1EQUdFOzs7Ozs7SUFNRiw2REFHRTs7Ozs7O0lBTUYsMkRBR0U7Ozs7OztJQU1GLDJEQUdFOzs7Ozs7SUFNRix5REFHRTs7Ozs7O0lBTUYsaURBR0U7Ozs7O0lBSUUsZ0RBQWtDOzs7OztJQUNsQyx3Q0FBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCwgT25DaGFuZ2VzLFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDYWxlbmRhckkxOG4gfSBmcm9tICcuLi8uLi9pMThuL2NhbGVuZGFyLWkxOG4nO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgQ2FsZW5kYXJDdXJyZW50IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2NhbGVuZGFyLWN1cnJlbnQnO1xuaW1wb3J0IHsgQ2FsZW5kYXJUeXBlLCBEYXlzT2ZXZWVrIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIuY29tcG9uZW50JztcbmltcG9ydCB7IENhbGVuZGFyRGF5IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2NhbGVuZGFyLWRheSc7XG5pbXBvcnQgeyBDYWxlbmRhclNlcnZpY2UgfSBmcm9tICcuLi8uLi9jYWxlbmRhci5zZXJ2aWNlJztcbmltcG9ydCB7IEZkUmFuZ2VEYXRlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZkLXJhbmdlLWRhdGUnO1xuXG4vKiogQ29tcG9uZW50IHJlcHJlc2VudGluZyB0aGUgZGF5IHZpZXcgb2YgdGhlIGNhbGVuZGFyLiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1jYWxlbmRhci1kYXktdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NhbGVuZGFyLWRheS12aWV3LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9jYWxlbmRhci1kYXktdmlldy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2F0dHIuaWRdJzogJ2lkICsgXCItZGF5LXZpZXdcIidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhbGVuZGFyRGF5Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmV3Rm9jdXNlZERheUlkOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKiBBY3R1YWwgZGF5IGdyaWQgd2l0aCBwcmV2aW91cy9jdXJyZW50L25leHQgbW9udGggZGF5cyAqL1xuICAgIHB1YmxpYyBkYXlWaWV3R3JpZDogQ2FsZW5kYXJEYXlbXVtdO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmZkLWNhbGVuZGFyX19kYXRlcycpXG4gICAgcHVibGljIGZkQ2FsZW5kYXJEYXRlVmlld0NsYXNzOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBDdXJyZW50bHkgZGlzcGxheWVkIG1vbnRoIGFuZCB5ZWFyIGZvciBkYXlzICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY3VycmVudGx5RGlzcGxheWVkOiBDYWxlbmRhckN1cnJlbnQ7XG5cbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBGZERhdGUgbW9kZWwgaW4gc2luZ2xlIG1vZGUuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWREYXRlOiBGZERhdGU7XG5cbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBGZERhdGVzIG1vZGVsIHN0YXJ0IGFuZCBlbmQgaW4gcmFuZ2UgbW9kZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZWxlY3RlZFJhbmdlRGF0ZTogRmRSYW5nZURhdGU7XG5cbiAgICAvKiogVGhlIGRheSBvZiB0aGUgd2VlayB0aGUgY2FsZW5kYXIgc2hvdWxkIHN0YXJ0IG9uLiAxIHJlcHJlc2VudHMgU3VuZGF5LCAyIGlzIE1vbmRheSwgMyBpcyBUdWVzZGF5LCBhbmQgc28gb24uICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3RhcnRpbmdEYXlPZldlZWs6IERheXNPZldlZWs7XG5cbiAgICAvKiogVGhlIHR5cGUgb2YgY2FsZW5kYXIsICdzaW5nbGUnIGZvciBzaW5nbGUgZGF0ZSBzZWxlY3Rpb24gb3IgJ3JhbmdlJyBmb3IgYSByYW5nZSBvZiBkYXRlcy4gKi9cbiAgICBASW5wdXQoKVxuICAgIGNhbFR5cGU6IENhbGVuZGFyVHlwZSA9ICdzaW5nbGUnO1xuXG4gICAgLyoqIElkIG9mIHRoZSBjYWxlbmRhci4gSWYgbm9uZSBpcyBwcm92aWRlZCwgb25lIHdpbGwgYmUgZ2VuZXJhdGVkLiAqL1xuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG5cbiAgICAvKiogRnVuY3Rpb24gdGhhdCBhbGxvd3MgdG8gc3BlY2lmeSB3aGljaCBmdW5jdGlvbiB3b3VsZCBiZSBjYWxsZWQsIHdoZW4gZm9jdXMgd2FudHMgdG8gZXNjYXBlICovXG4gICAgQElucHV0KClcbiAgICBmb2N1c0VzY2FwZUZ1bmN0aW9uOiBGdW5jdGlvbjtcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIGFsd2F5cywgd2hlbiBtb2RlbCBpcyBjaGFuZ2VkIGluIHJhbmdlIG1vZGUgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGZFJhbmdlRGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZkUmFuZ2VEYXRlPigpO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgYWx3YXlzLCB3aGVuIG5leHQgbW9udGggaXMgc2VsZWN0ZWQsIGJ5IGZvY3VzICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IG5leHRNb250aFNlbGVjdDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgYWx3YXlzLCB3aGVuIHByZXZpb3VzIG1vbnRoIGlzIHNlbGVjdGVkLCBieSBmb2N1cyAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBwcmV2aW91c01vbnRoU2VsZWN0OiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRXZlbnQgZW1pdHRlZCBhbHdheXMsIHdoZW4gbW9kZWwgaXMgY2hhbmdlZCBpbiBzaW5nbGUgbW9kZSAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBzZWxlY3RlZERhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGZERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxGZERhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRpc2FibGUgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIuXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVGdW5jdGlvbiA9IGZ1bmN0aW9uIChmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGlzYWJsZSBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIHN0YXJ0IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVJhbmdlU3RhcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGlzYWJsZSBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIGVuZCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVSYW5nZUVuZEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBibG9jayBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIHN0YXJ0IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmxvY2tSYW5nZVN0YXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiAoZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGJsb2NrIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyIGZvciB0aGUgcmFuZ2UgZW5kIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmxvY2tSYW5nZUVuZEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBibG9jayBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhci5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmxvY2tGdW5jdGlvbiA9IGZ1bmN0aW9uIChmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgY2FsZW5kYXJJMThuOiBDYWxlbmRhckkxOG4sXG4gICAgICAgIHByaXZhdGUgZVJlZjogRWxlbWVudFJlZixcbiAgICApIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBmb3Igc2VsZWN0aW5nIGEgZGF0ZSBvbiB0aGUgY2FsZW5kYXIuIFR5cGljYWxseSBjYWxsZWQgd2hlbiBhIGRhdGUgaXMgY2xpY2tlZCwgYnV0IGNhbiBhbHNvIGJlIGNhbGxlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAqIEBwYXJhbSBkYXkgQ2FsZW5kYXJEYXkgb2JqZWN0IHRvIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGVjdERhdGUoZGF5OiBDYWxlbmRhckRheSwgZXZlbnQ/OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGVyZSBhcmUgc29tZSBwcm9ibGVtcyB3aXRoIHBvcHVwIGludGVncmF0aW9uLiBBZnRlciBjbGlja2luZyBpbnNpZGUgZGF5IGNvbXBvbmVudCwgdGhlIHBvcG92ZXIgY2xvc2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IGRheS5pZDtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNFbGVtZW50KHRoaXMubmV3Rm9jdXNlZERheUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRheS5ibG9ja2VkICYmICFkYXkuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBkYXkuZGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZUNoYW5nZS5lbWl0KGRheS5kYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRGF5Vmlld0dyaWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0Q291bnRlciA9PT0gMCB8fCB0aGlzLnNlbGVjdENvdW50ZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IGRheS5kYXRlLCBlbmQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZUNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRGF5Vmlld0dyaWQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0Q291bnRlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRlIHBpY2tlZCBpcyBoaWdoZXIgdGhhbiBhbHJlYWR5IGNob3Nlbiwgb3RoZXJ3aXNlIGp1c3QgcmV2ZXJzZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LmdldFRpbWVTdGFtcCgpIDwgZGF5LmRhdGUuZ2V0VGltZVN0YW1wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgPSB7IHN0YXJ0OiB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LCBlbmQ6IGRheS5kYXRlIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlID0geyBzdGFydDogZGF5LmRhdGUsIGVuZDogdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZERheVZpZXdHcmlkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJ1aWxkRGF5Vmlld0dyaWQoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBBbW91bnQgb2Ygc2VsZWN0ZWQgZGF5c1xuICAgICAqICAwLCB3aGVuIG5vbmUsXG4gICAgICogIDEsIHdoZW4gb25seSBzdGFydERhdGUsIG9yIGVuZERhdGUgc2FtZSBhcyBzdGFydERhdGUsXG4gICAgICogIDIsIHdoZW4gYm90aFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RDb3VudGVyKCk6IG51bWJlciB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSB8fCAhdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCAmJlxuICAgICAgICAgICAgKCF0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCB8fFxuICAgICAgICAgICAgICAgIENhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQsIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuZW5kKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgJiYgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCB0aGF0IGhhbmRsZXMgZGF5IGNlbGxzIGtleWRvd24gZXZlbnRzLFxuICAgICAqIEBwYXJhbSBldmVudCBLZXlib2FyZEV2ZW50XG4gICAgICogQHBhcmFtIGNlbGwgQ2FsZW5kYXJEYXlcbiAgICAgKiBAcGFyYW0gZ3JpZCB3aXRoIHNwZWNpZmllZCBjb2x1bW4gYW5kIHJvdyBhcyBhIHggYW5kIHlcbiAgICAgKi9cbiAgICBvbktleWRvd25EYXlIYW5kbGVyKGV2ZW50LCBjZWxsOiBDYWxlbmRhckRheSwgZ3JpZDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9KTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudC5jb2RlID09PSAnVGFiJyAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzRXNjYXBlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNFc2NhcGVGdW5jdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAoJ1NwYWNlJyk6XG4gICAgICAgICAgICAgICAgY2FzZSAoJ0VudGVyJyk6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IGNlbGwuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICgnQXJyb3dVcCcpOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbZ3JpZC55IC0gMV1bZ3JpZC54XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXNNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmRheVZpZXdHcmlkW3RoaXMuZGF5Vmlld0dyaWQubGVuZ3RoIC0gMV1bZ3JpZC54XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAoJ0Fycm93RG93bicpOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLnkgPCB0aGlzLmRheVZpZXdHcmlkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFtncmlkLnkgKyAxXVtncmlkLnhdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFswXVtncmlkLnhdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICgnQXJyb3dMZWZ0Jyk6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQueCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFtncmlkLnldW2dyaWQueCAtIDFdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyaWQueSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFtncmlkLnkgLSAxXVt0aGlzLmRheVZpZXdHcmlkWzBdLmxlbmd0aCAtIDFdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91c01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXlWaWV3R3JpZFt0aGlzLmRheVZpZXdHcmlkLmxlbmd0aCAtIDFdW3RoaXMuZGF5Vmlld0dyaWRbMF0ubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgKCdBcnJvd1JpZ2h0Jyk6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQueCA8IHRoaXMuZGF5Vmlld0dyaWRbMF0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmRheVZpZXdHcmlkW2dyaWQueV1bZ3JpZC54ICsgMV0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JpZC55IDwgdGhpcy5kYXlWaWV3R3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbZ3JpZC55ICsgMV1bMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmRheVZpZXdHcmlkWzBdWzBdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5ld0ZvY3VzZWREYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnQodGhpcy5uZXdGb2N1c2VkRGF5SWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYnVpbGREYXlWaWV3R3JpZCgpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuXG4gICAgICogIE1ldGhvZCB0aGF0IGFsbG93IHRvIGZvY3VzIGVsZW1lbnRzIGluc2lkZSB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBmb2N1c0VsZW1lbnQoZWxlbWVudFNlbGVjdG9yKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm5ld0ZvY3VzZWREYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSAnJztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzOiBIVE1MRWxlbWVudCA9IHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRvRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBBY3RpdmUgZGF5IG1lYW5zIHRoYXQgd2l0aCB0YWJpbmRleCA9IDAsIGl0J3Mgc2VsZWN0ZWQgZGF5IG9yIHRvZGF5IG9yIGZpcnN0IGRheSAqL1xuICAgIHB1YmxpYyBmb2N1c0FjdGl2ZURheSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmdldEFjdGl2ZUNlbGwoXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyRGF5TGlzdC5maWx0ZXIoY2VsbCA9PiBjZWxsLm1vbnRoU3RhdHVzID09PSAnY3VycmVudCcpXG4gICAgICAgICkuaWQ7XG4gICAgICAgIHRoaXMuZm9jdXNFbGVtZW50KHRoaXMubmV3Rm9jdXNlZERheUlkKTtcbiAgICB9XG5cbiAgICAvKiogRnVuY3Rpb24gdGhhdCBnaXZlcyBhcnJheSBvZiBhbGwgZGlzcGxheWVkIENhbGVuZGFyRGF5cyAqL1xuICAgIHB1YmxpYyBnZXQgY2FsZW5kYXJEYXlMaXN0KCk6IENhbGVuZGFyRGF5W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXlWaWV3R3JpZC5yZWR1Y2UoKHRvdGFsQ2FsZW5kYXJSb3dzOiBDYWxlbmRhckRheVtdLCBjYWxlbmRhclJvdzogQ2FsZW5kYXJEYXlbXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYWxlbmRhclJvdykge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyUm93ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxDYWxlbmRhclJvd3MuY29uY2F0KGNhbGVuZGFyUm93KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgc2VsZWN0cyBwcmV2aW91cyBtb250aFxuICAgICAqIFRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG1vbnRoIGlzIGNoYW5nZWQgZHVyaW5nIGNoYW5naW5nIGZvY3VzXG4gICAgICogQWxzbyB0cmlnZ2VycyBldmVudCB0byBwYXJlbnQgY2FsZW5kYXIgY29tcG9uZW50IGFuZCByZWJ1aWxkcyBkYXkgdmlldyBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZWxlY3RQcmV2aW91c01vbnRoKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseURpc3BsYXllZCA9IHsgLi4udGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQsIG1vbnRoOiB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCAtIDEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RGlzcGxheWVkID0geyB5ZWFyOiB0aGlzLmN1cnJlbnRseURpc3BsYXllZC55ZWFyIC0gMSwgbW9udGg6IDEyIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZERheVZpZXdHcmlkKCk7XG4gICAgICAgIHRoaXMucHJldmlvdXNNb250aFNlbGVjdC5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgc2VsZWN0cyBuZXh0IG1vbnRoXG4gICAgICogVHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbW9udGggaXMgY2hhbmdlZCBkdXJpbmcgY2hhbmdpbmcgZm9jdXNcbiAgICAgKiBBbHNvIHRyaWdnZXJzIGV2ZW50IHRvIHBhcmVudCBjYWxlbmRhciBjb21wb25lbnQgYW5kIHJlYnVpbGRzIGRheSB2aWV3IGdyaWRcbiAgICAgKi9cbiAgICBwcml2YXRlIHNlbGVjdE5leHRNb250aCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQgPSB7IC4uLnRoaXMuY3VycmVudGx5RGlzcGxheWVkLCBtb250aDogdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggKyAxIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseURpc3BsYXllZCA9IHsgeWVhcjogdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQueWVhciArIDEsIG1vbnRoOiAxIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZERheVZpZXdHcmlkKCk7XG4gICAgICAgIHRoaXMubmV4dE1vbnRoU2VsZWN0LmVtaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9mIENhbGVuZGFyRGF5IG1vZGVscyB3aGljaCB3aWxsIGJlIHNob3duIG9uIGRheSBncmlkLFxuICAgICAqIGRlcGVuZGluZyBvbiBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgcG9wdWxhdGVDYWxlbmRhcigpOiBDYWxlbmRhckRheVtdIHtcbiAgICAgICAgbGV0IGNhbGVuZGFyOiBDYWxlbmRhckRheVtdID0gW107XG5cbiAgICAgICAgY2FsZW5kYXIgPSB0aGlzLmdldFByZXZpb3VzTW9udGhEYXlzKGNhbGVuZGFyKTtcbiAgICAgICAgY2FsZW5kYXIgPSBjYWxlbmRhci5jb25jYXQodGhpcy5nZXRDdXJyZW50TW9udGhEYXlzKCkpO1xuICAgICAgICBjYWxlbmRhciA9IHRoaXMuZ2V0TmV4dE1vbnRoRGF5cyhjYWxlbmRhcik7XG5cbiAgICAgICAgY2FsZW5kYXIuZm9yRWFjaCgoY2FsbCwgaW5kZXg6IG51bWJlcikgPT4gY2FsbC5pZCA9IHRoaXMuaWQgKyAnLWZkLWRheS0nICsgKE1hdGguZmxvb3IoaW5kZXggLyA3KSArIDEpICsgJycgKyAoaW5kZXggJSA3KSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGJ1aWxkcyAyIGRpbWVuc2lvbnMgZGF5IHZpZXcgZ3JpZCwgYWxzbyBzZXRzIHVwIGN1cnJlbnRseSBkaXNwbGF5ZWQgbW9udGgsIG9yIHllYXIsXG4gICAgICogd2hlbiB0aGVyZSBpcyBub3QgYW55LlxuICAgICAqL1xuICAgIHByaXZhdGUgYnVpbGREYXlWaWV3R3JpZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRseURpc3BsYXllZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQgPSB7IG1vbnRoOiB0aGlzLnNlbGVjdGVkRGF0ZS5tb250aCwgeWVhcjogdGhpcy5zZWxlY3RlZERhdGUueWVhciB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseURpc3BsYXllZCA9IHsgbW9udGg6IEZkRGF0ZS5nZXRUb2RheSgpLm1vbnRoLCB5ZWFyOiBGZERhdGUuZ2V0VG9kYXkoKS55ZWFyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYWxlbmRhckRheXMgPSB0aGlzLnBvcHVsYXRlQ2FsZW5kYXIoKTtcbiAgICAgICAgY29uc3QgZGF5Vmlld0dyaWQ6IENhbGVuZGFyRGF5W11bXSA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjYWxlbmRhckRheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF5Vmlld0dyaWQucHVzaChjYWxlbmRhckRheXMuc3BsaWNlKDAsIDcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRheVZpZXdHcmlkID0gZGF5Vmlld0dyaWQ7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2hpY2ggcHJvdmlkZXMgYXJyYXkgb2YgQ2FsZW5kYXJEYXksIHdoaWNoIGNvbnRhaW5zIGV2ZXJ5IHNpbmdsZSBkYXkgb2YgY3VycmVudGx5IHNob3duIG1vbnRoL3llYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRDdXJyZW50TW9udGhEYXlzKCk6IENhbGVuZGFyRGF5W10ge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQueWVhcjtcbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXlzOiBDYWxlbmRhckRheVtdID0gW107XG4gICAgICAgIGNvbnN0IGFtb3VudE9mRGF5c0luQ3VycmVudE1vbnRoOiBudW1iZXIgPSBDYWxlbmRhclNlcnZpY2UuZ2V0RGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAgICAgICBmb3IgKGxldCBkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gYW1vdW50T2ZEYXlzSW5DdXJyZW50TW9udGg7IGRheU51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCBmZERhdGU6IEZkRGF0ZSA9IG5ldyBGZERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlcik7XG4gICAgICAgICAgICBjYWxlbmRhckRheXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXREYXkoZmREYXRlKSxcbiAgICAgICAgICAgICAgICBtb250aFN0YXR1czogJ2N1cnJlbnQnLFxuICAgICAgICAgICAgICAgIHRvZGF5OiBDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbChGZERhdGUuZ2V0VG9kYXkoKSwgZmREYXRlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRBY3RpdmVDZWxsKGNhbGVuZGFyRGF5cykuaXNUYWJJbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF5cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFjdGl2ZSBjZWxsLCB3aGljaCBtZWFuczpcbiAgICAgKiBpZiB0aGVyZSBpcyBhbnkgc2VsZWN0ZWQgZGF5LCByZXR1cm4gc2VsZWN0ZWQgZGF5XG4gICAgICogaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgZGF5LCBidXQgdGhlcmUgaXMgdG9kYXkgZGF5LCByZXR1cm4gdG9kYXkgZGF5XG4gICAgICogaWYgdGhlcmUgaXMgbm8gdG9kYXksIG9yIHNlbGVjdGVkLCByZXR1cm4gZmlyc3Qgb25lXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRBY3RpdmVDZWxsKGNhbGVuZGFyRGF5czogQ2FsZW5kYXJEYXlbXSk6IENhbGVuZGFyRGF5IHtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF5cy5maW5kKGNlbGwgPT4gY2VsbC5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhckRheXMuZmluZChjZWxsID0+IGNlbGwuc2VsZWN0ZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGVuZGFyRGF5cy5maW5kKGNlbGwgPT4gY2VsbC50b2RheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhckRheXMuZmluZChjZWxsID0+IGNlbGwudG9kYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyRGF5c1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB3aGljaCBwcm92aWRlcyBhcnJheSBvZiBDYWxlbmRhckRheSwgd2hpY2ggY29udGFpbnMgbGFzdCAwLTYgZGF5cyBvZiBwcmV2aW91cyBtb250aC95ZWFyLiBUaGVzZXMgZGF5c1xuICAgICAqIGZpbGxzIHRoZSBnYXAgYmV0d2VlbiBzdGFydGluZyBzdGFydGluZ0RheU9mV2VlayBhbmQgZmlyc3QgZGF5IG9mIGN1cnJlbnQgbW9udGhcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFByZXZpb3VzTW9udGhEYXlzKGNhbGVuZGFyRGF5czogQ2FsZW5kYXJEYXlbXSk6IENhbGVuZGFyRGF5W10ge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoID4gMSA/IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoIC0gMSA6IDEyO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggPiAxID8gdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQueWVhciA6IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLnllYXIgLSAxO1xuICAgICAgICBjb25zdCBhbW91bnRPZkRheXNJbkN1cnJlbnRNb250aDogbnVtYmVyID0gQ2FsZW5kYXJTZXJ2aWNlLmdldERheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgY29uc3QgcHJldk1vbnRoTGFzdERhdGUgPSBuZXcgRmREYXRlKHllYXIsIG1vbnRoLCBhbW91bnRPZkRheXNJbkN1cnJlbnRNb250aCk7XG4gICAgICAgIGNvbnN0IHByZXZNb250aExhc3REYXkgPSBhbW91bnRPZkRheXNJbkN1cnJlbnRNb250aDtcbiAgICAgICAgbGV0IHByZXZNb250aExhc3RXZWVrRGF5ID0gcHJldk1vbnRoTGFzdERhdGUuZ2V0RGF5KCkgLSB0aGlzLnN0YXJ0aW5nRGF5T2ZXZWVrO1xuXG4gICAgICAgIC8qKiBDaGVja2luZyBpZiB0aGVyZSBhcmUgc29tZSBkYXlzIGN1dCBieSBzdGFydGluZ0RheU9mV2VlayBvcHRpb25cbiAgICAgICAgICogIElmIHllcywgdGhlcmUgaXMgd2hvbGUgd2VlayBhZGRlZCwgdG8gYXZvaWQgaGlkaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJldk1vbnRoTGFzdFdlZWtEYXkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2TW9udGhMYXN0V2Vla0RheSA9IHByZXZNb250aExhc3RXZWVrRGF5ICsgNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2TW9udGhMYXN0V2Vla0RheSA8IDYpIHtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2TW9udGhMYXN0V2Vla0RheSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldk1vbnRoRGF5ID0gcHJldk1vbnRoTGFzdERheSAtIHByZXZNb250aExhc3RXZWVrRGF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZkRGF0ZSA9IG5ldyBGZERhdGUoeWVhciwgbW9udGgsIHByZXZNb250aERheSk7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJEYXlzLnB1c2goeyAuLi50aGlzLmdldERheShmZERhdGUpLCBtb250aFN0YXR1czogJ3ByZXZpb3VzJyB9KTtcbiAgICAgICAgICAgICAgICBwcmV2TW9udGhMYXN0V2Vla0RheS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRheXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHdoaWNoIHByb3ZpZGVzIGFycmF5IG9mIENhbGVuZGFyRGF5LCB3aGljaCBjb250YWlucyBmaXJzdCBkYXlzIG9mIG5leHQgbW9udGgveWVhci4gVGhlc2VzIGRheXNcbiAgICAgKiBmaWxscyB0aGUgZ2FwIGJldHdlZW4gbGFzdCBkYXkgb2YgY3VycmVudCBkYXkgYW5kIGVuZCBvZiA2LXdlZWtzIGNhbGVuZGFyIGdyaWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROZXh0TW9udGhEYXlzKGNhbGVuZGFyRGF5czogQ2FsZW5kYXJEYXlbXSk6IENhbGVuZGFyRGF5W10ge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoIDwgMTIgPyB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCArIDEgOiAxO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggPCAxMiA/IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLnllYXIgOiB0aGlzLmN1cnJlbnRseURpc3BsYXllZC55ZWFyICsgMTtcblxuICAgICAgICAvLyBUaGUgY2FsZW5kYXIgZ3JpZCBjYW4gaGF2ZSA2ICg0MiBkYXlzKSB3ZWVrc1xuICAgICAgICBjb25zdCBuZXh0TW9udGhEaXNwbGF5ZWREYXlzID0gNDIgLSBjYWxlbmRhckRheXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IG5leHREID0gMTsgbmV4dEQgPD0gbmV4dE1vbnRoRGlzcGxheWVkRGF5czsgbmV4dEQrKykge1xuICAgICAgICAgICAgY29uc3QgZmREYXRlID0gbmV3IEZkRGF0ZSh5ZWFyLCBtb250aCwgbmV4dEQpO1xuICAgICAgICAgICAgY2FsZW5kYXJEYXlzLnB1c2goeyAuLi50aGlzLmdldERheShmZERhdGUpLCBtb250aFN0YXR1czogJ25leHQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRheXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZ2VuZXJhdGVzIHdob2xlIGRheSBtb2RlbCBiYXNpbmcgb24gZmREYXRlLCBkaXNhYmxpbmcgZnVuY3Rpb25zLCBibG9jayBmdW5jdGlvbnMsIGFuZCBhY3R1YWxseVxuICAgICAqIGNob3NlbiByYW5nZSAvIHNpbmdsZSBkYXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RGF5KGZkRGF0ZTogRmREYXRlKTogQ2FsZW5kYXJEYXkge1xuICAgICAgICBjb25zdCBkYXk6IENhbGVuZGFyRGF5ID0ge1xuICAgICAgICAgICAgZGF0ZTogZmREYXRlLFxuICAgICAgICAgICAgd2Vla0RheTogZmREYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZUZ1bmN0aW9uKGZkRGF0ZSksXG4gICAgICAgICAgICBibG9ja2VkOiB0aGlzLmJsb2NrRnVuY3Rpb24oZmREYXRlKSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiAoXG4gICAgICAgICAgICAgICAgKHRoaXMuY2FsVHlwZSA9PT0gJ3NpbmdsZScgJiYgQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmREYXRlLCB0aGlzLnNlbGVjdGVkRGF0ZSkpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiYgQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmREYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0KSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSAmJiBDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbChmZERhdGUsIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuZW5kKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzZWxlY3RlZEZpcnN0OiAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSAmJiBDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbChmZERhdGUsIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQpKSxcbiAgICAgICAgICAgIHNlbGVjdGVkTGFzdDogKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiYgQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmREYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCkpLFxuICAgICAgICAgICAgc2VsZWN0ZWRSYW5nZTogKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiYgKFxuICAgICAgICAgICAgICAgICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0ICYmICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LmdldFRpbWVTdGFtcCgpIDwgZmREYXRlLmdldFRpbWVTdGFtcCgpKSkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQgJiYgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuZW5kLmdldFRpbWVTdGFtcCgpID4gZmREYXRlLmdldFRpbWVTdGFtcCgpKSlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgYXJpYUxhYmVsOiB0aGlzLmNhbGVuZGFySTE4bi5nZXREYXlBcmlhTGFiZWwoZmREYXRlLnRvRGF0ZSgpKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmNhbFR5cGUgPT09ICdyYW5nZScgJiYgKHRoaXMuc2VsZWN0Q291bnRlciA9PT0gMCB8fCB0aGlzLnNlbGVjdENvdW50ZXIgPT09IDIpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlUmFuZ2VTdGFydEZ1bmN0aW9uICYmICFkYXkuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkYXkuZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVSYW5nZVN0YXJ0RnVuY3Rpb24oZGF5LmRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tSYW5nZVN0YXJ0RnVuY3Rpb24gJiYgIWRheS5ibG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgZGF5LmJsb2NrZWQgPSB0aGlzLmJsb2NrUmFuZ2VTdGFydEZ1bmN0aW9uKGRheS5kYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdENvdW50ZXIgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVSYW5nZUVuZEZ1bmN0aW9uICYmICFkYXkuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkYXkuZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVSYW5nZUVuZEZ1bmN0aW9uKGRheS5kYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tSYW5nZUVuZEZ1bmN0aW9uICYmICFkYXkuYmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGRheS5ibG9ja2VkID0gdGhpcy5ibG9ja1JhbmdlRW5kRnVuY3Rpb24oZGF5LmRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGZpcnN0IGxldHRlciBvZiBldmVyeSB3ZWVrZGF5LCBiYXNpbmcgb24gQ2FsZW5kYXJJMThuRGVmYXVsdC4gQ2FuIGJlIGNoYW5nZWQgYnkgdXNlciBieVxuICAgICAqIHByb3ZpZGluZyBvdGhlciBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIENhbGVuZGFySTE4blxuICAgICAqL1xuICAgIGdldCBzaG9ydFdlZWtEYXlzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJJMThuLmdldEFsbFNob3J0V2Vla2RheXMoKVxuICAgICAgICAgICAgLnNsaWNlKHRoaXMuc3RhcnRpbmdEYXlPZldlZWsgLSAxKVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmNhbGVuZGFySTE4bi5nZXRBbGxTaG9ydFdlZWtkYXlzKCkuc2xpY2UoMCwgdGhpcy5zdGFydGluZ0RheU9mV2VlayAtIDEpKVxuICAgICAgICAgICAgLm1hcCh3ZWVrZGF5ID0+IHdlZWtkYXlbMF0udG9Mb2NhbGVVcHBlckNhc2UoKSk7XG4gICAgfVxufVxuIl19