/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/* tslint:disable:max-classes-per-file */
import * as lodash from 'lodash';
import { Injectable } from '@angular/core';
/**
 * @ngdoc service
 * @name @smartutils.services:BackendEntry
 * @description
 * Invocations of {@link @smartutils.services:HttpBackendService} when, whenGET, whenPOST, whenPUT, whenDELETE
 * all return an instance of {@link @smartutils.services:BackendEntry BackendEntry}
 * It is used to specify the mocked response for the given conditions.
 */
var BackendEntry = /** @class */ (function () {
    function BackendEntry(pattern, matchingPayload) {
        this.pattern = pattern;
        this.matchingPayload = matchingPayload;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:BackendEntry#respond
     * @methodOf @smartutils.services:BackendEntry
     * @description
     * @param {BackendRespond} mock the {@link @smartutils.object:BackendRespond} to return for the given conditions
     */
    BackendEntry.prototype.respond = function (mock) {
        this.mock = mock;
        return this;
    };
    BackendEntry.prototype.passThrough = function () {
        //
    };
    return BackendEntry;
}());
export { BackendEntry };
/**
 * @ngdoc service
 * @name @smartutils.services:HttpBackendService
 * @description
 * Service aimed to provide mocked backend responses for given http request patterns.
 * It follows the API of {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend $httpBackend}
 * minus a few limitations
 */
var HttpBackendService = /** @class */ (function () {
    function HttpBackendService() {
        this.matchLatestDefinition = false;
        this.backends = {
            GET: [],
            POST: [],
            PUT: [],
            DELETE: []
        };
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenGET
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenGET $httpBackend#whenGET}
     * but with only the url pattern as parameter
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.whenGET = function (pattern) {
        return this._whenMethod('GET', pattern);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPOST
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPOST $httpBackend#whenPOST}
     * but with only the first 2 arguments
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.whenPOST = function (pattern, matchingPayload) {
        return this._whenMethod('POST', pattern, matchingPayload);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPUT
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPUT $httpBackend#whenPUT}
     * but with only the first 2 arguments
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.whenPUT = function (pattern, matchingPayload) {
        return this._whenMethod('PUT', pattern, matchingPayload);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPUT
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPUT $httpBackend#whenPUT}
     * but with only the url pattern as parameter
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.whenDELETE = function (pattern) {
        return this._whenMethod('DELETE', pattern);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#when
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#when $httpBackend#when}
     * @param {string} method GET, POST, PUT, or DELETE
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.when = function (method, pattern, matchingPayload) {
        return this._whenMethod(method, pattern, matchingPayload);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenAsync
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to legacy $httpBackend#whenAsync, use {@link @smartutils.services:HttpBackendService#when HttpBackendService#when} instead
     * @param {string} method GET, POST, PUT, or DELETE
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    HttpBackendService.prototype.whenAsync = function (method, pattern, matchingPayload) {
        return this._whenMethod(method, pattern, matchingPayload);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#matchLatestDefinitionEnabled
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#matchLatestDefinitionEnabled $httpBackend#matchLatestDefinitionEnabled}
     * @param {boolean=false} matchLatestDefinitionEnabled if true, the last matching pattern will be picked. Otherwise the first is picked
     */
    HttpBackendService.prototype.matchLatestDefinitionEnabled = function (matchLatestDefinitionEnabled) {
        this.matchLatestDefinition = matchLatestDefinitionEnabled;
    };
    // whenAsync
    ////////////////////////////////////
    HttpBackendService.prototype.findMatchingMock = function (request) {
        var _this = this;
        var backendEntry = (this.matchLatestDefinition
            ? this.backends[request.method].slice().reverse()
            : this.backends[request.method]).find(function (entry) {
            if (typeof entry.pattern === 'string') {
                return (request.urlWithParams.endsWith(entry.pattern) &&
                    _this.matchingPayloadRestriction(entry, request));
            }
            else {
                var test = entry.pattern.test(request.urlWithParams) &&
                    _this.matchingPayloadRestriction(entry, request);
                entry.pattern.lastIndex = 0;
                return test;
            }
        });
        return backendEntry ? backendEntry.mock : undefined;
    };
    HttpBackendService.prototype._whenMethod = function (method, pattern, matchingPayload) {
        var entry = new BackendEntry(pattern, matchingPayload);
        this.backends[method].push(entry);
        return entry;
    };
    HttpBackendService.prototype.matchingPayloadRestriction = function (entry, request) {
        return entry.matchingPayload ? lodash.isEqual(entry.matchingPayload, request.body) : true;
    };
    HttpBackendService = tslib_1.__decorate([
        Injectable()
    ], HttpBackendService);
    return HttpBackendService;
}());
export { HttpBackendService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1iYWNrZW5kLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac21hcnQvdXRpbHMvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9pbnRlcmNlcHRvcnMvYmFja2VuZC9odHRwLWJhY2tlbmQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHO0FBQ0gseUNBQXlDO0FBQ3pDLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUE2QjNDOzs7Ozs7O0dBT0c7QUFDSDtJQUdJLHNCQUFtQixPQUF3QixFQUFTLGVBQTJCO1FBQTVELFlBQU8sR0FBUCxPQUFPLENBQWlCO1FBQVMsb0JBQWUsR0FBZixlQUFlLENBQVk7SUFBRyxDQUFDO0lBRW5GOzs7Ozs7T0FNRztJQUNILDhCQUFPLEdBQVAsVUFBUSxJQUFvQjtRQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsa0NBQVcsR0FBWDtRQUNJLEVBQUU7SUFDTixDQUFDO0lBQ0wsbUJBQUM7QUFBRCxDQUFDLEFBcEJELElBb0JDOztBQU1EOzs7Ozs7O0dBT0c7QUFFSDtJQURBO1FBRVksMEJBQXFCLEdBQVksS0FBSyxDQUFDO1FBRXZDLGFBQVEsR0FBb0I7WUFDaEMsR0FBRyxFQUFFLEVBQUU7WUFDUCxJQUFJLEVBQUUsRUFBRTtZQUNSLEdBQUcsRUFBRSxFQUFFO1lBQ1AsTUFBTSxFQUFFLEVBQUU7U0FDYixDQUFDO0lBMklOLENBQUM7SUF6SUc7Ozs7Ozs7OztPQVNHO0lBQ0gsb0NBQU8sR0FBUCxVQUFRLE9BQXdCO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUNEOzs7Ozs7Ozs7O09BVUc7SUFDSCxxQ0FBUSxHQUFSLFVBQVMsT0FBd0Is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QyxLQUFLLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzlGLENBQUM7SUFsSlEsa0JBQWtCO1FBRDlCLFVBQVUsRUFBRTtPQUNBLGtCQUFrQixDQW1KOUI7SUFBRCx5QkFBQztDQUFBLEFBbkpELElBbUpDO1NBbkpZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IFNBUCBTRSBvciBhbiBTQVAgYWZmaWxpYXRlIGNvbXBhbnkuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAbW9kdWxlIHNtYXJ0dXRpbHNcbiAqL1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmltcG9ydCAqIGFzIGxvZGFzaCBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSHR0cFJlcXVlc3QgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBDbG9uZWFibGUsIFBheWxvYWQsIFR5cGVkTWFwIH0gZnJvbSAnLi4vLi4vLi4vZHRvcyc7XG5cbmV4cG9ydCB0eXBlIFJFU1RNRVRIT0QgPSAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURSc7XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgQHNtYXJ0dXRpbHMub2JqZWN0OkJhY2tlbmRSZXNwb25kXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tlZCByZXNwb25zZSBvZiBhIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2UgSHR0cEJhY2tlbmRTZXJ2aWNlfSBpbnZvY2F0aW9uXG4gKiBJdCBpcyBlaXRoZXIgYSBDbG9uZWFibGUgcGF5bG9hZCAocmV0dXJuZWQgYXV0b21hdGljYWxseSB3aXRoIDIwMCBzdGF0dXMgY29kZSlcbiAqIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5IG9mIDIgYXJndW1lbnRzOiB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBwYXlsb2FkXG4gKiBpZiBhIGZ1bmN0aW9uLCBpdCBpcyBpbnZva2VkIHdpdGg6XG4gKiBAcGFyYW0ge3N0cmluZz19IG1ldGhvZCBHRVQsIFBPU1QsIFBVVCBvciBERUxFVEVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdXJsIHRoZSBmdWxsIHVybCB3aXRoIHF1ZXJ5IHN0cmluZ1xuICogQHBhcmFtIHthbnk9fSBkYXRhIHRoZSBwYXlsb2FkIG9yIHRoZSByZXF1ZXN0LCBvciB0aGUgUE9TVCBxdWVyeXN0cmluZ1xuICogQHBhcmFtIHtUeXBlZE1hcDxzdHJpbmc+PX0gaGVhZGVycyB0aGUgb3V0cGJvdW5kIHJlcXVlc3QgaGVhZGVycyBtYXBcbiAqL1xuZXhwb3J0IHR5cGUgQmFja2VuZFJlc3BvbmQgPVxuICAgIHwgUGF5bG9hZFxuICAgIHwgUGF5bG9hZFtdXG4gICAgfCAoKFxuICAgICAgICAgIG1ldGhvZD86IHN0cmluZyxcbiAgICAgICAgICB1cmw/OiBzdHJpbmcsXG4gICAgICAgICAgZGF0YT86IGFueSxcbiAgICAgICAgICBoZWFkZXJzPzogVHlwZWRNYXA8c3RyaW5nPlxuICAgICAgKSA9PiBbbnVtYmVyLCBQYXlsb2FkIHwgUGF5bG9hZFtdXSB8IFByb21pc2VMaWtlPFtudW1iZXIsIFBheWxvYWQgfCBQYXlsb2FkW11dPik7XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeVxuICogQGRlc2NyaXB0aW9uXG4gKiBJbnZvY2F0aW9ucyBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlfSB3aGVuLCB3aGVuR0VULCB3aGVuUE9TVCwgd2hlblBVVCwgd2hlbkRFTEVURVxuICogYWxsIHJldHVybiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IEJhY2tlbmRFbnRyeX1cbiAqIEl0IGlzIHVzZWQgdG8gc3BlY2lmeSB0aGUgbW9ja2VkIHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY29uZGl0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhY2tlbmRFbnRyeSB7XG4gICAgbW9jaz86IEJhY2tlbmRSZXNwb25kO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCwgcHVibGljIG1hdGNoaW5nUGF5bG9hZD86IENsb25lYWJsZSkge31cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpCYWNrZW5kRW50cnkjcmVzcG9uZFxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpCYWNrZW5kRW50cnlcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0ge0JhY2tlbmRSZXNwb25kfSBtb2NrIHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkJhY2tlbmRSZXNwb25kfSB0byByZXR1cm4gZm9yIHRoZSBnaXZlbiBjb25kaXRpb25zXG4gICAgICovXG4gICAgcmVzcG9uZChtb2NrOiBCYWNrZW5kUmVzcG9uZCk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHRoaXMubW9jayA9IG1vY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBhc3NUaHJvdWdoKCk6IHZvaWQge1xuICAgICAgICAvL1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZW5kRW50cnlNYXAge1xuICAgIFtpbmRleDogc3RyaW5nXTogQmFja2VuZEVudHJ5W107XG59XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXJ2aWNlIGFpbWVkIHRvIHByb3ZpZGUgbW9ja2VkIGJhY2tlbmQgcmVzcG9uc2VzIGZvciBnaXZlbiBodHRwIHJlcXVlc3QgcGF0dGVybnMuXG4gKiBJdCBmb2xsb3dzIHRoZSBBUEkgb2Yge0BsaW5rIGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZ01vY2tFMkUvc2VydmljZS8kaHR0cEJhY2tlbmQgJGh0dHBCYWNrZW5kfVxuICogbWludXMgYSBmZXcgbGltaXRhdGlvbnNcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEh0dHBCYWNrZW5kU2VydmljZSB7XG4gICAgcHJpdmF0ZSBtYXRjaExhdGVzdERlZmluaXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYmFja2VuZHM6IEJhY2tlbmRFbnRyeU1hcCA9IHtcbiAgICAgICAgR0VUOiBbXSxcbiAgICAgICAgUE9TVDogW10sXG4gICAgICAgIFBVVDogW10sXG4gICAgICAgIERFTEVURTogW11cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuR0VUXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI3doZW5HRVQgJGh0dHBCYWNrZW5kI3doZW5HRVR9XG4gICAgICogYnV0IHdpdGggb25seSB0aGUgdXJsIHBhdHRlcm4gYXMgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IHBhdHRlcm4gdXJsIGVuZCBvZiB0aGUgdXJsIHBhdHRlcm4gdG8gbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7QmFja2VuZEVudHJ5fSB0aGUge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSBiYWNrZW5FbnRyeX1cbiAgICAgKi9cbiAgICB3aGVuR0VUKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuTWV0aG9kKCdHRVQnLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuUE9TVFxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBtZXRob2Qgc2ltaWxhciB0byB7QGxpbmsgaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nTW9ja0UyRS9zZXJ2aWNlLyRodHRwQmFja2VuZCN3aGVuUE9TVCAkaHR0cEJhY2tlbmQjd2hlblBPU1R9XG4gICAgICogYnV0IHdpdGggb25seSB0aGUgZmlyc3QgMiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcGF0dGVybiB1cmwgZW5kIG9mIHRoZSB1cmwgcGF0dGVybiB0byBtYXRjaFxuICAgICAqIEBwYXJhbSB7Q2xvZW5hYmxlPX0gbWF0Y2hpbmdQYXlsb2FkIEhUVFAgcmVxdWVzdCBib2R5IHRvIGJlIG1hdGNoZWRcbiAgICAgKiBAcmV0dXJucyB7QmFja2VuZEVudHJ5fSB0aGUge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSBiYWNrZW5FbnRyeX1cbiAgICAgKi9cbiAgICB3aGVuUE9TVChwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHAsIG1hdGNoaW5nUGF5bG9hZD86IENsb25lYWJsZSk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuTWV0aG9kKCdQT1NUJywgcGF0dGVybiwgbWF0Y2hpbmdQYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuUFVUXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI3doZW5QVVQgJGh0dHBCYWNrZW5kI3doZW5QVVR9XG4gICAgICogYnV0IHdpdGggb25seSB0aGUgZmlyc3QgMiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcGF0dGVybiB1cmwgZW5kIG9mIHRoZSB1cmwgcGF0dGVybiB0byBtYXRjaFxuICAgICAqIEBwYXJhbSB7Q2xvZW5hYmxlPX0gbWF0Y2hpbmdQYXlsb2FkIEhUVFAgcmVxdWVzdCBib2R5IHRvIGJlIG1hdGNoZWRcbiAgICAgKiBAcmV0dXJucyB7QmFja2VuZEVudHJ5fSB0aGUge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSBiYWNrZW5FbnRyeX1cbiAgICAgKi9cbiAgICB3aGVuUFVUKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCwgbWF0Y2hpbmdQYXlsb2FkPzogQ2xvbmVhYmxlKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZW5NZXRob2QoJ1BVVCcsIHBhdHRlcm4sIG1hdGNoaW5nUGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2Ujd2hlblBVVFxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBtZXRob2Qgc2ltaWxhciB0byB7QGxpbmsgaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nTW9ja0UyRS9zZXJ2aWNlLyRodHRwQmFja2VuZCN3aGVuUFVUICRodHRwQmFja2VuZCN3aGVuUFVUfVxuICAgICAqIGJ1dCB3aXRoIG9ubHkgdGhlIHVybCBwYXR0ZXJuIGFzIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBwYXR0ZXJuIHVybCBlbmQgb2YgdGhlIHVybCBwYXR0ZXJuIHRvIG1hdGNoXG4gICAgICogQHJldHVybnMge0JhY2tlbmRFbnRyeX0gdGhlIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpCYWNrZW5kRW50cnkgYmFja2VuRW50cnl9XG4gICAgICovXG4gICAgd2hlbkRFTEVURShwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHApOiBCYWNrZW5kRW50cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2hlbk1ldGhvZCgnREVMRVRFJywgcGF0dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2Ujd2hlblxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBtZXRob2Qgc2ltaWxhciB0byB7QGxpbmsgaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nTW9ja0UyRS9zZXJ2aWNlLyRodHRwQmFja2VuZCN3aGVuICRodHRwQmFja2VuZCN3aGVufVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgR0VULCBQT1NULCBQVVQsIG9yIERFTEVURVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBwYXR0ZXJuIHVybCBlbmQgb2YgdGhlIHVybCBwYXR0ZXJuIHRvIG1hdGNoXG4gICAgICogQHBhcmFtIHtDbG9lbmFibGU9fSBtYXRjaGluZ1BheWxvYWQgSFRUUCByZXF1ZXN0IGJvZHkgdG8gYmUgbWF0Y2hlZFxuICAgICAqIEByZXR1cm5zIHtCYWNrZW5kRW50cnl9IHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IGJhY2tlbkVudHJ5fVxuICAgICAqL1xuICAgIHdoZW4obWV0aG9kOiBSRVNUTUVUSE9ELCBwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHAsIG1hdGNoaW5nUGF5bG9hZD86IENsb25lYWJsZSk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuTWV0aG9kKG1ldGhvZCwgcGF0dGVybiwgbWF0Y2hpbmdQYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuQXN5bmNcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogbWV0aG9kIHNpbWlsYXIgdG8gbGVnYWN5ICRodHRwQmFja2VuZCN3aGVuQXN5bmMsIHVzZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI3doZW4gSHR0cEJhY2tlbmRTZXJ2aWNlI3doZW59IGluc3RlYWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIEdFVCwgUE9TVCwgUFVULCBvciBERUxFVEVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcGF0dGVybiB1cmwgZW5kIG9mIHRoZSB1cmwgcGF0dGVybiB0byBtYXRjaFxuICAgICAqIEBwYXJhbSB7Q2xvZW5hYmxlPX0gbWF0Y2hpbmdQYXlsb2FkIEhUVFAgcmVxdWVzdCBib2R5IHRvIGJlIG1hdGNoZWRcbiAgICAgKiBAcmV0dXJucyB7QmFja2VuZEVudHJ5fSB0aGUge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSBiYWNrZW5FbnRyeX1cbiAgICAgKi9cbiAgICB3aGVuQXN5bmMoXG4gICAgICAgIG1ldGhvZDogUkVTVE1FVEhPRCxcbiAgICAgICAgcGF0dGVybjogc3RyaW5nIHwgUmVnRXhwLFxuICAgICAgICBtYXRjaGluZ1BheWxvYWQ/OiBDbG9uZWFibGVcbiAgICApOiBCYWNrZW5kRW50cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2hlbk1ldGhvZChtZXRob2QsIHBhdHRlcm4sIG1hdGNoaW5nUGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSNtYXRjaExhdGVzdERlZmluaXRpb25FbmFibGVkXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI21hdGNoTGF0ZXN0RGVmaW5pdGlvbkVuYWJsZWQgJGh0dHBCYWNrZW5kI21hdGNoTGF0ZXN0RGVmaW5pdGlvbkVuYWJsZWR9XG4gICAgICogQHBhcmFtIHtib29sZWFuPWZhbHNlfSBtYXRjaExhdGVzdERlZmluaXRpb25FbmFibGVkIGlmIHRydWUsIHRoZSBsYXN0IG1hdGNoaW5nIHBhdHRlcm4gd2lsbCBiZSBwaWNrZWQuIE90aGVyd2lzZSB0aGUgZmlyc3QgaXMgcGlja2VkXG4gICAgICovXG4gICAgbWF0Y2hMYXRlc3REZWZpbml0aW9uRW5hYmxlZChtYXRjaExhdGVzdERlZmluaXRpb25FbmFibGVkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMubWF0Y2hMYXRlc3REZWZpbml0aW9uID0gbWF0Y2hMYXRlc3REZWZpbml0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICAvLyB3aGVuQXN5bmNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGZpbmRNYXRjaGluZ01vY2socmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IEJhY2tlbmRSZXNwb25kIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEVudHJ5ID0gKHRoaXMubWF0Y2hMYXRlc3REZWZpbml0aW9uXG4gICAgICAgICAgICA/IHRoaXMuYmFja2VuZHNbcmVxdWVzdC5tZXRob2RdLnNsaWNlKCkucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXMuYmFja2VuZHNbcmVxdWVzdC5tZXRob2RdXG4gICAgICAgICkuZmluZCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkucGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnVybFdpdGhQYXJhbXMuZW5kc1dpdGgoZW50cnkucGF0dGVybikgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGluZ1BheWxvYWRSZXN0cmljdGlvbihlbnRyeSwgcmVxdWVzdClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID1cbiAgICAgICAgICAgICAgICAgICAgZW50cnkucGF0dGVybi50ZXN0KHJlcXVlc3QudXJsV2l0aFBhcmFtcykgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGluZ1BheWxvYWRSZXN0cmljdGlvbihlbnRyeSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgZW50cnkucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYmFja2VuZEVudHJ5ID8gYmFja2VuZEVudHJ5Lm1vY2sgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd2hlbk1ldGhvZChcbiAgICAgICAgbWV0aG9kOiBSRVNUTUVUSE9ELFxuICAgICAgICBwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHAsXG4gICAgICAgIG1hdGNoaW5nUGF5bG9hZD86IENsb25lYWJsZVxuICAgICk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEJhY2tlbmRFbnRyeShwYXR0ZXJuLCBtYXRjaGluZ1BheWxvYWQpO1xuICAgICAgICB0aGlzLmJhY2tlbmRzW21ldGhvZF0ucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG1hdGNoaW5nUGF5bG9hZFJlc3RyaWN0aW9uKGVudHJ5OiBCYWNrZW5kRW50cnksIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5Lm1hdGNoaW5nUGF5bG9hZCA/IGxvZGFzaC5pc0VxdWFsKGVudHJ5Lm1hdGNoaW5nUGF5bG9hZCwgcmVxdWVzdC5ib2R5KSA6IHRydWU7XG4gICAgfVxufVxuIl19