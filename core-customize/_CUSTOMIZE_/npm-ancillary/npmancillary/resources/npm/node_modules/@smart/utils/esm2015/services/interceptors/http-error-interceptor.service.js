/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector } from '@angular/core';
import * as lodash from 'lodash';
import { from } from 'rxjs';
import { Deferred, PromiseUtils } from '../../utils';
/**
 * @ngdoc service
 * @name @smartutils.services:httpErrorInterceptorService
 *
 * @description
 * The httpErrorInterceptorService provides the functionality to add custom HTTP error interceptors.
 * An interceptor can be an {Object} or an Angular Factory and must be represented by a pair of functions:
 * - predicate(request, response) {Function} that must return true if the response is associated to the interceptor. Important: The predicate must be designed to fulfill a specific function. It must not be defined for generic use.
 * - responseError(request, response) {Function} function called if the current response error matches the predicate. It must return a {Promise} with the resolved or rejected response.
 *
 * Each time an HTTP request fails, the service iterates through all registered interceptors. It sequentially calls the responseError function for all interceptors that have a predicate returning true for the current response error. If an interceptor modifies the response, the next interceptor that is called will have the modified response.
 * The last interceptor added to the service will be the first interceptor called. This makes it possible to override default interceptors.
 * If an interceptor resolves the response, the service service stops the iteration.
 */
let HttpErrorInterceptorService = class HttpErrorInterceptorService {
    constructor(injector, promiseUtils) {
        this.injector = injector;
        this.promiseUtils = promiseUtils;
        this._errorInterceptors = [];
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:httpErrorInterceptorService#addInterceptor
     * @methodOf @smartutils.services:httpErrorInterceptorService
     *
     * @description
     * Add a new error interceptor
     *
     * @param {Object|String} interceptor The interceptor {Object} or angular Factory
     *
     * @returns {Function} Function to call to unregister the interceptor from the service
     *
     * @example
     * ```js
     *      // Add a new interceptor with an instance of IHttpErrorInterceptor:
     *      var unregisterCustomInterceptor = httpErrorInterceptorService.addInterceptor({
     *          predicate: function(request, response) {
     *              return response.status === 400;
     *          },
     *          responseError: function(request, response) {
     *              alertService.showDanger({
     *                  message: response.message
     *              });
     *              return Promise.reject(response);// FIXME: update doc
     *          }
     *      });
     *
     *      // Add an interceptor with a class of IHttpErrorInterceptor:
     *      var unregisterCustomInterceptor = httpErrorInterceptorService.addInterceptor(CustomErrorInterceptor);
     *
     *      // Unregister the interceptor:
     *      unregisterCustomInterceptor();
     * ```
     */
    addInterceptors(interceptorClasses) {
        interceptorClasses.forEach((InterceptorClass) => {
            this.addInterceptor(InterceptorClass);
        });
    }
    addInterceptor(_interceptor) {
        let interceptor;
        if (_interceptor.predicate ||
            _interceptor.responseError) {
            interceptor = _interceptor;
        }
        else {
            interceptor = this.injector.get(_interceptor);
        }
        this._validateInterceptor(interceptor);
        this._errorInterceptors.unshift(interceptor);
        return () => {
            this._errorInterceptors.splice(this._errorInterceptors.indexOf(interceptor), 1);
        };
    }
    responseError(request, response) {
        const matchingErrorInterceptors = this._errorInterceptors.filter((errorInterceptor) => errorInterceptor.predicate(request, response) === true);
        const _interceptorsDeferred = this.promiseUtils.defer();
        if (matchingErrorInterceptors.length) {
            this._iterateErrorInterceptors(request.clone(), lodash.cloneDeep(response), matchingErrorInterceptors, _interceptorsDeferred);
        }
        else {
            _interceptorsDeferred.reject(response);
        }
        return from(_interceptorsDeferred.promise);
    }
    _iterateErrorInterceptors(request, response, interceptors, _interceptorsDeferred, idx = 0) {
        if (idx === interceptors.length) {
            _interceptorsDeferred.reject(response);
        }
        else {
            const iterateFn = this._iterateErrorInterceptors.bind(this);
            // FIXME: fully convert this part to Observable chaining
            Promise.resolve(interceptors[idx].responseError(request, response)).then((interceptedResponse) => {
                _interceptorsDeferred.resolve(interceptedResponse);
            }, (interceptedResponse) => {
                iterateFn(request, interceptedResponse, interceptors, _interceptorsDeferred, ++idx);
            });
        }
    }
    /**
     * @ignore
     * Validate if the provided interceptor respects the Interface (predicate and responseError functions are mandatory).
     * @param {Object|String} interceptor The interceptor {Object} or angular Factory
     */
    _validateInterceptor(interceptor) {
        if (!interceptor.predicate || typeof interceptor.predicate !== 'function') {
            throw new Error('httpErrorInterceptorService.addInterceptor.error.interceptor.has.no.predicate');
        }
        if (!interceptor.responseError || typeof interceptor.responseError !== 'function') {
            throw new Error('httpErrorInterceptorService.addInterceptor.error.interceptor.has.no.responseError');
        }
    }
};
HttpErrorInterceptorService.ctorParameters = () => [
    { type: Injector },
    { type: PromiseUtils }
];
HttpErrorInterceptorService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [Injector, PromiseUtils])
], HttpErrorInterceptorService);
export { HttpErrorInterceptorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1lcnJvci1pbnRlcmNlcHRvci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsic2VydmljZXMvaW50ZXJjZXB0b3JzL2h0dHAtZXJyb3ItaW50ZXJjZXB0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBS0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxLQUFLLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLElBQUksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUlyRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsSUFBYSwyQkFBMkIsR0FBeEMsTUFBYSwyQkFBMkI7SUFHcEMsWUFBb0IsUUFBa0IsRUFBVSxZQUEwQjtRQUF0RCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQVUsaUJBQVksR0FBWixZQUFZLENBQWM7UUFGbEUsdUJBQWtCLEdBQTRCLEVBQUUsQ0FBQztJQUVvQixDQUFDO0lBRTlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQ0c7SUFFSCxlQUFlLENBQ1gsa0JBQTRFO1FBRTVFLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDNUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELGNBQWMsQ0FBQyxZQUFrRTtRQUM3RSxJQUFJLFdBQWtDLENBQUM7UUFDdkMsSUFDSyxZQUFzQyxDQUFDLFNBQVM7WUFDaEQsWUFBc0MsQ0FBQyxhQUFhLEVBQ3ZEO1lBQ0UsV0FBVyxHQUFHLFlBQXFDLENBQUM7U0FDdkQ7YUFBTTtZQUNILFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFD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KGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG5pbXBvcnQgeyBIdHRwRXJyb3JSZXNwb25zZSwgSHR0cEV2ZW50LCBIdHRwUmVxdWVzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERlZmVycmVkLCBQcm9taXNlVXRpbHMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBDbGFzcyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IElIdHRwRXJyb3JJbnRlcmNlcHRvciB9IGZyb20gJy4vaS1odHRwLWVycm9yLmludGVyY2VwdG9yJztcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6aHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgaHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlIHByb3ZpZGVzIHRoZSBmdW5jdGlvbmFsaXR5IHRvIGFkZCBjdXN0b20gSFRUUCBlcnJvciBpbnRlcmNlcHRvcnMuXG4gKiBBbiBpbnRlcmNlcHRvciBjYW4gYmUgYW4ge09iamVjdH0gb3IgYW4gQW5ndWxhciBGYWN0b3J5IGFuZCBtdXN0IGJlIHJlcHJlc2VudGVkIGJ5IGEgcGFpciBvZiBmdW5jdGlvbnM6XG4gKiAtIHByZWRpY2F0ZShyZXF1ZXN0LCByZXNwb25zZSkge0Z1bmN0aW9ufSB0aGF0IG11c3QgcmV0dXJuIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGludGVyY2VwdG9yLiBJbXBvcnRhbnQ6IFRoZSBwcmVkaWNhdGUgbXVzdCBiZSBkZXNpZ25lZCB0byBmdWxmaWxsIGEgc3BlY2lmaWMgZnVuY3Rpb24uIEl0IG11c3Qgbm90IGJlIGRlZmluZWQgZm9yIGdlbmVyaWMgdXNlLlxuICogLSByZXNwb25zZUVycm9yKHJlcXVlc3QsIHJlc3BvbnNlKSB7RnVuY3Rpb259IGZ1bmN0aW9uIGNhbGxlZCBpZiB0aGUgY3VycmVudCByZXNwb25zZSBlcnJvciBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuIEl0IG11c3QgcmV0dXJuIGEge1Byb21pc2V9IHdpdGggdGhlIHJlc29sdmVkIG9yIHJlamVjdGVkIHJlc3BvbnNlLlxuICpcbiAqIEVhY2ggdGltZSBhbiBIVFRQIHJlcXVlc3QgZmFpbHMsIHRoZSBzZXJ2aWNlIGl0ZXJhdGVzIHRocm91Z2ggYWxsIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzLiBJdCBzZXF1ZW50aWFsbHkgY2FsbHMgdGhlIHJlc3BvbnNlRXJyb3IgZnVuY3Rpb24gZm9yIGFsbCBpbnRlcmNlcHRvcnMgdGhhdCBoYXZlIGEgcHJlZGljYXRlIHJldHVybmluZyB0cnVlIGZvciB0aGUgY3VycmVudCByZXNwb25zZSBlcnJvci4gSWYgYW4gaW50ZXJjZXB0b3IgbW9kaWZpZXMgdGhlIHJlc3BvbnNlLCB0aGUgbmV4dCBpbnRlcmNlcHRvciB0aGF0IGlzIGNhbGxlZCB3aWxsIGhhdmUgdGhlIG1vZGlmaWVkIHJlc3BvbnNlLlxuICogVGhlIGxhc3QgaW50ZXJjZXB0b3IgYWRkZWQgdG8gdGhlIHNlcnZpY2Ugd2lsbCBiZSB0aGUgZmlyc3QgaW50ZXJjZXB0b3IgY2FsbGVkLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIG92ZXJyaWRlIGRlZmF1bHQgaW50ZXJjZXB0b3JzLlxuICogSWYgYW4gaW50ZXJjZXB0b3IgcmVzb2x2ZXMgdGhlIHJlc3BvbnNlLCB0aGUgc2VydmljZSBzZXJ2aWNlIHN0b3BzIHRoZSBpdGVyYXRpb24uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIdHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2Uge1xuICAgIHByaXZhdGUgX2Vycm9ySW50ZXJjZXB0b3JzOiBJSHR0cEVycm9ySW50ZXJjZXB0b3JbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsIHByaXZhdGUgcHJvbWlzZVV0aWxzOiBQcm9taXNlVXRpbHMpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6aHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlI2FkZEludGVyY2VwdG9yXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOmh0dHBFcnJvckludGVyY2VwdG9yU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQWRkIGEgbmV3IGVycm9yIGludGVyY2VwdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGludGVyY2VwdG9yIFRoZSBpbnRlcmNlcHRvciB7T2JqZWN0fSBvciBhbmd1bGFyIEZhY3RvcnlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gRnVuY3Rpb24gdG8gY2FsbCB0byB1bnJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogICAgICAvLyBBZGQgYSBuZXcgaW50ZXJjZXB0b3Igd2l0aCBhbiBpbnN0YW5jZSBvZiBJSHR0cEVycm9ySW50ZXJjZXB0b3I6XG4gICAgICogICAgICB2YXIgdW5yZWdpc3RlckN1c3RvbUludGVyY2VwdG9yID0gaHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlLmFkZEludGVyY2VwdG9yKHtcbiAgICAgKiAgICAgICAgICBwcmVkaWNhdGU6IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICogICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IDQwMDtcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIHJlc3BvbnNlRXJyb3I6IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICogICAgICAgICAgICAgIGFsZXJ0U2VydmljZS5zaG93RGFuZ2VyKHtcbiAgICAgKiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLm1lc3NhZ2VcbiAgICAgKiAgICAgICAgICAgICAgfSk7XG4gICAgICogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXNwb25zZSk7Ly8gRklYTUU6IHVwZGF0ZSBkb2NcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqICAgICAgLy8gQWRkIGFuIGludGVyY2VwdG9yIHdpdGggYSBjbGFzcyBvZiBJSHR0cEVycm9ySW50ZXJjZXB0b3I6XG4gICAgICogICAgICB2YXIgdW5yZWdpc3RlckN1c3RvbUludGVyY2VwdG9yID0gaHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlLmFkZEludGVyY2VwdG9yKEN1c3RvbUVycm9ySW50ZXJjZXB0b3IpO1xuICAgICAqXG4gICAgICogICAgICAvLyBVbnJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvcjpcbiAgICAgKiAgICAgIHVucmVnaXN0ZXJDdXN0b21JbnRlcmNlcHRvcigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuXG4gICAgYWRkSW50ZXJjZXB0b3JzKFxuICAgICAgICBpbnRlcmNlcHRvckNsYXNzZXM6IChDbGFzczxJSHR0cEVycm9ySW50ZXJjZXB0b3I+IHwgSUh0dHBFcnJvckludGVyY2VwdG9yKVtdXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGludGVyY2VwdG9yQ2xhc3Nlcy5mb3JFYWNoKChJbnRlcmNlcHRvckNsYXNzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZEludGVyY2VwdG9yKEludGVyY2VwdG9yQ2xhc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRJbnRlcmNlcHRvcihfaW50ZXJjZXB0b3I6IENsYXNzPElIdHRwRXJyb3JJbnRlcmNlcHRvcj4gfCBJSHR0cEVycm9ySW50ZXJjZXB0b3IpOiAoKSA9PiB2b2lkIHtcbiAgICAgICAgbGV0IGludGVyY2VwdG9yOiBJSHR0cEVycm9ySW50ZXJjZXB0b3I7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChfaW50ZXJjZXB0b3IgYXMgSUh0dHBFcnJvckludGVyY2VwdG9yKS5wcmVkaWNhdGUgfHxcbiAgICAgICAgICAgIChfaW50ZXJjZXB0b3IgYXMgSUh0dHBFcnJvckludGVyY2VwdG9yKS5yZXNwb25zZUVycm9yXG4gICAgICAgICkge1xuICAgICAgICAgICAgaW50ZXJjZXB0b3IgPSBfaW50ZXJjZXB0b3IgYXMgSUh0dHBFcnJvckludGVyY2VwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJjZXB0b3IgPSB0aGlzLmluamVjdG9yLmdldChfaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3IpO1xuICAgICAgICB0aGlzLl9lcnJvckludGVyY2VwdG9ycy51bnNoaWZ0KGludGVyY2VwdG9yKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JJbnRlcmNlcHRvcnMuc3BsaWNlKHRoaXMuX2Vycm9ySW50ZXJjZXB0b3JzLmluZGV4T2YoaW50ZXJjZXB0b3IpLCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXNwb25zZUVycm9yPFQ+KFxuICAgICAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxUPixcbiAgICAgICAgcmVzcG9uc2U6IEh0dHBFcnJvclJlc3BvbnNlXG4gICAgKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8VD4+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFcnJvckludGVyY2VwdG9ycyA9IHRoaXMuX2Vycm9ySW50ZXJjZXB0b3JzLmZpbHRlcihcbiAgICAgICAgICAgIChlcnJvckludGVyY2VwdG9yKSA9PiBlcnJvckludGVyY2VwdG9yLnByZWRpY2F0ZShyZXF1ZXN0LCByZXNwb25zZSkgPT09IHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgX2ludGVyY2VwdG9yc0RlZmVycmVkOiBEZWZlcnJlZDxhbnk+ID0gdGhpcy5wcm9taXNlVXRpbHMuZGVmZXI8YW55PigpO1xuICAgICAgICBpZiAobWF0Y2hpbmdFcnJvckludGVyY2VwdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGVFcnJvckludGVyY2VwdG9yczxUPihcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgbG9kYXNoLmNsb25lRGVlcChyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdFcnJvckludGVyY2VwdG9ycyxcbiAgICAgICAgICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWQucmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbShfaW50ZXJjZXB0b3JzRGVmZXJyZWQucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXRlcmF0ZUVycm9ySW50ZXJjZXB0b3JzPFQ+KFxuICAgICAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxUPixcbiAgICAgICAgcmVzcG9uc2U6IEh0dHBFcnJvclJlc3BvbnNlLFxuICAgICAgICBpbnRlcmNlcHRvcnM6IElIdHRwRXJyb3JJbnRlcmNlcHRvcltdLFxuICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWQ6IERlZmVycmVkPGFueT4sXG4gICAgICAgIGlkeDogbnVtYmVyID0gMFxuICAgICk6IHZvaWQge1xuICAgICAgICBpZiAoaWR4ID09PSBpbnRlcmNlcHRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWQucmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGVGbiA9IHRoaXMuX2l0ZXJhdGVFcnJvckludGVyY2VwdG9ycy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gRklYTUU6IGZ1bGx5IGNvbnZlcnQgdGhpcyBwYXJ0IHRvIE9ic2VydmFibGUgY2hhaW5pbmdcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpbnRlcmNlcHRvcnNbaWR4XS5yZXNwb25zZUVycm9yKHJlcXVlc3QsIHJlc3BvbnNlKSkudGhlbihcbiAgICAgICAgICAgICAgICAoaW50ZXJjZXB0ZWRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWQucmVzb2x2ZShpbnRlcmNlcHRlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChpbnRlcmNlcHRlZFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVGbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2ludGVyY2VwdG9yc0RlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgKytpZHhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqIFZhbGlkYXRlIGlmIHRoZSBwcm92aWRlZCBpbnRlcmNlcHRvciByZXNwZWN0cyB0aGUgSW50ZXJmYWNlIChwcmVkaWNhdGUgYW5kIHJlc3BvbnNlRXJyb3IgZnVuY3Rpb25zIGFyZSBtYW5kYXRvcnkpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW50ZXJjZXB0b3IgVGhlIGludGVyY2VwdG9yIHtPYmplY3R9IG9yIGFuZ3VsYXIgRmFjdG9yeVxuICAgICAqL1xuICAgIHByaXZhdGUgX3ZhbGlkYXRlSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3I6IElIdHRwRXJyb3JJbnRlcmNlcHRvcikge1xuICAgICAgICBpZiAoIWludGVyY2VwdG9yLnByZWRpY2F0ZSB8fCB0eXBlb2YgaW50ZXJjZXB0b3IucHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2h0dHBFcnJvckludGVyY2VwdG9yU2VydmljZS5hZGRJbnRlcmNlcHRvci5lcnJvci5pbnRlcmNlcHRvci5oYXMubm8ucHJlZGljYXRlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IgfHwgdHlwZW9mIGludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnaHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlLmFkZEludGVyY2VwdG9yLmVycm9yLmludGVyY2VwdG9yLmhhcy5uby5yZXNwb25zZUVycm9yJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==