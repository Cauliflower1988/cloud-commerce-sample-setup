/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as lodash from 'lodash';
import { FunctionsUtils } from '../utils';
/** @internal */
var annotationType;
(function (annotationType) {
    annotationType["Class"] = "ClassAnnotation";
    annotationType["Method"] = "MethodAnnotation";
})(annotationType || (annotationType = {}));
/**
 * @ngdoc service
 * @name @smartutils.services:AnnotationService
 *
 * @description
 * Utility service to declare and consume method level and class level {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript decorator factories}.
 * <br/>Since Decorator is a reserved word in Smartedit, Typescript Decorators are called as Annotations.
 */
export class AnnotationService {
    constructor() {
        this.INJECTABLE_NAME_KEY = 'getInjectableName';
        this.ORIGINAL_CONSTRUCTOR_KEY = 'originalConstructor';
        /**
         * @ngdoc method
         * @name @smartutils.services:AnnotationService#getClassAnnotations
         * @methodOf @smartutils.services:AnnotationService
         *
         * @description
         * Retrieves an object with all the string-indexed annotations defined on the given class target
         * @param {any} target The typescript class on which class annotations are defined
         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
         */
        this.getClassAnnotations = lodash.memoize(this.getClassAnnotationsLogic);
        /**
         * @ngdoc method
         * @name @smartutils.services:AnnotationService#getMethodAnnotations
         * @methodOf @smartutils.services:AnnotationService
         *
         * @description
         * Retrieves an object with all the string indexed annotations defined on the given class method
         * @param {any} target The typescript class to the inspected
         * @param {string} propertyName The name of the method on which annotations are defined
         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
         */
        this.getMethodAnnotations = lodash.memoize(this.getMethodAnnotationsLogic, function (target, propertyName) {
            return JSON.stringify(target.prototype) + propertyName;
        });
        this.functionsUtils = new FunctionsUtils();
        this.annotationFactoryMap = {};
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getClassAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves arguments of class annotation under a given annotation name
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {any} the payload passed to the annotation
     */
    getClassAnnotation(target, annotation) {
        const annotationMap = this.getClassAnnotations(target);
        const annotationName = annotation.annotationName;
        if (annotationMap) {
            if (annotationName in annotationMap) {
                return annotationMap[annotationName];
            }
        }
        else {
            return null;
        }
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getMethodAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves arguments of method annotation for a given typescript class
     * @param {any} target The typescript class
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator)} annotation The type of the method annotation
     * @returns {any} the payload passed to the annotation
     */
    getMethodAnnotation(target, propertyName, annotation) {
        const annotationMap = this.getMethodAnnotations(target, propertyName);
        const annotationName = annotation.annotationName;
        if (annotationMap) {
            if (annotationName in annotationMap) {
                return annotationMap[annotationName];
            }
        }
        else {
            return null;
        }
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#hasClassAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Determines whether a given class target has given annotation name defined or not
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {boolean} true if a given target has given annotation name. Otherwise false.
     */
    hasClassAnnotation(target, annotation) {
        const annotationMap = this.getClassAnnotations(target);
        return annotation.annotationName in annotationMap ? true : false;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#hasMethodAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Determines whether a given method name has given annotation name defined or not under a given typescript class
     * @param {any} target The typescript class object
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator} annotation The type of the method annotation
     * @returns {boolean} true if a given method name has given annotation name. Otherwise false.
     */
    hasMethodAnnotation(target, propertyName, annotation) {
        const annotationMap = this.getMethodAnnotations(target, propertyName);
        return annotation.annotationName in annotationMap ? true : false;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#setClassAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Registers a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory} under a given name.
     * <br/>Typically, in order for the ClassAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name the name of the factory.
     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    setClassAnnotationFactory(name, annotationFactory) {
        this.annotationFactoryMap[name] = annotationFactory;
        return annotationFactory;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getClassAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const GatewayProxied = annotationService.getClassAnnotationFactory('GatewayProxied');
     * </pre>
     *
     * @param {string} name The name of the factory
     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    getClassAnnotationFactory(name) {
        const instance = this;
        const classAnnotationFactory = function (...factoryArgument) {
            return function (originalConstructor) {
                const newConstructor = instance.functionsUtils.extendsConstructor(originalConstructor, function (...args) {
                    const annotationFactory = instance.annotationFactoryMap[name];
                    if (annotationFactory) {
                        // Note: Before we used to bind originalConstructor.bind(this). However, it had to be left up to the caller
                        // since that causes problems in IE; when a function is bound in IE, the browser wraps it in a function with
                        // native code, making it impossible to retrieve its name.
                        const result = annotationFactory(factoryArgument)(this, originalConstructor, args);
                        if (result) {
                            return result;
                        }
                    }
                    else {
                        throw new Error(`annotation '${name}' is used on '${originalConstructor.name}' but its ClassAnnotationFactory may not have been added to the dependency injection`);
                    }
                });
                /*
                 * enable Angular and AngularJS to inject this new constructor even though it has an empty signature
                 * by copying $inject property and DI related Angular metatdata
                 * For idempotency purposes we copy all properties anyways
                 */
                lodash.merge(newConstructor, originalConstructor);
                /*
                 * some properties set by Angular are not enumerable and yet contain
                 * such information as @Inject "metadata" necessary for DI
                 */
                newConstructor.__annotations__ = originalConstructor.__annotations__;
                newConstructor.__parameters__ = originalConstructor.__parameters__;
                newConstructor.__prop__metadata__ = originalConstructor.__prop__metadata__;
                /*
                 * copying such metadata as design:paramtypes necessary for DI
                 */
                Reflect.getMetadataKeys(originalConstructor).forEach((key) => {
                    Reflect.defineMetadata(key, Reflect.getMetadata(key, originalConstructor), newConstructor);
                });
                const rootOriginalConstructor = instance.getOriginalConstructor(originalConstructor);
                Reflect.defineMetadata(instance.ORIGINAL_CONSTRUCTOR_KEY, rootOriginalConstructor, newConstructor);
                Reflect.defineMetadata(annotationType.Class + ':' + name, factoryArgument, rootOriginalConstructor);
                // override original constructor
                return newConstructor;
            };
        };
        classAnnotationFactory.annotationName = name;
        return classAnnotationFactory;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#setMethodAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Registers a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory} under a given name.
     * <br/>Typically, in order for the MethodAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name The name of the factory.
     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}
     */
    setMethodAnnotationFactory(name, annotationFactory) {
        this.annotationFactoryMap[name] = annotationFactory;
        return annotationFactory;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getMethodAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves a method level {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const Cached = annotationService.getMethodAnnotationFactory('Cached');
     * </pre>
     *
     * @param {string} name the name of the factory.
     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}.
     */
    getMethodAnnotationFactory(name) {
        const instance = this;
        const methodAnnotationFactory = function (...factoryArgument) {
            /*
             * when decorating an abstract class, strangely enough target is an instance of the abstract class
             * we need pass "this" instead to the annotationFactory invocation
             */
            return (target, propertyName, descriptor) => {
                const originalMethod = descriptor.value;
                descriptor.value = function () {
                    const annotationFactory = instance
                        .annotationFactoryMap[name];
                    if (annotationFactory) {
                        return originalMethod
                            ? annotationFactory(factoryArgument)(this, propertyName, originalMethod.bind(this), arguments)
                            : undefined;
                    }
                    else {
                        throw new Error(`annotation '${name}' is used but its MethodAnnotationFactory may not have been added to the dependency injection`);
                    }
                };
                Reflect.defineMetadata(annotationType.Method + ':' + name, factoryArgument, target, propertyName);
            };
        };
        methodAnnotationFactory.annotationName = name;
        return methodAnnotationFactory;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getOriginalConstructor
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Given a class constructor, returns the original constructor of it prior to any class level
     * proxying by annotations declared through {@link @smartutils.services:AnnotationService AnnotationService}
     *
     * @param {Class} target the constructor
     */
    getOriginalConstructor(target) {
        return Reflect.getMetadata(this.ORIGINAL_CONSTRUCTOR_KEY, target) || target;
    }
    getClassAnnotationsLogic(target) {
        const originalConstructor = this.getOriginalConstructor(target);
        const annotationMap = {};
        Reflect.getMetadataKeys(originalConstructor)
            .filter((key) => key.toString().startsWith(annotationType.Class))
            .map((key) => {
            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, originalConstructor);
        });
        return annotationMap;
    }
    getMethodAnnotationsLogic(target, propertyName) {
        const annotationMap = {};
        Reflect.getMetadataKeys(target.prototype, propertyName)
            .filter((key) => key.toString().startsWith(annotationType.Method))
            .map((key) => {
            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, target.prototype, propertyName);
        });
        return annotationMap;
    }
}
export const annotationService = new AnnotationService();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsic2VydmljZXMvYW5ub3RhdGlvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUNILE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFpRTFDLGdCQUFnQjtBQUNoQixJQUFLLGNBR0o7QUFIRCxXQUFLLGNBQWM7SUFDZiwyQ0FBeUIsQ0FBQTtJQUN6Qiw2Q0FBMkIsQ0FBQTtBQUMvQixDQUFDLEVBSEksY0FBYyxLQUFkLGNBQWMsUUFHbEI7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLGlCQUFpQjtJQUE5QjtRQUNvQix3QkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztRQUMxQyw2QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQztRQUVqRTs7Ozs7Ozs7O1dBU0c7UUFDSCx3QkFBbUIsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBRXBFOzs7Ozs7Ozs7O1dBVUc7UUFDSCx5QkFBb0IsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxVQUNsRSxNQUFXLEVBQ1gsWUFBb0I7WUFFcEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxZQUFZLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUM7UUFFSyxtQkFBYyxHQUFtQixJQUFJLGNBQWMsRUFBRSxDQUFDO1FBRXRELHlCQUFvQixHQUFHLEVBRTlCLENBQUM7SUE0VU4sQ0FBQztJQTFVRzs7Ozs7Ozs7OztPQVVHO0lBQ0gsa0JBQWtCLENBQUMsTUFBVyxFQUFFLFVBQTBDO1FBQ3RFLE1BQU0sYUFBYSxHQUFrQixJQUFJLENBQUMsbUJBQW1CLENBQUMs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QkFBaUIsR0FBc0IsSUFBSSxpQkFBaUIsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEZ1bmN0aW9uc1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQ2xhc3MgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBUeXBlZE1hcCB9IGZyb20gJy4uL2R0b3MnO1xuaW1wb3J0IHt9IGZyb20gJ3JlZmxlY3QtbWV0YWRhdGEnO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTaG9ydGhhbmQgc2lnbmF0dXJlIG9mIGEge0BsaW5rIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBUeXBlc2NyaXB0IERlY29yYXRvcn0gZnVuY3Rpb24gZm9yIG1ldGhvZHNcbiAqIHVzZWQgYnkge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlIEFubm90YXRpb25TZXJ2aWNlfS5cbiAqIEBwYXJhbSB7YW55fSB0YXJnZXQgdGhlIGluc3RhbmNlIHRoZSBtZXRob2Qgb2Ygd2hpY2ggaXMgYW5ub3RhdGVkXG4gKiBAcGFyYW0ge2FueX0gcHJvcGVydHlOYW1lIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCBpcyBhbm5vdGF0ZWRcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5hbE1ldGhvZCB0aGUgb3JpZ2luYWwgbWV0aG9kIGJlaW5nIGFubm90YXRlZCwgaXQgaXMgcHJlYm91bmQgdG8gdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgZmluYWwgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcm94aWVkIG1ldGhvZC5cbiAqIEl0IGlzIGxlZnQgdG8gaW1wbGVtZW50ZXJzIHRvIGRpc2NhcmQsIG1vZGlmeSwgcmV1c2UgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqL1xuZXhwb3J0IHR5cGUgTWV0aG9kQW5ub3RhdGlvbiA9IChcbiAgICB0YXJnZXQ6IGFueSxcbiAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZyxcbiAgICBvcmlnaW5hbE1ldGhvZDogKC4uLng6IGFueVtdKSA9PiBhbnksXG4gICAgLi4uaW52b2NhdGlvbkFyZ3VtZW50czogYW55W11cbikgPT4gYW55O1xuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnlcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uIE1ldGhvZEFubm90YXRpb259IGZhY3RvcnlcbiAqIHVzZWQgYnkge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlIEFubm90YXRpb25TZXJ2aWNlfS5cbiAqIEBwYXJhbSB7Li4uYW55W119IGZhY3RvcnlBcmd1bWVudHMgdGhlIGZhY3RvcnkgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7TWV0aG9kQW5ub3RhdGlvbn0ge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uIE1ldGhvZEFubm90YXRpb259XG4gKi9cbmV4cG9ydCB0eXBlIE1ldGhvZEFubm90YXRpb25GYWN0b3J5ID0gKC4uLmZhY3RvcnlBcmd1bWVudHM6IGFueVtdKSA9PiBNZXRob2RBbm5vdGF0aW9uO1xuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTaG9ydGhhbmQgc2lnbmF0dXJlIG9mIGEge0BsaW5rIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBUeXBlc2NyaXB0IERlY29yYXRvcn0gZnVuY3Rpb24gZm9yIGNsYXNzZXNcbiAqIHVzZWQgYnkge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlIEFubm90YXRpb25TZXJ2aWNlfS5cbiAqIEBwYXJhbSB7YW55fSBpbnN0YW5jZSBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgd2hpY2ggaXMgYW5ub3RhdGVkXG4gKiBAcGFyYW0geyguLi54OiBhbnlbXSkgPT4gYW55fSBvcmlnaW5hbENvbnN0cnVjdG9yIHRoZSBwcmVib3VuZCBvcmlnaW5hbCBjb25zdHJ1Y3RvciBvZiB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Li4uYW55W119IGludm9jYXRpb25Bcmd1bWVudHMgdGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7YW55fSB2b2lkIG9yIGEgbmV3IGluc3RhbmNlLlxuICogSXQgaXMgbGVmdCB0byBpbXBsZW1lbnRlcnMgdG8gZGlzY2FyZCwgbW9kaWZ5LCBvciByZXVzZSB0aGUgb3JpZ2luYWwgY29uc3RydWN0b3IgdGhlbiBub3QgdG8gcmV0dXJuIG9yIHJldHVybiBhIG5ldyBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2xhc3NBbm5vdGF0aW9uID0gKFxuICAgIGluc3RhbmNlOiBhbnksXG4gICAgb3JpZ2luYWxDb25zdHJ1Y3RvcjogKC4uLng6IGFueVtdKSA9PiBhbnksXG4gICAgLi4uaW52b2NhdGlvbkFyZ3VtZW50czogYW55W11cbikgPT4gYW55O1xuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNsYXNzQW5ub3RhdGlvbiBDbGFzc0Fubm90YXRpb259IGZhY3RvcnlcbiAqIHVzZWQgYnkge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlIEFubm90YXRpb25TZXJ2aWNlfS5cbiAqIEBwYXJhbSB7Li4uYW55W119IGZhY3RvcnlBcmd1bWVudHMgdGhlIGZhY3RvcnkgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7Q2xhc3NBbm5vdGF0aW9ufSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNsYXNzQW5ub3RhdGlvbiBDbGFzc0Fubm90YXRpb259XG4gKi9cbmV4cG9ydCB0eXBlIENsYXNzQW5ub3RhdGlvbkZhY3RvcnkgPSAoLi4ueDogYW55W10pID0+IENsYXNzQW5ub3RhdGlvbjtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZW51bSBhbm5vdGF0aW9uVHlwZSB7XG4gICAgQ2xhc3MgPSAnQ2xhc3NBbm5vdGF0aW9uJyxcbiAgICBNZXRob2QgPSAnTWV0aG9kQW5ub3RhdGlvbidcbn1cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFV0aWxpdHkgc2VydmljZSB0byBkZWNsYXJlIGFuZCBjb25zdW1lIG1ldGhvZCBsZXZlbCBhbmQgY2xhc3MgbGV2ZWwge0BsaW5rIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBUeXBlc2NyaXB0IGRlY29yYXRvciBmYWN0b3JpZXN9LlxuICogPGJyLz5TaW5jZSBEZWNvcmF0b3IgaXMgYSByZXNlcnZlZCB3b3JkIGluIFNtYXJ0ZWRpdCwgVHlwZXNjcmlwdCBEZWNvcmF0b3JzIGFyZSBjYWxsZWQgYXMgQW5ub3RhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm5vdGF0aW9uU2VydmljZSB7XG4gICAgcHVibGljIHJlYWRvbmx5IElOSkVDVEFCTEVfTkFNRV9LRVkgPSAnZ2V0SW5qZWN0YWJsZU5hbWUnO1xuICAgIHB1YmxpYyByZWFkb25seSBPUklHSU5BTF9DT05TVFJVQ1RPUl9LRVkgPSAnb3JpZ2luYWxDb25zdHJ1Y3Rvcic7XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0Q2xhc3NBbm5vdGF0aW9uc1xuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0cmlldmVzIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgc3RyaW5nLWluZGV4ZWQgYW5ub3RhdGlvbnMgZGVmaW5lZCBvbiB0aGUgZ2l2ZW4gY2xhc3MgdGFyZ2V0XG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBUaGUgdHlwZXNjcmlwdCBjbGFzcyBvbiB3aGljaCBjbGFzcyBhbm5vdGF0aW9ucyBhcmUgZGVmaW5lZFxuICAgICAqIEByZXR1cm5zIHtbaW5kZXg6IHN0cmluZ106IGFueX0gYW4gb2JqZWN0IGNvbnRhaW5zIHN0cmluZy1pbmRleGVkIGFubm90YXRpb24gbmFtZSBhbmQgcGF5bG9hZFxuICAgICAqL1xuICAgIGdldENsYXNzQW5ub3RhdGlvbnMgPSBsb2Rhc2gubWVtb2l6ZSh0aGlzLmdldENsYXNzQW5ub3RhdGlvbnNMb2dpYyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0TWV0aG9kQW5ub3RhdGlvbnNcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHJpZXZlcyBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHN0cmluZyBpbmRleGVkIGFubm90YXRpb25zIGRlZmluZWQgb24gdGhlIGdpdmVuIGNsYXNzIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7YW55fSB0YXJnZXQgVGhlIHR5cGVzY3JpcHQgY2xhc3MgdG8gdGhlIGluc3BlY3RlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvbiB3aGljaCBhbm5vdGF0aW9ucyBhcmUgZGVmaW5lZFxuICAgICAqIEByZXR1cm5zIHtbaW5kZXg6IHN0cmluZ106IGFueX0gYW4gb2JqZWN0IGNvbnRhaW5zIHN0cmluZy1pbmRleGVkIGFubm90YXRpb24gbmFtZSBhbmQgcGF5bG9hZFxuICAgICAqL1xuICAgIGdldE1ldGhvZEFubm90YXRpb25zID0gbG9kYXNoLm1lbW9pemUodGhpcy5nZXRNZXRob2RBbm5vdGF0aW9uc0xvZ2ljLCBmdW5jdGlvbihcbiAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0YXJnZXQucHJvdG90eXBlKSArIHByb3BlcnR5TmFtZTtcbiAgICB9KTtcblxuICAgIHByaXZhdGUgZnVuY3Rpb25zVXRpbHM6IEZ1bmN0aW9uc1V0aWxzID0gbmV3IEZ1bmN0aW9uc1V0aWxzKCk7XG5cbiAgICBwcml2YXRlIGFubm90YXRpb25GYWN0b3J5TWFwID0ge30gYXMgVHlwZWRNYXA8XG4gICAgICAgIE1ldGhvZEFubm90YXRpb25GYWN0b3J5IHwgQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeSB8IG51bGxcbiAgICA+O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlI2dldENsYXNzQW5ub3RhdGlvblxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0cmlldmVzIGFyZ3VtZW50cyBvZiBjbGFzcyBhbm5vdGF0aW9uIHVuZGVyIGEgZ2l2ZW4gYW5ub3RhdGlvbiBuYW1lXG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBUaGUgdHlwZXNjcmlwdCBjbGFzcyBvbiB3aGljaCBjbGFzcyBhbm5vdGF0aW9uIGlzIGRlZmluZWRcbiAgICAgKiBAcGFyYW0geyhhcmdzPzogYW55KSA9PiBDbGFzc0RlY29yYXRvcn0gYW5ub3RhdGlvbiBUaGUgdHlwZSBvZiB0aGUgY2xhc3MgYW5ub3RhdGlvblxuICAgICAqIEByZXR1cm5zIHthbnl9IHRoZSBwYXlsb2FkIHBhc3NlZCB0byB0aGUgYW5ub3RhdGlvblxuICAgICAqL1xuICAgIGdldENsYXNzQW5ub3RhdGlvbih0YXJnZXQ6IGFueSwgYW5ub3RhdGlvbjogKGFyZ3M/OiBhbnkpID0+IENsYXNzRGVjb3JhdG9yKTogYW55IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbk1hcDogVHlwZWRNYXA8YW55PiA9IHRoaXMuZ2V0Q2xhc3NBbm5vdGF0aW9ucyh0YXJnZXQpO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTmFtZTogc3RyaW5nID0gKGFubm90YXRpb24gYXMgYW55KS5hbm5vdGF0aW9uTmFtZTtcbiAgICAgICAgaWYgKGFubm90YXRpb25NYXApIHtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uTmFtZSBpbiBhbm5vdGF0aW9uTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25NYXBbYW5ub3RhdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0TWV0aG9kQW5ub3RhdGlvblxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0cmlldmVzIGFyZ3VtZW50cyBvZiBtZXRob2QgYW5ub3RhdGlvbiBmb3IgYSBnaXZlbiB0eXBlc2NyaXB0IGNsYXNzXG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBUaGUgdHlwZXNjcmlwdCBjbGFzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvbiB3aGljaCBhbm5vdGF0aW9uIGlzIGRlZmluZWRcbiAgICAgKiBAcGFyYW0geyhhcmdzPzogYW55KSA9PiBNZXRob2REZWNvcmF0b3IpfSBhbm5vdGF0aW9uIFRoZSB0eXBlIG9mIHRoZSBtZXRob2QgYW5ub3RhdGlvblxuICAgICAqIEByZXR1cm5zIHthbnl9IHRoZSBwYXlsb2FkIHBhc3NlZCB0byB0aGUgYW5ub3RhdGlvblxuICAgICAqL1xuICAgIGdldE1ldGhvZEFubm90YXRpb24oXG4gICAgICAgIHRhcmdldDogYW55LFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZyxcbiAgICAgICAgYW5ub3RhdGlvbjogKGFyZ3M/OiBhbnkpID0+IE1ldGhvZERlY29yYXRvclxuICAgICk6IGFueSB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25NYXA6IFR5cGVkTWFwPGFueT4gPSB0aGlzLmdldE1ldGhvZEFubm90YXRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbk5hbWU6IHN0cmluZyA9IChhbm5vdGF0aW9uIGFzIGFueSkuYW5ub3RhdGlvbk5hbWU7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uTWFwKSB7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbk5hbWUgaW4gYW5ub3RhdGlvbk1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uTWFwW2Fubm90YXRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlI2hhc0NsYXNzQW5ub3RhdGlvblxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gY2xhc3MgdGFyZ2V0IGhhcyBnaXZlbiBhbm5vdGF0aW9uIG5hbWUgZGVmaW5lZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0eXBlc2NyaXB0IGNsYXNzIG9uIHdoaWNoIGNsYXNzIGFubm90YXRpb24gaXMgZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7KGFyZ3M/OiBhbnkpID0+IENsYXNzRGVjb3JhdG9yfSBhbm5vdGF0aW9uIFRoZSB0eXBlIG9mIHRoZSBjbGFzcyBhbm5vdGF0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBnaXZlbiB0YXJnZXQgaGFzIGdpdmVuIGFubm90YXRpb24gbmFtZS4gT3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGhhc0NsYXNzQW5ub3RhdGlvbih0YXJnZXQ6IGFueSwgYW5ub3RhdGlvbjogKGFyZ3M/OiBhbnkpID0+IENsYXNzRGVjb3JhdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25NYXA6IFR5cGVkTWFwPGFueT4gPSB0aGlzLmdldENsYXNzQW5ub3RhdGlvbnModGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIChhbm5vdGF0aW9uIGFzIGFueSkuYW5ub3RhdGlvbk5hbWUgaW4gYW5ub3RhdGlvbk1hcCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjaGFzTWV0aG9kQW5ub3RhdGlvblxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gbWV0aG9kIG5hbWUgaGFzIGdpdmVuIGFubm90YXRpb24gbmFtZSBkZWZpbmVkIG9yIG5vdCB1bmRlciBhIGdpdmVuIHR5cGVzY3JpcHQgY2xhc3NcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0eXBlc2NyaXB0IGNsYXNzIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvbiB3aGljaCBhbm5vdGF0aW9uIGlzIGRlZmluZWRcbiAgICAgKiBAcGFyYW0geyhhcmdzPzogYW55KSA9PiBNZXRob2REZWNvcmF0b3J9IGFubm90YXRpb24gVGhlIHR5cGUgb2YgdGhlIG1ldGhvZCBhbm5vdGF0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBnaXZlbiBtZXRob2QgbmFtZSBoYXMgZ2l2ZW4gYW5ub3RhdGlvbiBuYW1lLiBPdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgaGFzTWV0aG9kQW5ub3RhdGlvbihcbiAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgICAgICBhbm5vdGF0aW9uOiAoYXJncz86IGFueSkgPT4gTWV0aG9kRGVjb3JhdG9yXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25NYXA6IFR5cGVkTWFwPGFueT4gPSB0aGlzLmdldE1ldGhvZEFubm90YXRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgcmV0dXJuIChhbm5vdGF0aW9uIGFzIGFueSkuYW5ub3RhdGlvbk5hbWUgaW4gYW5ub3RhdGlvbk1hcCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2Ujc2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVnaXN0ZXJzIGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25GYWN0b3J5IENsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9IHVuZGVyIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKiA8YnIvPlR5cGljYWxseSwgaW4gb3JkZXIgZm9yIHRoZSBDbGFzc0Fubm90YXRpb25GYWN0b3J5IHRvIGJlbmVmaXQgZnJvbSBBbmd1bGFyIGRlcGVuZGVuY3kgaW5qZWN0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aXRoaW4gYW4gQW5ndWxhciBmYWN0b3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmYWN0b3J5LlxuICAgICAqIEByZXR1cm5zIHtDbGFzc0Fubm90YXRpb25GYWN0b3J5fSBhIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeSBDbGFzc0Fubm90YXRpb25GYWN0b3J5fVxuICAgICAqL1xuICAgIHNldENsYXNzQW5ub3RhdGlvbkZhY3RvcnkoXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgYW5ub3RhdGlvbkZhY3Rvcnk6IENsYXNzQW5ub3RhdGlvbkZhY3RvcnkgfCBudWxsXG4gICAgKTogQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeSB8IG51bGwge1xuICAgICAgICB0aGlzLmFubm90YXRpb25GYWN0b3J5TWFwW25hbWVdID0gYW5ub3RhdGlvbkZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0cmlldmVzIGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25GYWN0b3J5IENsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9XG4gICAgICogcHJldmlvdXNseSByZWdpc3RlcmVkIHVuZGVyIHRoZSBnaXZlbiBuYW1lOlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiAgIGV4cG9ydCBjb25zdCBHYXRld2F5UHJveGllZCA9IGFubm90YXRpb25TZXJ2aWNlLmdldENsYXNzQW5ub3RhdGlvbkZhY3RvcnkoJ0dhdGV3YXlQcm94aWVkJyk7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmFjdG9yeVxuICAgICAqIEByZXR1cm5zIHtDbGFzc0Fubm90YXRpb25GYWN0b3J5fSBhIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeSBDbGFzc0Fubm90YXRpb25GYWN0b3J5fVxuICAgICAqL1xuXG4gICAgZ2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeShuYW1lOiBzdHJpbmcpOiAoLi4uYXJnczogYW55W10pID0+IENsYXNzRGVjb3JhdG9yIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzQW5ub3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbiguLi5mYWN0b3J5QXJndW1lbnQ6IGFueVtdKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob3JpZ2luYWxDb25zdHJ1Y3RvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29uc3RydWN0b3IgPSBpbnN0YW5jZS5mdW5jdGlvbnNVdGlscy5leHRlbmRzQ29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uRmFjdG9yeSA9IGluc3RhbmNlLmFubm90YXRpb25GYWN0b3J5TWFwW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gYXMgQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEJlZm9yZSB3ZSB1c2VkIHRvIGJpbmQgb3JpZ2luYWxDb25zdHJ1Y3Rvci5iaW5kKHRoaXMpLiBIb3dldmVyLCBpdCBoYWQgdG8gYmUgbGVmdCB1cCB0byB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhhdCBjYXVzZXMgcHJvYmxlbXMgaW4gSUU7IHdoZW4gYSBmdW5jdGlvbiBpcyBib3VuZCBpbiBJRSwgdGhlIGJyb3dzZXIgd3JhcHMgaXQgaW4gYSBmdW5jdGlvbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGNvZGUsIG1ha2luZyBpdCBpbXBvc3NpYmxlIHRvIHJldHJpZXZlIGl0cyBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFubm90YXRpb25GYWN0b3J5KGZhY3RvcnlBcmd1bWVudCkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFubm90YXRpb24gJyR7bmFtZX0nIGlzIHVzZWQgb24gJyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgYnV0IGl0cyBDbGFzc0Fubm90YXRpb25GYWN0b3J5IG1heSBub3QgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBkZXBlbmRlbmN5IGluamVjdGlvbmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZW5hYmxlIEFuZ3VsYXIgYW5kIEFuZ3VsYXJKUyB0byBpbmplY3QgdGhpcyBuZXcgY29uc3RydWN0b3IgZXZlbiB0aG91Z2ggaXQgaGFzIGFuIGVtcHR5IHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAqIGJ5IGNvcHlpbmcgJGluamVjdCBwcm9wZXJ0eSBhbmQgREkgcmVsYXRlZCBBbmd1bGFyIG1ldGF0ZGF0YVxuICAgICAgICAgICAgICAgICAqIEZvciBpZGVtcG90ZW5jeSBwdXJwb3NlcyB3ZSBjb3B5IGFsbCBwcm9wZXJ0aWVzIGFueXdheXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsb2Rhc2gubWVyZ2UobmV3Q29uc3RydWN0b3IsIG9yaWdpbmFsQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc29tZSBwcm9wZXJ0aWVzIHNldCBieSBBbmd1bGFyIGFyZSBub3QgZW51bWVyYWJsZSBhbmQgeWV0IGNvbnRhaW5cbiAgICAgICAgICAgICAgICAgKiBzdWNoIGluZm9ybWF0aW9uIGFzIEBJbmplY3QgXCJtZXRhZGF0YVwiIG5lY2Vzc2FyeSBmb3IgRElcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBuZXdDb25zdHJ1Y3Rvci5fX2Fubm90YXRpb25zX18gPSBvcmlnaW5hbENvbnN0cnVjdG9yLl9fYW5ub3RhdGlvbnNfXztcbiAgICAgICAgICAgICAgICBuZXdDb25zdHJ1Y3Rvci5fX3BhcmFtZXRlcnNfXyA9IG9yaWdpbmFsQ29uc3RydWN0b3IuX19wYXJhbWV0ZXJzX187XG4gICAgICAgICAgICAgICAgbmV3Q29uc3RydWN0b3IuX19wcm9wX19tZXRhZGF0YV9fID0gb3JpZ2luYWxDb25zdHJ1Y3Rvci5fX3Byb3BfX21ldGFkYXRhX187XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGNvcHlpbmcgc3VjaCBtZXRhZGF0YSBhcyBkZXNpZ246cGFyYW10eXBlcyBuZWNlc3NhcnkgZm9yIERJXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMob3JpZ2luYWxDb25zdHJ1Y3RvcikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmdldE1ldGFkYXRhKGtleSwgb3JpZ2luYWxDb25zdHJ1Y3RvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdE9yaWdpbmFsQ29uc3RydWN0b3IgPSBpbnN0YW5jZS5nZXRPcmlnaW5hbENvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLk9SSUdJTkFMX0NPTlNUUlVDVE9SX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdE9yaWdpbmFsQ29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25UeXBlLkNsYXNzICsgJzonICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICByb290T3JpZ2luYWxDb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBvcmlnaW5hbCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIChjbGFzc0Fubm90YXRpb25GYWN0b3J5IGFzIGFueSkuYW5ub3RhdGlvbk5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gY2xhc3NBbm5vdGF0aW9uRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2Ujc2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnlcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlZ2lzdGVycyBhIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgTWV0aG9kQW5ub3RhdGlvbkZhY3Rvcnl9IHVuZGVyIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKiA8YnIvPlR5cGljYWxseSwgaW4gb3JkZXIgZm9yIHRoZSBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSB0byBiZW5lZml0IGZyb20gQW5ndWxhciBkZXBlbmRlbmN5IGluamVjdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2l0aGluIGFuIEFuZ3VsYXIgZmFjdG9yeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmFjdG9yeS5cbiAgICAgKiBAcmV0dXJucyB7TWV0aG9kQW5ub3RhdGlvbkZhY3Rvcnl9IGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeX1cbiAgICAgKi9cbiAgICBzZXRNZXRob2RBbm5vdGF0aW9uRmFjdG9yeShcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBhbm5vdGF0aW9uRmFjdG9yeTogTWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgfCBudWxsXG4gICAgKTogTWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgfCBudWxsIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRmFjdG9yeU1hcFtuYW1lXSA9IGFubm90YXRpb25GYWN0b3J5O1xuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbkZhY3Rvcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlI2dldE1ldGhvZEFubm90YXRpb25GYWN0b3J5XG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgYSBtZXRob2QgbGV2ZWwge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeX1cbiAgICAgKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWU6XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqICAgZXhwb3J0IGNvbnN0IENhY2hlZCA9IGFubm90YXRpb25TZXJ2aWNlLmdldE1ldGhvZEFubm90YXRpb25GYWN0b3J5KCdDYWNoZWQnKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmYWN0b3J5LlxuICAgICAqIEByZXR1cm5zIHtNZXRob2RBbm5vdGF0aW9uRmFjdG9yeX0gYSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb25GYWN0b3J5IE1ldGhvZEFubm90YXRpb25GYWN0b3J5fS5cbiAgICAgKi9cbiAgICBnZXRNZXRob2RBbm5vdGF0aW9uRmFjdG9yeShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG1ldGhvZEFubm90YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oLi4uZmFjdG9yeUFyZ3VtZW50OiBhbnlbXSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gZGVjb3JhdGluZyBhbiBhYnN0cmFjdCBjbGFzcywgc3RyYW5nZWx5IGVub3VnaCB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGFic3RyYWN0IGNsYXNzXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHBhc3MgXCJ0aGlzXCIgaW5zdGVhZCB0byB0aGUgYW5ub3RhdGlvbkZhY3RvcnkgaW52b2NhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRhcmdldDogYW55LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPCguLi54OiBhbnlbXSkgPT4gYW55PlxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uRmFjdG9yeTogTWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgPSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFubm90YXRpb25GYWN0b3J5TWFwW25hbWVdIGFzIE1ldGhvZEFubm90YXRpb25GYWN0b3J5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhbm5vdGF0aW9uRmFjdG9yeShmYWN0b3J5QXJndW1lbnQpKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFubm90YXRpb24gJyR7bmFtZX0nIGlzIHVzZWQgYnV0IGl0cyBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSBtYXkgbm90IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgZGVwZW5kZW5jeSBpbmplY3Rpb25gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25UeXBlLk1ldGhvZCArICc6JyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnlBcmd1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgKG1ldGhvZEFubm90YXRpb25GYWN0b3J5IGFzIGFueSkuYW5ub3RhdGlvbk5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gbWV0aG9kQW5ub3RhdGlvbkZhY3Rvcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlI2dldE9yaWdpbmFsQ29uc3RydWN0b3JcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdpdmVuIGEgY2xhc3MgY29uc3RydWN0b3IsIHJldHVybnMgdGhlIG9yaWdpbmFsIGNvbnN0cnVjdG9yIG9mIGl0IHByaW9yIHRvIGFueSBjbGFzcyBsZXZlbFxuICAgICAqIHByb3h5aW5nIGJ5IGFubm90YXRpb25zIGRlY2xhcmVkIHRocm91Z2gge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlIEFubm90YXRpb25TZXJ2aWNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDbGFzc30gdGFyZ2V0IHRoZSBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPcmlnaW5hbENvbnN0cnVjdG9yKHRhcmdldDogYW55KTogQ2xhc3Mge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRNZXRhZGF0YSh0aGlzLk9SSUdJTkFMX0NPTlNUUlVDVE9SX0tFWSwgdGFyZ2V0KSB8fCB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDbGFzc0Fubm90YXRpb25zTG9naWModGFyZ2V0OiBhbnkpOiBUeXBlZE1hcDxhbnk+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0T3JpZ2luYWxDb25zdHJ1Y3Rvcih0YXJnZXQpO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTWFwOiBUeXBlZE1hcDxhbnk+ID0ge307XG5cbiAgICAgICAgUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMob3JpZ2luYWxDb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleTogc3RyaW5nKSA9PiBrZXkudG9TdHJpbmcoKS5zdGFydHNXaXRoKGFubm90YXRpb25UeXBlLkNsYXNzKSlcbiAgICAgICAgICAgIC5tYXAoKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbk1hcFtrZXkuc3BsaXQoJzonKVsxXV0gPSBSZWZsZWN0LmdldE1ldGFkYXRhKGtleSwgb3JpZ2luYWxDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25NYXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNZXRob2RBbm5vdGF0aW9uc0xvZ2ljKHRhcmdldDogYW55LCBwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IFR5cGVkTWFwPGFueT4ge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTWFwOiBUeXBlZE1hcDxhbnk+ID0ge307XG5cbiAgICAgICAgUmVmbGVjdC5nZXRNZXRhZGF0YUtleXModGFyZ2V0LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5OiBzdHJpbmcpID0+IGtleS50b1N0cmluZygpLnN0YXJ0c1dpdGgoYW5ub3RhdGlvblR5cGUuTWV0aG9kKSlcbiAgICAgICAgICAgIC5tYXAoKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbk1hcFtrZXkuc3BsaXQoJzonKVsxXV0gPSBSZWZsZWN0LmdldE1ldGFkYXRhKFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbk1hcDtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBhbm5vdGF0aW9uU2VydmljZTogQW5ub3RhdGlvblNlcnZpY2UgPSBuZXcgQW5ub3RhdGlvblNlcnZpY2UoKTtcbiJdfQ==