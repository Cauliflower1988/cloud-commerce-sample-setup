/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as lodash from 'lodash';
import { stringUtils } from './string-utils';
/* tslint:disable:max-classes-per-file */
/**
 * @ngdoc service
 * @name @smartutils.services:UrlUtils#URIBuilder
 *
 * @description
 * builder or URIs, build() method must be invoked to actually retrieve a URI
 *
 * @param {Object} modalStack, the $modalStack service of angular-ui.
 */
export class URIBuilder {
    constructor(uri) {
        this.uri = uri;
        this.wholeWordMatch = '[\\w]+';
    }
    build() {
        return this.uri;
    }
    /**
     * @ngdoc method
     * @name  @smartutils.services:UrlUtils#URIBuilder#replaceParams
     * @methodOf  @smartutils.services:UrlUtils#URIBuilder
     *
     * @description
     * Substitute all ":" prefixed placeholders in the full url with the matching values in the given params
     * Substitute Non ":" prefixed placeholders containg "_"
     *
     * @param {Object} params a map of placeholder names / values
     */
    replaceParams(params) {
        const clone = lodash.cloneDeep(this);
        if (params) {
            // order the keys by descending length
            clone.uri = Object.keys(params)
                .sort(function (a, b) {
                return b.length - a.length;
            })
                .reduce((tempURL, key) => {
                return this.substituteKeyForValue(tempURL, key, params[key]);
            }, clone.uri);
        }
        return clone;
    }
    /**
     * @ngdoc method
     * @name  @smartutils.services:UrlUtils#URIBuilder#sanitize
     * @methodOf  @smartutils.services:UrlUtils#URIBuilder
     *
     * @description
     * removes unresolved ":" prefixed placeholders from absolute path
     */
    sanitize() {
        const clone = lodash.cloneDeep(this);
        const uriDomainAndPath = /(https?:\/\/[^\/]*)(\/.*)/.exec(clone.uri);
        clone.uri = uriDomainAndPath == null ? clone.uri : uriDomainAndPath[2];
        clone.uri = this.substituteKeyForValue(clone.uri, this.wholeWordMatch, '')
            .replace(/\/\//, '/') // to replace double slash (api/:identifier/data?param=true) if :identifier is removed
            .replace(/\/\?/, '?') // to replace slash question mark (api/:identifier?param=true) if :identifier is removed
            .replace(/\/$/, ''); // to remove trailing slash
        clone.uri = uriDomainAndPath == null ? clone.uri : uriDomainAndPath[1] + clone.uri;
        return clone;
    }
    substituteKeyForValue(url, key, value) {
        url = url
            .replace(new RegExp(':' + key + '/'), `${value || ''}/`)
            .replace(new RegExp(':' + key + '$'), `${value || ''}`)
            .replace(new RegExp(':' + key + '\\?'), `${value || ''}?`)
            .replace(new RegExp(':' + key + '&'), `${value || ''}&`);
        /*
         * to cater for special case of smartedit
         * where some non ":" prefixed placeholders must be resolved too
         * we limit it though to keys containing "_" (case for smartedit)
         * since it would otherwise breaks most APIs patterns
         */
        if (key !== this.wholeWordMatch && key.includes('_')) {
            const _uri = url.includes('?') ? url.substr(0, url.indexOf('?')) : url;
            const uri = _uri.replace(new RegExp('\\b' + key + '\\b'), `${value || ''}`);
            url = url.includes('?') ? uri + url.substr(url.indexOf('?')) : uri;
        }
        return url;
    }
}
/**
 * @ngdoc service
 * @name @smartutils.services:UrlUtils
 *
 * @description
 * A collection of utility methods for manipulating URLs
 */
export class UrlUtils {
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#getOrigin
     * @methodOf @smartutils.services:UrlUtils
     * @description
     * returns document location origin
     * Some browsers still do not support W3C document.location.origin, this function caters for gap.
     * @param {String =} url optional any url
     */
    getOrigin(url) {
        if (url) {
            let link = document.createElement('a');
            link.setAttribute('href', url);
            const origin = link.protocol + '//' + link.hostname + (link.port ? ':' + link.port : '');
            // @ts-ignore
            link = null; // GC
            return origin;
        }
        else {
            return (window.location.protocol +
                '//' +
                window.location.hostname +
                (window.location.port ? ':' + window.location.port : ''));
        }
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#getURI
     * @methodOf @smartutils.services:UrlUtils
     *
     * @description
     * Will return the URI part of a URL
     * @param {String} url the URL the URI of which is to be returned
     */
    getURI(url) {
        return url && url.indexOf('?') > -1 ? url.split('?')[0] : url;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#updateUrlParameter
     * @methodOf @smartutils.services:UrlUtils
     *
     * @description
     * Updates a URL to contain the query param and value provided. If already exists then it is updated,
     * if it did not previously exist, then it will be added.
     *
     * @param {String} url The url to be updated (this param will not be modified)
     * @param {String} key The query param key
     * @param {String} value The query param value
     *
     * @returns {String} The url with updated key/value
     */
    updateUrlParameter(url, key, value) {
        const i = url.indexOf('#');
        const hash = i === -1 ? '' : url.substr(i);
        url = i === -1 ? url : url.substr(0, i);
        const regex = new RegExp('([?&])' + key + '=.*?(&|$)', 'i');
        const separator = url.indexOf('?') !== -1 ? '&' : '?';
        if (url.match(regex)) {
            url = url.replace(regex, '$1' + key + '=' + value + '$2');
        }
        else {
            url = url + separator + key + '=' + value;
        }
        return url + hash;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#getQueryString
     * @methodOf @smartutils.services:UrlUtils
     *
     * @description
     * <b>getQueryString</b> will convert a given object into a query string.
     *
     * Below is the code snippet for sample input and sample output:
     *
     * <pre>
     * var params = {
     *  key1 : 'value1',
     *  key2 : 'value2',
     *  key3 : 'value3'
     *  }
     *
     *  var output = getQueryString(params);
     *
     *  // The output is '?&key1=value1&key2=value2&key3=value3'
     *
     * </pre>
     * @param {Object} params Object containing a list of params.
     *
     * @returns {String} a query string
     */
    getQueryString(params) {
        let queryString = '';
        if (params) {
            for (const param in params) {
                if (params.hasOwnProperty(param)) {
                    (lodash.isArray(params[param]) ? params[param] : [params[param]]).forEach((value) => {
                        queryString +=
                            '&' + encodeURIComponent(param) + '=' + encodeURIComponent(value);
                    });
                }
            }
        }
        return '?' + (!stringUtils.isBlank(queryString) ? queryString.substring(1) : queryString);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#parseQuery
     * @methodOf @smartutils.services:UrlUtils
     *
     * @description
     * <b>parseQuery</b> will convert a given query string to an object.
     *
     * Below is the code snippet for sample input and sample output:
     *
     * <pre>
     * var query = '?key1=value1&key2=value2&key3=value3';
     *
     * var output = parseQuery(query);
     *
     * // The output is { key1 : 'value1', key2 : 'value2', key3 : 'value3' }
     *
     * </pre>
     * @param {String} query String that needs to be parsed.
     *
     * @returns {Object} an object containing all params of the given query
     */
    parseQuery(str) {
        const objURL = {};
        str.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'), function ($0, $1, $2, $3) {
            objURL[$1] = $3;
        });
        return objURL;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:UrlUtils#getAbsoluteURL
     * @methodOf @smartutils.services:UrlUtils
     *
     * @description
     * Makes url absolute (with provided domain) if not yet
     *
     * @param {String} domain the domain with witch to prepend the url if it is not absolute
     * @param {String} url the url to test
     *
     * @returns {String} url
     */
    getAbsoluteURL(domain, url) {
        // url regex
        // scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
        const re = new RegExp('([a-zA-Z0-9]+://)' + // scheme
            '([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?' + // user:password
            '([a-zA-Z0-9.-]+)' + // hostname
            '|([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)' + // or ip
            '(:[0-9]+)?' + // port
            '(/.*)?' // everything else
        );
        return re.exec(url) ? url : domain + url;
    }
}
export const urlUtils = new UrlUtils();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsidXRpbHMvdXJsLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUNILE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUc3Qyx5Q0FBeUM7QUFFekM7Ozs7Ozs7O0dBUUc7QUFFSCxNQUFNLE9BQU8sVUFBVTtJQUduQixZQUFvQixHQUFXO1FBQVgsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUZkLG1CQUFjLEdBQUcsUUFBUSxDQUFDO0lBRVQsQ0FBQztJQUVuQyxLQUFLO1FBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsYUFBYSxDQUFDLE1BQXdCO1FBQ2xDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsSUFBSSxNQUFNLEVBQUU7WUFDUixzQ0FBc0M7WUFDdEMsS0FBSyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztpQkFDMUIsSUFBSSxDQUFDLFVBQVMsQ0FBQyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDL0IsQ0FBQyxDQUFDO2lCQUNELE1BQU0sQ0FBQyxDQUFDLE9BQWUsRUFBRSxHQUFXLEVBQUUsRUFBRTtnQkFDckMsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqRSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7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O1lBQ2xCLFFBQVEsQ0FBQyxrQkFBa0I7U0FDbEMsQ0FBQztRQUVGLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQzdDLENBQUM7Q0FDSjtBQUVELE1BQU0sQ0FBQyxNQUFNLFFBQVEsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHN0cmluZ1V0aWxzIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgVHlwZWRNYXAgfSBmcm9tICcuLi9kdG9zJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHMjVVJJQnVpbGRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogYnVpbGRlciBvciBVUklzLCBidWlsZCgpIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgdG8gYWN0dWFsbHkgcmV0cmlldmUgYSBVUklcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kYWxTdGFjaywgdGhlICRtb2RhbFN0YWNrIHNlcnZpY2Ugb2YgYW5ndWxhci11aS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgVVJJQnVpbGRlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSB3aG9sZVdvcmRNYXRjaCA9ICdbXFxcXHddKyc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHVyaTogc3RyaW5nKSB7fVxuXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVyaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgIEBzbWFydHV0aWxzLnNlcnZpY2VzOlVybFV0aWxzI1VSSUJ1aWxkZXIjcmVwbGFjZVBhcmFtc1xuICAgICAqIEBtZXRob2RPZiAgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHMjVVJJQnVpbGRlclxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU3Vic3RpdHV0ZSBhbGwgXCI6XCIgcHJlZml4ZWQgcGxhY2Vob2xkZXJzIGluIHRoZSBmdWxsIHVybCB3aXRoIHRoZSBtYXRjaGluZyB2YWx1ZXMgaW4gdGhlIGdpdmVuIHBhcmFtc1xuICAgICAqIFN1YnN0aXR1dGUgTm9uIFwiOlwiIHByZWZpeGVkIHBsYWNlaG9sZGVycyBjb250YWluZyBcIl9cIlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBhIG1hcCBvZiBwbGFjZWhvbGRlciBuYW1lcyAvIHZhbHVlc1xuICAgICAqL1xuICAgIHJlcGxhY2VQYXJhbXMocGFyYW1zOiBUeXBlZE1hcDxzdHJpbmc+KTogVVJJQnVpbGRlciB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbG9kYXNoLmNsb25lRGVlcCh0aGlzKTtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgLy8gb3JkZXIgdGhlIGtleXMgYnkgZGVzY2VuZGluZyBsZW5ndGhcbiAgICAgICAgICAgIGNsb25lLnVyaSA9IE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgodGVtcFVSTDogc3RyaW5nLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzdGl0dXRlS2V5Rm9yVmFsdWUodGVtcFVSTCwga2V5LCBwYXJhbXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfSwgY2xvbmUudXJpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlscyNVUklCdWlsZGVyI3Nhbml0aXplXG4gICAgICogQG1ldGhvZE9mICBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlscyNVUklCdWlsZGVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiByZW1vdmVzIHVucmVzb2x2ZWQgXCI6XCIgcHJlZml4ZWQgcGxhY2Vob2xkZXJzIGZyb20gYWJzb2x1dGUgcGF0aFxuICAgICAqL1xuICAgIHNhbml0aXplKCk6IFVSSUJ1aWxkZXIge1xuICAgICAgICBjb25zdCBjbG9uZSA9IGxvZGFzaC5jbG9uZURlZXAodGhpcyk7XG4gICAgICAgIGNvbnN0IHVyaURvbWFpbkFuZFBhdGg6IHN0cmluZ1tdIHwgbnVsbCA9IC8oaHR0cHM/OlxcL1xcL1teXFwvXSopKFxcLy4qKS8uZXhlYyhjbG9uZS51cmkpO1xuICAgICAgICBjbG9uZS51cmkgPSB1cmlEb21haW5BbmRQYXRoID09IG51bGwgPyBjbG9uZS51cmkgOiB1cmlEb21haW5BbmRQYXRoWzJdO1xuICAgICAgICBjbG9uZS51cmkgPSB0aGlzLnN1YnN0aXR1dGVLZXlGb3JWYWx1ZShjbG9uZS51cmksIHRoaXMud2hvbGVXb3JkTWF0Y2gsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcL1xcLy8sICcvJykgLy8gdG8gcmVwbGFjZSBkb3VibGUgc2xhc2ggKGFwaS86aWRlbnRpZmllci9kYXRhP3BhcmFtPXRydWUpIGlmIDppZGVudGlmaWVyIGlzIHJlbW92ZWRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC9cXD8vLCAnPycpIC8vIHRvIHJlcGxhY2Ugc2xhc2ggcXVlc3Rpb24gbWFyayAoYXBpLzppZGVudGlmaWVyP3BhcmFtPXRydWUpIGlmIDppZGVudGlmaWVyIGlzIHJlbW92ZWRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8kLywgJycpOyAvLyB0byByZW1vdmUgdHJhaWxpbmcgc2xhc2hcblxuICAgICAgICBjbG9uZS51cmkgPSB1cmlEb21haW5BbmRQYXRoID09IG51bGwgPyBjbG9uZS51cmkgOiB1cmlEb21haW5BbmRQYXRoWzFdICsgY2xvbmUudXJpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzdGl0dXRlS2V5Rm9yVmFsdWUodXJsOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgdXJsID0gdXJsXG4gICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGtleSArICcvJyksIGAke3ZhbHVlIHx8ICcnfS9gKVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicgKyBrZXkgKyAnJCcpLCBgJHt2YWx1ZSB8fCAnJ31gKVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicgKyBrZXkgKyAnXFxcXD8nKSwgYCR7dmFsdWUgfHwgJyd9P2ApXG4gICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGtleSArICcmJyksIGAke3ZhbHVlIHx8ICcnfSZgKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB0byBjYXRlciBmb3Igc3BlY2lhbCBjYXNlIG9mIHNtYXJ0ZWRpdFxuICAgICAgICAgKiB3aGVyZSBzb21lIG5vbiBcIjpcIiBwcmVmaXhlZCBwbGFjZWhvbGRlcnMgbXVzdCBiZSByZXNvbHZlZCB0b29cbiAgICAgICAgICogd2UgbGltaXQgaXQgdGhvdWdoIHRvIGtleXMgY29udGFpbmluZyBcIl9cIiAoY2FzZSBmb3Igc21hcnRlZGl0KVxuICAgICAgICAgKiBzaW5jZSBpdCB3b3VsZCBvdGhlcndpc2UgYnJlYWtzIG1vc3QgQVBJcyBwYXR0ZXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGtleSAhPT0gdGhpcy53aG9sZVdvcmRNYXRjaCAmJiBrZXkuaW5jbHVkZXMoJ18nKSkge1xuICAgICAgICAgICAgY29uc3QgX3VyaSA9IHVybC5pbmNsdWRlcygnPycpID8gdXJsLnN1YnN0cigwLCB1cmwuaW5kZXhPZignPycpKSA6IHVybDtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IF91cmkucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcYicgKyBrZXkgKyAnXFxcXGInKSwgYCR7dmFsdWUgfHwgJyd9YCk7XG4gICAgICAgICAgICB1cmwgPSB1cmwuaW5jbHVkZXMoJz8nKSA/IHVyaSArIHVybC5zdWJzdHIodXJsLmluZGV4T2YoJz8nKSkgOiB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlsc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIFVSTHNcbiAqL1xuZXhwb3J0IGNsYXNzIFVybFV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHMjZ2V0T3JpZ2luXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOlVybFV0aWxzXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogcmV0dXJucyBkb2N1bWVudCBsb2NhdGlvbiBvcmlnaW5cbiAgICAgKiBTb21lIGJyb3dzZXJzIHN0aWxsIGRvIG5vdCBzdXBwb3J0IFczQyBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4sIHRoaXMgZnVuY3Rpb24gY2F0ZXJzIGZvciBnYXAuXG4gICAgICogQHBhcmFtIHtTdHJpbmcgPX0gdXJsIG9wdGlvbmFsIGFueSB1cmxcbiAgICAgKi9cbiAgICBnZXRPcmlnaW4odXJsPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPVxuICAgICAgICAgICAgICAgIGxpbmsucHJvdG9jb2wgKyAnLy8nICsgbGluay5ob3N0bmFtZSArIChsaW5rLnBvcnQgPyAnOicgKyBsaW5rLnBvcnQgOiAnJyk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBsaW5rID0gbnVsbDsgLy8gR0NcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArXG4gICAgICAgICAgICAgICAgJy8vJyArXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgICAod2luZG93LmxvY2F0aW9uLnBvcnQgPyAnOicgKyB3aW5kb3cubG9jYXRpb24ucG9ydCA6ICcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlscyNnZXRVUklcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFdpbGwgcmV0dXJuIHRoZSBVUkkgcGFydCBvZiBhIFVSTFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIFVSTCB0aGUgVVJJIG9mIHdoaWNoIGlzIHRvIGJlIHJldHVybmVkXG4gICAgICovXG4gICAgZ2V0VVJJKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwuaW5kZXhPZignPycpID4gLTEgPyB1cmwuc3BsaXQoJz8nKVswXSA6IHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHMjdXBkYXRlVXJsUGFyYW1ldGVyXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOlVybFV0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBVcGRhdGVzIGEgVVJMIHRvIGNvbnRhaW4gdGhlIHF1ZXJ5IHBhcmFtIGFuZCB2YWx1ZSBwcm92aWRlZC4gSWYgYWxyZWFkeSBleGlzdHMgdGhlbiBpdCBpcyB1cGRhdGVkLFxuICAgICAqIGlmIGl0IGRpZCBub3QgcHJldmlvdXNseSBleGlzdCwgdGhlbiBpdCB3aWxsIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsIHRvIGJlIHVwZGF0ZWQgKHRoaXMgcGFyYW0gd2lsbCBub3QgYmUgbW9kaWZpZWQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgcXVlcnkgcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBxdWVyeSBwYXJhbSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHVybCB3aXRoIHVwZGF0ZWQga2V5L3ZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlVXJsUGFyYW1ldGVyKHVybDogc3RyaW5nLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGkgPSB1cmwuaW5kZXhPZignIycpO1xuICAgICAgICBjb25zdCBoYXNoID0gaSA9PT0gLTEgPyAnJyA6IHVybC5zdWJzdHIoaSk7XG4gICAgICAgIHVybCA9IGkgPT09IC0xID8gdXJsIDogdXJsLnN1YnN0cigwLCBpKTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCcoWz8mXSknICsga2V5ICsgJz0uKj8oJnwkKScsICdpJyk7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgIT09IC0xID8gJyYnIDogJz8nO1xuXG4gICAgICAgIGlmICh1cmwubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShyZWdleCwgJyQxJyArIGtleSArICc9JyArIHZhbHVlICsgJyQyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwgKyBzZXBhcmF0b3IgKyBrZXkgKyAnPScgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsICsgaGFzaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHMjZ2V0UXVlcnlTdHJpbmdcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxiPmdldFF1ZXJ5U3RyaW5nPC9iPiB3aWxsIGNvbnZlcnQgYSBnaXZlbiBvYmplY3QgaW50byBhIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEJlbG93IGlzIHRoZSBjb2RlIHNuaXBwZXQgZm9yIHNhbXBsZSBpbnB1dCBhbmQgc2FtcGxlIG91dHB1dDpcbiAgICAgKlxuICAgICAqIDxwcmU+XG4gICAgICogdmFyIHBhcmFtcyA9IHtcbiAgICAgKiAga2V5MSA6ICd2YWx1ZTEnLFxuICAgICAqICBrZXkyIDogJ3ZhbHVlMicsXG4gICAgICogIGtleTMgOiAndmFsdWUzJ1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgdmFyIG91dHB1dCA9IGdldFF1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgICpcbiAgICAgKiAgLy8gVGhlIG91dHB1dCBpcyAnPyZrZXkxPXZhbHVlMSZrZXkyPXZhbHVlMiZrZXkzPXZhbHVlMydcbiAgICAgKlxuICAgICAqIDwvcHJlPlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT2JqZWN0IGNvbnRhaW5pbmcgYSBsaXN0IG9mIHBhcmFtcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGEgcXVlcnkgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0UXVlcnlTdHJpbmcocGFyYW1zOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcXVlcnlTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICAobG9kYXNoLmlzQXJyYXkocGFyYW1zW3BhcmFtXSkgPyBwYXJhbXNbcGFyYW1dIDogW3BhcmFtc1twYXJhbV1dKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc/JyArICghc3RyaW5nVXRpbHMuaXNCbGFuayhxdWVyeVN0cmluZykgPyBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSkgOiBxdWVyeVN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOlVybFV0aWxzI3BhcnNlUXVlcnlcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6VXJsVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxiPnBhcnNlUXVlcnk8L2I+IHdpbGwgY29udmVydCBhIGdpdmVuIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBCZWxvdyBpcyB0aGUgY29kZSBzbmlwcGV0IGZvciBzYW1wbGUgaW5wdXQgYW5kIHNhbXBsZSBvdXRwdXQ6XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIHZhciBxdWVyeSA9ICc/a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTMnO1xuICAgICAqXG4gICAgICogdmFyIG91dHB1dCA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICAgICAqXG4gICAgICogLy8gVGhlIG91dHB1dCBpcyB7IGtleTEgOiAndmFsdWUxJywga2V5MiA6ICd2YWx1ZTInLCBrZXkzIDogJ3ZhbHVlMycgfVxuICAgICAqXG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBwYXJhbXMgb2YgdGhlIGdpdmVuIHF1ZXJ5XG4gICAgICovXG4gICAgcGFyc2VRdWVyeShzdHI6IGFueSk6IEpTT04ge1xuICAgICAgICBjb25zdCBvYmpVUkwgPSB7fSBhcyBhbnk7XG5cbiAgICAgICAgc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnKFtePz0mXSspKD0oW14mXSopKT8nLCAnZycpLCBmdW5jdGlvbihcbiAgICAgICAgICAgICQwOiBhbnksXG4gICAgICAgICAgICAkMTogYW55LFxuICAgICAgICAgICAgJDI6IGFueSxcbiAgICAgICAgICAgICQzOiBhbnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvYmpVUkxbJDFdID0gJDM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqVVJMO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlscyNnZXRBYnNvbHV0ZVVSTFxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpVcmxVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWFrZXMgdXJsIGFic29sdXRlICh3aXRoIHByb3ZpZGVkIGRvbWFpbikgaWYgbm90IHlldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiB0aGUgZG9tYWluIHdpdGggd2l0Y2ggdG8gcHJlcGVuZCB0aGUgdXJsIGlmIGl0IGlzIG5vdCBhYnNvbHV0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIHVybCB0byB0ZXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgKi9cbiAgICBnZXRBYnNvbHV0ZVVSTChkb21haW46IHN0cmluZywgdXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAvLyB1cmwgcmVnZXhcbiAgICAgICAgLy8gc2NoZW1lOlsvL1t1c2VyWzpwYXNzd29yZF1AXWhvc3RbOnBvcnRdXVsvcGF0aF1bP3F1ZXJ5XVsjZnJhZ21lbnRdXG4gICAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICcoW2EtekEtWjAtOV0rOi8vKScgKyAvLyBzY2hlbWVcbiAgICAgICAgICAgICcoW2EtekEtWjAtOV9dKzpbYS16QS1aMC05X10rQCk/JyArIC8vIHVzZXI6cGFzc3dvcmRcbiAgICAgICAgICAgICcoW2EtekEtWjAtOS4tXSspJyArIC8vIGhvc3RuYW1lXG4gICAgICAgICAgICAnfChbMC05XStcXFxcLlswLTldK1xcXFwuWzAtOV0rXFxcXC5bMC05XSspJyArIC8vIG9yIGlwXG4gICAgICAgICAgICAnKDpbMC05XSspPycgKyAvLyBwb3J0XG4gICAgICAgICAgICAgICAgJygvLiopPycgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlLmV4ZWModXJsKSA/IHVybCA6IGRvbWFpbiArIHVybDtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCB1cmxVdGlscyA9IG5ldyBVcmxVdGlscygpO1xuIl19