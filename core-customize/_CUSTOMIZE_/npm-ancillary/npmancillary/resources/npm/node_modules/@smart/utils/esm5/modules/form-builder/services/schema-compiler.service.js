/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import { Injectable } from '@angular/core';
import { FormArray, FormControl, FormGroup } from '@angular/forms';
import { FormBuilderModule } from '../form-builder.module';
import { FormField, FormGrouping, FormList, InputProperties, ValidatorParameters } from '../models';
import { FormListerComponent } from '../components/form-lister/form-lister.component';
import { ComponentRegistryService, ComponentTypeMap } from './component-registry.service';
import { ValidatorMap, ValidatorRegistryService } from './validator-registry.service';
import { AsyncValidatorMap, AsyncValidatorRegistryService } from './async-validator-registry.service';
import * as i0 from "@angular/core";
import * as i1 from "./component-registry.service";
import * as i2 from "./validator-registry.service";
import * as i3 from "./async-validator-registry.service";
import * as i4 from "../form-builder.module";
/**
 * Schema compilers service is used for compiling a schema to concrete classes for use
 * by the FormRendererDirective.
 */
var SchemaCompilerService = /** @class */ (function () {
    function SchemaCompilerService(types, validators, asyncValidators) {
        this.types = types;
        this.validators = validators;
        this.asyncValidators = asyncValidators;
    }
    /**
     * Compile a schema group.
     *
     * @param value
     * @param groupSchema
     * @returns
     */
    SchemaCompilerService.prototype.compileGroup = function (value, groupSchema, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var abstractForms = Object.keys(groupSchema.schemas).reduce(function (acc, key) {
            acc[key] = _this._toAbstractForm(value ? value[key] : null, groupSchema.schemas[key], options);
            return acc;
        }, {});
        var formGroup = new FormGroup(Object.keys(abstractForms).reduce(function (acc, key) {
            acc[key] = abstractForms[key].control;
            return acc;
        }, {}));
        return new FormGrouping(groupSchema.component
            ? this._getComponent(groupSchema.component, options.components)
            : FormListerComponent, formGroup, new InputProperties(groupSchema.inputs), this._toPersist(groupSchema.persist), null, abstractForms);
    };
    /**
     * Compiles a list of values with a schema.
     *
     * @param values An array of values.
     * @param listSchema
     */
    SchemaCompilerService.prototype.compileList = function (values, schema, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        /**
         * The schema list for each value since each value can have different
         * schemas. Or they can have the same schema for all values in the list.
         */
        var schemaList = Array.isArray(schema.schema) ? schema.schema : [schema.schema];
        if (!schemaList.length) {
            throw Error('SchemaCompilerService - One or more schemas must be provided to compile a form list.');
        }
        var list = (Array.isArray(values) ? values : []).map(function (value, index) {
            var childSchema = schemaList[index]
                ? /**
                   * Get the schema one to one for the value, or get the last schema
                   * which may be repeated for all values.
                   */
                    schemaList[index]
                : schemaList[schemaList.length - 1];
            return _this._toAbstractForm(value, childSchema, options);
        });
        var control = new FormArray(list.map(function (form) { return form.control; }));
        return new FormList(this._getComponent(schema.component, options.components), control, new InputProperties(schema.inputs), null, this._toPersist(schema.persist), list);
    };
    /**
     * Compiles a schema field.
     *
     * @param value
     * @param {FormFieldSchema} schema
     * @returns {FormField}
     */
    SchemaCompilerService.prototype.compileField = function (value, schema, options) {
        if (options === void 0) { options = {}; }
        var validators = [];
        var asyncValidators = [];
        if (schema.validators) {
            validators = this._mapValidator(schema.validators, this.validators, options.validators);
        }
        if (schema.asyncValidators) {
            asyncValidators = this._mapValidator(schema.asyncValidators, this.asyncValidators, options.asyncValidators);
        }
        var formControl = new FormControl({ value: value, disabled: schema.disabled }, validators, asyncValidators);
        return new FormField(this._getComponent(schema.component, options.components), formControl, new InputProperties(schema.inputs), this._toPersist(schema.persist), new ValidatorParameters(schema.validators, schema.asyncValidators));
    };
    /**
     * @internal
     * @param value
     * @param schema
     */
    SchemaCompilerService.prototype._toAbstractForm = function (value, schema, options) {
        if (schema.type === 'field') {
            return this.compileField(value, schema, options);
        }
        if (schema.type === 'group') {
            return this.compileGroup(value, schema, options);
        }
        return this.compileList(value, schema, options);
    };
    /**
     * @internal
     *
     * Maps schema validators to actual validators in the registry and passes custom params to a validator.
     * If params are undefined then the validator isn't added to the array of validators. Validators
     * that are found the inline registry will take precedence of those in registries.
     */
    SchemaCompilerService.prototype._mapValidator = function (validators, registry, inline) {
        var _this = this;
        if (inline === void 0) { inline = {}; }
        return Object.keys(validators).reduce(function (acc, name) {
            var params = validators[name];
            if (params !== undefined) {
                var fn = inline[name] ? inline[name] : registry.get(name);
                if (!fn) {
                    throw new Error("SchemaCompilerService - Validator not found in " + _this.validators.constructor.name + " for: " + name + ".");
                }
                acc.push(fn(params));
            }
            return acc;
        }, []);
    };
    /**
     * @internal
     * Sets default to true if parameter persist is undefined.
     */
    SchemaCompilerService.prototype._toPersist = function (persist) {
        if (persist === void 0) { persist = true; }
        return persist;
    };
    /**
     * @internal
     * Decides if should get the type from the inline map or registry.
     * If no component is found, it would throw an error.
     *
     * @param name The name of the component in the registry.
     * @param components An component type name, used for inline components.
     */
    SchemaCompilerService.prototype._getComponent = function (name, components) {
        if (components === void 0) { components = {}; }
        var comp = components[name] ? components[name] : this.types.get(name);
        if (!comp) {
            throw new Error("SchemaCompilerService - Did not find component for: " + name + ".");
        }
        return comp;
    };
    SchemaCompilerService.ctorParameters = function () { return [
        { type: ComponentRegistryService },
        { type: ValidatorRegistryService },
        { type: AsyncValidatorRegistryService }
    ]; };
    SchemaCompilerService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function SchemaCompilerService_Factory() { return new SchemaCompilerService(i0.ɵɵinject(i1.ComponentRegistryService), i0.ɵɵinject(i2.ValidatorRegistryService), i0.ɵɵinject(i3.AsyncValidatorRegistryService)); }, token: SchemaCompilerService, providedIn: i4.FormBuilderModule });
    SchemaCompilerService = tslib_1.__decorate([
        Injectable({
            providedIn: FormBuilderModule
        }),
        tslib_1.__metadata("design:paramtypes", [ComponentRegistryService,
            ValidatorRegistryService,
            AsyncValidatorRegistryService])
    ], SchemaCompilerService);
    return SchemaCompilerService;
}());
export { SchemaCompilerService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hLWNvbXBpbGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac21hcnQvdXRpbHMvIiwic291cmNlcyI6WyJtb2R1bGVzL2Zvcm0tYnVpbGRlci9zZXJ2aWNlcy9zY2hlbWEtY29tcGlsZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHO0FBQ0gsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQW9CLFNBQVMsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFlLE1BQU0sZ0JBQWdCLENBQUM7QUFFbEcsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDM0QsT0FBTyxFQUtILFNBQVMsRUFFVCxZQUFZLEVBRVosUUFBUSxFQUVSLGVBQWUsRUFDZixtQkFBbUIsRUFDdEIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saURBQWlELENBQUM7QUFFdEYsT0FBTyxFQUFFLHdCQUF3QixFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDMUYsT0FBTyxFQUFFLFlBQVksRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3RGLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsNkJBQTZCLEVBQ2hDLE1BQU0sb0NBQW9DLENBQUM7Ozs7OztBQTBCNUM7OztHQUdHO0FBSUg7SUFDSSwrQkFDWSxLQUErQixFQUMvQixVQUFvQyxFQUNwQyxlQUE4QztRQUY5QyxVQUFLLEdBQUwsS0FBSyxDQUEwQjtRQUMvQixlQUFVLEdBQVYsVUFBVSxDQUEwQjtRQUNwQyxvQkFBZSxHQUFmLGVBQWUsQ0FBK0I7SUFDdkQsQ0FBQztJQUVKOzs7Ozs7T0FNRztJQUNILDRDQUFZLEdBQVosVUFDSSxLQUFpQixFQUNqQixXQUE0QixFQUM1QixPQUFtQztRQUh2QyxpQkFxQ0M7UUFsQ0csd0JBQUEsRUFBQSxZQUFtQztR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QUFDLENBQUM7YUFDeEI7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUMsRUFDRCxFQUFXLENBQ2QsQ0FBQztJQUNOLENBQUM7SUFFRDs7O09BR0c7SUFDSywwQ0FBVSxHQUFsQixVQUFtQixPQUFtQztRQUFuQyx3QkFBQSxFQUFBLGNBQW1DO1FBQ2xELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssNkNBQWEsR0FBckIsVUFBc0IsSUFBWSxFQUFFLFVBQWlDO1FBQWpDLDJCQUFBLEVBQUEsZUFBaUM7UUFDakUsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXhFLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLHlEQUF1RCxJQUFJLE1BQUcsQ0FBQyxDQUFDO1NBQ25GO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQzs7Z0JBN05rQix3QkFBd0I7Z0JBQ25CLHdCQUF3QjtnQkFDbkIsNkJBQTZCOzs7SUFKakQscUJBQXFCO1FBSGpDLFVBQVUsQ0FBQztZQUNSLFVBQVUsRUFBRSxpQkFBaUI7U0FDaEMsQ0FBQztpREFHcUIsd0JBQXdCO1lBQ25CLHdCQUF3QjtZQUNuQiw2QkFBNkI7T0FKakQscUJBQXFCLENBZ09qQztnQ0E5UkQ7Q0E4UkMsQUFoT0QsSUFnT0M7U0FoT1kscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBc3luY1ZhbGlkYXRvckZuLCBGb3JtQXJyYXksIEZvcm1Db250cm9sLCBGb3JtR3JvdXAsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBGb3JtQnVpbGRlck1vZHVsZSB9IGZyb20gJy4uL2Zvcm0tYnVpbGRlci5tb2R1bGUnO1xuaW1wb3J0IHtcbiAgICBBYnN0cmFjdEZvcm0sXG4gICAgQWJzdHJhY3RGb3JtcyxcbiAgICBBYnN0cmFjdEZvcm1TY2hlbWEsXG4gICAgQ29tcG9uZW50VHlwZSxcbiAgICBGb3JtRmllbGQsXG4gICAgRm9ybUZpZWxkU2NoZW1hLFxuICAgIEZvcm1Hcm91cGluZyxcbiAgICBGb3JtR3JvdXBTY2hlbWEsXG4gICAgRm9ybUxpc3QsXG4gICAgRm9ybUxpc3RTY2hlbWEsXG4gICAgSW5wdXRQcm9wZXJ0aWVzLFxuICAgIFZhbGlkYXRvclBhcmFtZXRlcnNcbn0gZnJvbSAnLi4vbW9kZWxzJztcbmltcG9ydCB7IEZvcm1MaXN0ZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzL2Zvcm0tbGlzdGVyL2Zvcm0tbGlzdGVyLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENvbXBvbmVudFJlZ2lzdHJ5U2VydmljZSwgQ29tcG9uZW50VHlwZU1hcCB9IGZyb20gJy4vY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHsgVmFsaWRhdG9yTWFwLCBWYWxpZGF0b3JSZWdpc3RyeVNlcnZpY2UgfSBmcm9tICcuL3ZhbGlkYXRvci1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7XG4gICAgQXN5bmNWYWxpZGF0b3JNYXAsXG4gICAgQXN5bmNWYWxpZGF0b3JSZWdpc3RyeVNlcnZpY2Vcbn0gZnJvbSAnLi9hc3luYy12YWxpZGF0b3ItcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgeyBSZWdpc3RyeSB9IGZyb20gJy4vcmVnaXN0cnknO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gYmUgcGFzc2VkIGlubGluZSBpbnRvIHRoZSBjb21waWxlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFDb21waWxlck9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIEFuZ3VsYXIgY29tcG9uZW50cyB0byBiZSBwYXNzZWQgaW5saW5lLiBDb21wb25lbnQgZm91bmRcbiAgICAgKiBpbiB0aGlzIG1hcCB3aWxsIHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzPzogQ29tcG9uZW50VHlwZU1hcDtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiB2YWxpZGF0b3IgZnVuY3Rpb25zIHRvIGJlIHBhc3NlZCBpbmxpbmUuXG4gICAgICogVmFsaWRhdG9ycyBmb3VuZCBpbiB0aGlzIG1hcCB3aWxsIHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZVxuICAgICAqIHRha2VuIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqL1xuICAgIHZhbGlkYXRvcnM/OiBWYWxpZGF0b3JNYXA7XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYXN5bmMgdmFsaWRhdG9ycyB0byBiZSBwYXNzZWQgaW5saW5lLlxuICAgICAqIFZhbGlkYXRvcnMgZm91bmQgaW4gdGhpcyBtYXAgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2VcbiAgICAgKiB0YWtlbiBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKi9cbiAgICBhc3luY1ZhbGlkYXRvcnM/OiBBc3luY1ZhbGlkYXRvck1hcDtcbn1cblxuLyoqXG4gKiBTY2hlbWEgY29tcGlsZXJzIHNlcnZpY2UgaXMgdXNlZCBmb3IgY29tcGlsaW5nIGEgc2NoZW1hIHRvIGNvbmNyZXRlIGNsYXNzZXMgZm9yIHVzZVxuICogYnkgdGhlIEZvcm1SZW5kZXJlckRpcmVjdGl2ZS5cbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46IEZvcm1CdWlsZGVyTW9kdWxlXG59KVxuZXhwb3J0IGNsYXNzIFNjaGVtYUNvbXBpbGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgdHlwZXM6IENvbXBvbmVudFJlZ2lzdHJ5U2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSB2YWxpZGF0b3JzOiBWYWxpZGF0b3JSZWdpc3RyeVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgYXN5bmNWYWxpZGF0b3JzOiBBc3luY1ZhbGlkYXRvclJlZ2lzdHJ5U2VydmljZVxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIENvbXBpbGUgYSBzY2hlbWEgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gZ3JvdXBTY2hlbWFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNvbXBpbGVHcm91cChcbiAgICAgICAgdmFsdWU6IGFueSB8IG51bGwsXG4gICAgICAgIGdyb3VwU2NoZW1hOiBGb3JtR3JvdXBTY2hlbWEsXG4gICAgICAgIG9wdGlvbnM6IFNjaGVtYUNvbXBpbGVyT3B0aW9ucyA9IHt9XG4gICAgKTogRm9ybUdyb3VwaW5nIHtcbiAgICAgICAgY29uc3QgYWJzdHJhY3RGb3JtcyA9IE9iamVjdC5rZXlzKGdyb3VwU2NoZW1hLnNjaGVtYXMpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSB0aGlzLl90b0Fic3RyYWN0Rm9ybShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPyB2YWx1ZVtrZXldIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTY2hlbWEuc2NoZW1hc1trZXldLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHt9IGFzIEFic3RyYWN0Rm9ybXNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBmb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWJzdHJhY3RGb3JtcykucmVkdWNlKFxuICAgICAgICAgICAgICAgIChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGFic3RyYWN0Rm9ybXNba2V5XS5jb250cm9sO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge30gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtR3JvdXBpbmcoXG4gICAgICAgICAgICBncm91cFNjaGVtYS5jb21wb25lbnRcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2dldENvbXBvbmVudChncm91cFNjaGVtYS5jb21wb25lbnQsIG9wdGlvbnMuY29tcG9uZW50cylcbiAgICAgICAgICAgICAgICA6IEZvcm1MaXN0ZXJDb21wb25lbnQsXG4gICAgICAgICAgICBmb3JtR3JvdXAsXG4gICAgICAgICAgICBuZXcgSW5wdXRQcm9wZXJ0aWVzKGdyb3VwU2NoZW1hLmlucHV0cyksXG4gICAgICAgICAgICB0aGlzLl90b1BlcnNpc3QoZ3JvdXBTY2hlbWEucGVyc2lzdCksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYWJzdHJhY3RGb3Jtc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBpbGVzIGEgbGlzdCBvZiB2YWx1ZXMgd2l0aCBhIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgQW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBsaXN0U2NoZW1hXG4gICAgICovXG4gICAgY29tcGlsZUxpc3QoXG4gICAgICAgIHZhbHVlczogYW55W10sXG4gICAgICAgIHNjaGVtYTogRm9ybUxpc3RTY2hlbWEsXG4gICAgICAgIG9wdGlvbnM6IFNjaGVtYUNvbXBpbGVyT3B0aW9ucyA9IHt9XG4gICAgKTogRm9ybUxpc3Qge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjaGVtYSBsaXN0IGZvciBlYWNoIHZhbHVlIHNpbmNlIGVhY2ggdmFsdWUgY2FuIGhhdmUgZGlmZmVyZW50XG4gICAgICAgICAqIHNjaGVtYXMuIE9yIHRoZXkgY2FuIGhhdmUgdGhlIHNhbWUgc2NoZW1hIGZvciBhbGwgdmFsdWVzIGluIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2NoZW1hTGlzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnNjaGVtYSkgPyBzY2hlbWEuc2NoZW1hIDogW3NjaGVtYS5zY2hlbWFdO1xuXG4gICAgICAgIGlmICghc2NoZW1hTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICdTY2hlbWFDb21waWxlclNlcnZpY2UgLSBPbmUgb3IgbW9yZSBzY2hlbWFzIG11c3QgYmUgcHJvdmlkZWQgdG8gY29tcGlsZSBhIGZvcm0gbGlzdC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdCA9IChBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbXSkubWFwKCh2YWx1ZTogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IHNjaGVtYUxpc3RbaW5kZXhdXG4gICAgICAgICAgICAgICAgPyAvKipcbiAgICAgICAgICAgICAgICAgICAqIEdldCB0aGUgc2NoZW1hIG9uZSB0byBvbmUgZm9yIHRoZSB2YWx1ZSwgb3IgZ2V0IHRoZSBsYXN0IHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICogd2hpY2ggbWF5IGJlIHJlcGVhdGVkIGZvciBhbGwgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBzY2hlbWFMaXN0W2luZGV4XVxuICAgICAgICAgICAgICAgIDogc2NoZW1hTGlzdFtzY2hlbWFMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9BYnN0cmFjdEZvcm0odmFsdWUsIGNoaWxkU2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQXJyYXkobGlzdC5tYXAoKGZvcm0pID0+IGZvcm0uY29udHJvbCkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgRm9ybUxpc3QoXG4gICAgICAgICAgICB0aGlzLl9nZXRDb21wb25lbnQoc2NoZW1hLmNvbXBvbmVudCwgb3B0aW9ucy5jb21wb25lbnRzKSxcbiAgICAgICAgICAgIGNvbnRyb2wsXG4gICAgICAgICAgICBuZXcgSW5wdXRQcm9wZXJ0aWVzKHNjaGVtYS5pbnB1dHMpLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRoaXMuX3RvUGVyc2lzdChzY2hlbWEucGVyc2lzdCksXG4gICAgICAgICAgICBsaXN0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZXMgYSBzY2hlbWEgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Zvcm1GaWVsZFNjaGVtYX0gc2NoZW1hXG4gICAgICogQHJldHVybnMge0Zvcm1GaWVsZH1cbiAgICAgKi9cbiAgICBjb21waWxlRmllbGQoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIHNjaGVtYTogRm9ybUZpZWxkU2NoZW1hLFxuICAgICAgICBvcHRpb25zOiBTY2hlbWFDb21waWxlck9wdGlvbnMgPSB7fVxuICAgICk6IEZvcm1GaWVsZCB7XG4gICAgICAgIGxldCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gW107XG4gICAgICAgIGxldCBhc3luY1ZhbGlkYXRvcnM6IEFzeW5jVmFsaWRhdG9yRm5bXSA9IFtdO1xuXG4gICAgICAgIGlmIChzY2hlbWEudmFsaWRhdG9ycykge1xuICAgICAgICAgICAgdmFsaWRhdG9ycyA9IHRoaXMuX21hcFZhbGlkYXRvcjxWYWxpZGF0b3JSZWdpc3RyeVNlcnZpY2UsIFZhbGlkYXRvckZuPihcbiAgICAgICAgICAgICAgICBzY2hlbWEudmFsaWRhdG9ycyxcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvcnMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52YWxpZGF0b3JzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5hc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGFzeW5jVmFsaWRhdG9ycyA9IHRoaXMuX21hcFZhbGlkYXRvcjxBc3luY1ZhbGlkYXRvclJlZ2lzdHJ5U2VydmljZSwgQXN5bmNWYWxpZGF0b3JGbj4oXG4gICAgICAgICAgICAgICAgc2NoZW1hLmFzeW5jVmFsaWRhdG9ycyxcbiAgICAgICAgICAgICAgICB0aGlzLmFzeW5jVmFsaWRhdG9ycyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1Db250cm9sID0gbmV3IEZvcm1Db250cm9sKFxuICAgICAgICAgICAgeyB2YWx1ZSwgZGlzYWJsZWQ6IHNjaGVtYS5kaXNhYmxlZCB9LFxuICAgICAgICAgICAgdmFsaWRhdG9ycyxcbiAgICAgICAgICAgIGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBuZXcgRm9ybUZpZWxkKFxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29tcG9uZW50KHNjaGVtYS5jb21wb25lbnQsIG9wdGlvbnMuY29tcG9uZW50cyksXG4gICAgICAgICAgICBmb3JtQ29udHJvbCxcbiAgICAgICAgICAgIG5ldyBJbnB1dFByb3BlcnRpZXMoc2NoZW1hLmlucHV0cyksXG4gICAgICAgICAgICB0aGlzLl90b1BlcnNpc3Qoc2NoZW1hLnBlcnNpc3QpLFxuICAgICAgICAgICAgbmV3IFZhbGlkYXRvclBhcmFtZXRlcnMoc2NoZW1hLnZhbGlkYXRvcnMsIHNjaGVtYS5hc3luY1ZhbGlkYXRvcnMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHNjaGVtYVxuICAgICAqL1xuICAgIHByaXZhdGUgX3RvQWJzdHJhY3RGb3JtKFxuICAgICAgICB2YWx1ZTogYW55IHwgbnVsbCxcbiAgICAgICAgc2NoZW1hOiBBYnN0cmFjdEZvcm1TY2hlbWEsXG4gICAgICAgIG9wdGlvbnM6IFNjaGVtYUNvbXBpbGVyT3B0aW9uc1xuICAgICk6IEFic3RyYWN0Rm9ybSB7XG4gICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUZpZWxkKHZhbHVlLCBzY2hlbWEgYXMgRm9ybUZpZWxkU2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVHcm91cCh2YWx1ZSwgc2NoZW1hIGFzIEZvcm1Hcm91cFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUxpc3QodmFsdWUsIHNjaGVtYSBhcyBGb3JtTGlzdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICpcbiAgICAgKiBNYXBzIHNjaGVtYSB2YWxpZGF0b3JzIHRvIGFjdHVhbCB2YWxpZGF0b3JzIGluIHRoZSByZWdpc3RyeSBhbmQgcGFzc2VzIGN1c3RvbSBwYXJhbXMgdG8gYSB2YWxpZGF0b3IuXG4gICAgICogSWYgcGFyYW1zIGFyZSB1bmRlZmluZWQgdGhlbiB0aGUgdmFsaWRhdG9yIGlzbid0IGFkZGVkIHRvIHRoZSBhcnJheSBvZiB2YWxpZGF0b3JzLiBWYWxpZGF0b3JzXG4gICAgICogdGhhdCBhcmUgZm91bmQgdGhlIGlubGluZSByZWdpc3RyeSB3aWxsIHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBpbiByZWdpc3RyaWVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgX21hcFZhbGlkYXRvcjxUIGV4dGVuZHMgUmVnaXN0cnk8YW55PiwgTT4oXG4gICAgICAgIHZhbGlkYXRvcnM6IHsgW2luZGV4OiBzdHJpbmddOiBhbnkgfSxcbiAgICAgICAgcmVnaXN0cnk6IFQsXG4gICAgICAgIGlubGluZTogeyBba2V5OiBzdHJpbmddOiAoLi4uYXJnczogYW55W10pID0+IE0gfSA9IHt9XG4gICAgKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gdmFsaWRhdG9yc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSBpbmxpbmVbbmFtZV0gPyBpbmxpbmVbbmFtZV0gOiByZWdpc3RyeS5nZXQobmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBTY2hlbWFDb21waWxlclNlcnZpY2UgLSBWYWxpZGF0b3Igbm90IGZvdW5kIGluICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9ycy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmb3I6ICR7bmFtZX0uYFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKGZuKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtdIGFzIGFueVtdXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogU2V0cyBkZWZhdWx0IHRvIHRydWUgaWYgcGFyYW1ldGVyIHBlcnNpc3QgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3RvUGVyc2lzdChwZXJzaXN0OiBib29sZWFuIHwgdW5kZWZpbmVkID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcGVyc2lzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBEZWNpZGVzIGlmIHNob3VsZCBnZXQgdGhlIHR5cGUgZnJvbSB0aGUgaW5saW5lIG1hcCBvciByZWdpc3RyeS5cbiAgICAgKiBJZiBubyBjb21wb25lbnQgaXMgZm91bmQsIGl0IHdvdWxkIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGUgcmVnaXN0cnkuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudHMgQW4gY29tcG9uZW50IHR5cGUgbmFtZSwgdXNlZCBmb3IgaW5saW5lIGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0Q29tcG9uZW50KG5hbWU6IHN0cmluZywgY29tcG9uZW50czogQ29tcG9uZW50VHlwZU1hcCA9IHt9KTogQ29tcG9uZW50VHlwZSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBjb21wb25lbnRzW25hbWVdID8gY29tcG9uZW50c1tuYW1lXSA6IHRoaXMudHlwZXMuZ2V0KG5hbWUpO1xuXG4gICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWFDb21waWxlclNlcnZpY2UgLSBEaWQgbm90IGZpbmQgY29tcG9uZW50IGZvcjogJHtuYW1lfS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wO1xuICAgIH1cbn1cbiJdfQ==