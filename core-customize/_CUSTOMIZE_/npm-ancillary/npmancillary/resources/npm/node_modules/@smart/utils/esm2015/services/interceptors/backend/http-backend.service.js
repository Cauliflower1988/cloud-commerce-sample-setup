/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/* tslint:disable:max-classes-per-file */
import * as lodash from 'lodash';
import { Injectable } from '@angular/core';
/**
 * @ngdoc service
 * @name @smartutils.services:BackendEntry
 * @description
 * Invocations of {@link @smartutils.services:HttpBackendService} when, whenGET, whenPOST, whenPUT, whenDELETE
 * all return an instance of {@link @smartutils.services:BackendEntry BackendEntry}
 * It is used to specify the mocked response for the given conditions.
 */
export class BackendEntry {
    constructor(pattern, matchingPayload) {
        this.pattern = pattern;
        this.matchingPayload = matchingPayload;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:BackendEntry#respond
     * @methodOf @smartutils.services:BackendEntry
     * @description
     * @param {BackendRespond} mock the {@link @smartutils.object:BackendRespond} to return for the given conditions
     */
    respond(mock) {
        this.mock = mock;
        return this;
    }
    passThrough() {
        //
    }
}
/**
 * @ngdoc service
 * @name @smartutils.services:HttpBackendService
 * @description
 * Service aimed to provide mocked backend responses for given http request patterns.
 * It follows the API of {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend $httpBackend}
 * minus a few limitations
 */
let HttpBackendService = class HttpBackendService {
    /**
     * @ngdoc service
     * @name @smartutils.services:HttpBackendService
     * @description
     * Service aimed to provide mocked backend responses for given http request patterns.
     * It follows the API of {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend $httpBackend}
     * minus a few limitations
     */
    constructor() {
        this.matchLatestDefinition = false;
        this.backends = {
            GET: [],
            POST: [],
            PUT: [],
            DELETE: []
        };
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenGET
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenGET $httpBackend#whenGET}
     * but with only the url pattern as parameter
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    whenGET(pattern) {
        return this._whenMethod('GET', pattern);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPOST
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPOST $httpBackend#whenPOST}
     * but with only the first 2 arguments
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    whenPOST(pattern, matchingPayload) {
        return this._whenMethod('POST', pattern, matchingPayload);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPUT
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPUT $httpBackend#whenPUT}
     * but with only the first 2 arguments
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    whenPUT(pattern, matchingPayload) {
        return this._whenMethod('PUT', pattern, matchingPayload);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenPUT
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#whenPUT $httpBackend#whenPUT}
     * but with only the url pattern as parameter
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    whenDELETE(pattern) {
        return this._whenMethod('DELETE', pattern);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#when
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#when $httpBackend#when}
     * @param {string} method GET, POST, PUT, or DELETE
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    when(method, pattern, matchingPayload) {
        return this._whenMethod(method, pattern, matchingPayload);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#whenAsync
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to legacy $httpBackend#whenAsync, use {@link @smartutils.services:HttpBackendService#when HttpBackendService#when} instead
     * @param {string} method GET, POST, PUT, or DELETE
     * @param {string | RegExp} pattern url end of the url pattern to match
     * @param {Cloenable=} matchingPayload HTTP request body to be matched
     * @returns {BackendEntry} the {@link @smartutils.services:BackendEntry backenEntry}
     */
    whenAsync(method, pattern, matchingPayload) {
        return this._whenMethod(method, pattern, matchingPayload);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:HttpBackendService#matchLatestDefinitionEnabled
     * @methodOf @smartutils.services:HttpBackendService
     * @description
     * method similar to {@link https://docs.angularjs.org/api/ngMockE2E/service/$httpBackend#matchLatestDefinitionEnabled $httpBackend#matchLatestDefinitionEnabled}
     * @param {boolean=false} matchLatestDefinitionEnabled if true, the last matching pattern will be picked. Otherwise the first is picked
     */
    matchLatestDefinitionEnabled(matchLatestDefinitionEnabled) {
        this.matchLatestDefinition = matchLatestDefinitionEnabled;
    }
    // whenAsync
    ////////////////////////////////////
    findMatchingMock(request) {
        const backendEntry = (this.matchLatestDefinition
            ? this.backends[request.method].slice().reverse()
            : this.backends[request.method]).find((entry) => {
            if (typeof entry.pattern === 'string') {
                return (request.urlWithParams.endsWith(entry.pattern) &&
                    this.matchingPayloadRestriction(entry, request));
            }
            else {
                const test = entry.pattern.test(request.urlWithParams) &&
                    this.matchingPayloadRestriction(entry, request);
                entry.pattern.lastIndex = 0;
                return test;
            }
        });
        return backendEntry ? backendEntry.mock : undefined;
    }
    _whenMethod(method, pattern, matchingPayload) {
        const entry = new BackendEntry(pattern, matchingPayload);
        this.backends[method].push(entry);
        return entry;
    }
    matchingPayloadRestriction(entry, request) {
        return entry.matchingPayload ? lodash.isEqual(entry.matchingPayload, request.body) : true;
    }
};
HttpBackendService = tslib_1.__decorate([
    Injectable()
], HttpBackendService);
export { HttpBackendService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1iYWNrZW5kLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac21hcnQvdXRpbHMvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9pbnRlcmNlcHRvcnMvYmFja2VuZC9odHRwLWJhY2tlbmQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHO0FBQ0gseUNBQXlDO0FBQ3pDLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUE2QjNDOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQU8sWUFBWTtJQUdyQixZQUFtQixPQUF3QixFQUFTLGVBQTJCO1FBQTVELFlBQU8sR0FBUCxPQUFPLENBQWlCO1FBQVMsb0JBQWUsR0FBZixlQUFlLENBQVk7SUFBRyxDQUFDO0lBRW5GOzs7Ozs7T0FNRztJQUNILE9BQU8sQ0FBQyxJQUFvQjtRQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsV0FBVztRQUNQLEVBQUU7SUFDTixDQUFDO0NBQ0o7QUFNRDs7Ozs7OztHQU9HO0FBRUgsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFUL0I7Ozs7Ozs7T0FPRztJQUNIO1FBRVksMEJBQXFCLEdBQVksS0FBSyxDQUFDO1FBRXZDLGFBQVEsR0FBb0I7WUFDaEMsR0FBRyxFQUFFLEVBQUU7WUFDUCxJQUFJLEVBQUUsRUFBRTtZQUNSLEdBQUcsRUFBRSxFQUFFO1lBQ1AsTUFBTSxFQUFFLEVBQUU7U0FDYixDQUFDO0lBMklOLENBQUM7SUF6SUc7Ozs7Ozs7OztPQVNHO0lBQ0gsT0FBTyxDQUFDLE9BQXdCO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUNEOzs7Ozs7Ozs7O09BVUc7SUFDSCxRQUFRLENB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LENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDOUYsQ0FBQztDQUNKLENBQUE7QUFuSlksa0JBQWtCO0lBRDlCLFVBQVUsRUFBRTtHQUNBLGtCQUFrQixDQW1KOUI7U0FuSlksa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwUmVxdWVzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IENsb25lYWJsZSwgUGF5bG9hZCwgVHlwZWRNYXAgfSBmcm9tICcuLi8uLi8uLi9kdG9zJztcblxuZXhwb3J0IHR5cGUgUkVTVE1FVEhPRCA9ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJztcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6QmFja2VuZFJlc3BvbmRcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja2VkIHJlc3BvbnNlIG9mIGEge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSBIdHRwQmFja2VuZFNlcnZpY2V9IGludm9jYXRpb25cbiAqIEl0IGlzIGVpdGhlciBhIENsb25lYWJsZSBwYXlsb2FkIChyZXR1cm5lZCBhdXRvbWF0aWNhbGx5IHdpdGggMjAwIHN0YXR1cyBjb2RlKVxuICogb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgMiBhcmd1bWVudHM6IHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIHBheWxvYWRcbiAqIGlmIGEgZnVuY3Rpb24sIGl0IGlzIGludm9rZWQgd2l0aDpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWV0aG9kIEdFVCwgUE9TVCwgUFVUIG9yIERFTEVURVxuICogQHBhcmFtIHtzdHJpbmc9fSB1cmwgdGhlIGZ1bGwgdXJsIHdpdGggcXVlcnkgc3RyaW5nXG4gKiBAcGFyYW0ge2FueT19IGRhdGEgdGhlIHBheWxvYWQgb3IgdGhlIHJlcXVlc3QsIG9yIHRoZSBQT1NUIHF1ZXJ5c3RyaW5nXG4gKiBAcGFyYW0ge1R5cGVkTWFwPHN0cmluZz49fSBoZWFkZXJzIHRoZSBvdXRwYm91bmQgcmVxdWVzdCBoZWFkZXJzIG1hcFxuICovXG5leHBvcnQgdHlwZSBCYWNrZW5kUmVzcG9uZCA9XG4gICAgfCBQYXlsb2FkXG4gICAgfCBQYXlsb2FkW11cbiAgICB8ICgoXG4gICAgICAgICAgbWV0aG9kPzogc3RyaW5nLFxuICAgICAgICAgIHVybD86IHN0cmluZyxcbiAgICAgICAgICBkYXRhPzogYW55LFxuICAgICAgICAgIGhlYWRlcnM/OiBUeXBlZE1hcDxzdHJpbmc+XG4gICAgICApID0+IFtudW1iZXIsIFBheWxvYWQgfCBQYXlsb2FkW11dIHwgUHJvbWlzZUxpa2U8W251bWJlciwgUGF5bG9hZCB8IFBheWxvYWRbXV0+KTtcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5XG4gKiBAZGVzY3JpcHRpb25cbiAqIEludm9jYXRpb25zIG9mIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2V9IHdoZW4sIHdoZW5HRVQsIHdoZW5QT1NULCB3aGVuUFVULCB3aGVuREVMRVRFXG4gKiBhbGwgcmV0dXJuIGFuIGluc3RhbmNlIG9mIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpCYWNrZW5kRW50cnkgQmFja2VuZEVudHJ5fVxuICogSXQgaXMgdXNlZCB0byBzcGVjaWZ5IHRoZSBtb2NrZWQgcmVzcG9uc2UgZm9yIHRoZSBnaXZlbiBjb25kaXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgQmFja2VuZEVudHJ5IHtcbiAgICBtb2NrPzogQmFja2VuZFJlc3BvbmQ7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcGF0dGVybjogc3RyaW5nIHwgUmVnRXhwLCBwdWJsaWMgbWF0Y2hpbmdQYXlsb2FkPzogQ2xvbmVhYmxlKSB7fVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSNyZXNwb25kXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7QmFja2VuZFJlc3BvbmR9IG1vY2sgdGhlIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6QmFja2VuZFJlc3BvbmR9IHRvIHJldHVybiBmb3IgdGhlIGdpdmVuIGNvbmRpdGlvbnNcbiAgICAgKi9cbiAgICByZXNwb25kKG1vY2s6IEJhY2tlbmRSZXNwb25kKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgdGhpcy5tb2NrID0gbW9jaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcGFzc1Rocm91Z2goKTogdm9pZCB7XG4gICAgICAgIC8vXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmRFbnRyeU1hcCB7XG4gICAgW2luZGV4OiBzdHJpbmddOiBCYWNrZW5kRW50cnlbXTtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlcnZpY2UgYWltZWQgdG8gcHJvdmlkZSBtb2NrZWQgYmFja2VuZCByZXNwb25zZXMgZm9yIGdpdmVuIGh0dHAgcmVxdWVzdCBwYXR0ZXJucy5cbiAqIEl0IGZvbGxvd3MgdGhlIEFQSSBvZiB7QGxpbmsgaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nTW9ja0UyRS9zZXJ2aWNlLyRodHRwQmFja2VuZCAkaHR0cEJhY2tlbmR9XG4gKiBtaW51cyBhIGZldyBsaW1pdGF0aW9uc1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSHR0cEJhY2tlbmRTZXJ2aWNlIHtcbiAgICBwcml2YXRlIG1hdGNoTGF0ZXN0RGVmaW5pdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBiYWNrZW5kczogQmFja2VuZEVudHJ5TWFwID0ge1xuICAgICAgICBHRVQ6IFtdLFxuICAgICAgICBQT1NUOiBbXSxcbiAgICAgICAgUFVUOiBbXSxcbiAgICAgICAgREVMRVRFOiBbXVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI3doZW5HRVRcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogbWV0aG9kIHNpbWlsYXIgdG8ge0BsaW5rIGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZ01vY2tFMkUvc2VydmljZS8kaHR0cEJhY2tlbmQjd2hlbkdFVCAkaHR0cEJhY2tlbmQjd2hlbkdFVH1cbiAgICAgKiBidXQgd2l0aCBvbmx5IHRoZSB1cmwgcGF0dGVybiBhcyBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcGF0dGVybiB1cmwgZW5kIG9mIHRoZSB1cmwgcGF0dGVybiB0byBtYXRjaFxuICAgICAqIEByZXR1cm5zIHtCYWNrZW5kRW50cnl9IHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IGJhY2tlbkVudHJ5fVxuICAgICAqL1xuICAgIHdoZW5HRVQocGF0dGVybjogc3RyaW5nIHwgUmVnRXhwKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZW5NZXRob2QoJ0dFVCcsIHBhdHRlcm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI3doZW5QT1NUXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI3doZW5QT1NUICRodHRwQmFja2VuZCN3aGVuUE9TVH1cbiAgICAgKiBidXQgd2l0aCBvbmx5IHRoZSBmaXJzdCAyIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBwYXR0ZXJuIHVybCBlbmQgb2YgdGhlIHVybCBwYXR0ZXJuIHRvIG1hdGNoXG4gICAgICogQHBhcmFtIHtDbG9lbmFibGU9fSBtYXRjaGluZ1BheWxvYWQgSFRUUCByZXF1ZXN0IGJvZHkgdG8gYmUgbWF0Y2hlZFxuICAgICAqIEByZXR1cm5zIHtCYWNrZW5kRW50cnl9IHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IGJhY2tlbkVudHJ5fVxuICAgICAqL1xuICAgIHdoZW5QT1NUKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCwgbWF0Y2hpbmdQYXlsb2FkPzogQ2xvbmVhYmxlKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZW5NZXRob2QoJ1BPU1QnLCBwYXR0ZXJuLCBtYXRjaGluZ1BheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI3doZW5QVVRcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogbWV0aG9kIHNpbWlsYXIgdG8ge0BsaW5rIGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZ01vY2tFMkUvc2VydmljZS8kaHR0cEJhY2tlbmQjd2hlblBVVCAkaHR0cEJhY2tlbmQjd2hlblBVVH1cbiAgICAgKiBidXQgd2l0aCBvbmx5IHRoZSBmaXJzdCAyIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBwYXR0ZXJuIHVybCBlbmQgb2YgdGhlIHVybCBwYXR0ZXJuIHRvIG1hdGNoXG4gICAgICogQHBhcmFtIHtDbG9lbmFibGU9fSBtYXRjaGluZ1BheWxvYWQgSFRUUCByZXF1ZXN0IGJvZHkgdG8gYmUgbWF0Y2hlZFxuICAgICAqIEByZXR1cm5zIHtCYWNrZW5kRW50cnl9IHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IGJhY2tlbkVudHJ5fVxuICAgICAqL1xuICAgIHdoZW5QVVQocGF0dGVybjogc3RyaW5nIHwgUmVnRXhwLCBtYXRjaGluZ1BheWxvYWQ/OiBDbG9uZWFibGUpOiBCYWNrZW5kRW50cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2hlbk1ldGhvZCgnUFVUJywgcGF0dGVybiwgbWF0Y2hpbmdQYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuUFVUXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI3doZW5QVVQgJGh0dHBCYWNrZW5kI3doZW5QVVR9XG4gICAgICogYnV0IHdpdGggb25seSB0aGUgdXJsIHBhdHRlcm4gYXMgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IHBhdHRlcm4gdXJsIGVuZCBvZiB0aGUgdXJsIHBhdHRlcm4gdG8gbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7QmFja2VuZEVudHJ5fSB0aGUge0BsaW5rIEBzbWFydHV0aWxzLnNlcnZpY2VzOkJhY2tlbmRFbnRyeSBiYWNrZW5FbnRyeX1cbiAgICAgKi9cbiAgICB3aGVuREVMRVRFKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuTWV0aG9kKCdERUxFVEUnLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZSN3aGVuXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkh0dHBCYWNrZW5kU2VydmljZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIG1ldGhvZCBzaW1pbGFyIHRvIHtAbGluayBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrRTJFL3NlcnZpY2UvJGh0dHBCYWNrZW5kI3doZW4gJGh0dHBCYWNrZW5kI3doZW59XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBHRVQsIFBPU1QsIFBVVCwgb3IgREVMRVRFXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IHBhdHRlcm4gdXJsIGVuZCBvZiB0aGUgdXJsIHBhdHRlcm4gdG8gbWF0Y2hcbiAgICAgKiBAcGFyYW0ge0Nsb2VuYWJsZT19IG1hdGNoaW5nUGF5bG9hZCBIVFRQIHJlcXVlc3QgYm9keSB0byBiZSBtYXRjaGVkXG4gICAgICogQHJldHVybnMge0JhY2tlbmRFbnRyeX0gdGhlIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpCYWNrZW5kRW50cnkgYmFja2VuRW50cnl9XG4gICAgICovXG4gICAgd2hlbihtZXRob2Q6IFJFU1RNRVRIT0QsIHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCwgbWF0Y2hpbmdQYXlsb2FkPzogQ2xvbmVhYmxlKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZW5NZXRob2QobWV0aG9kLCBwYXR0ZXJuLCBtYXRjaGluZ1BheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI3doZW5Bc3luY1xuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBtZXRob2Qgc2ltaWxhciB0byBsZWdhY3kgJGh0dHBCYWNrZW5kI3doZW5Bc3luYywgdXNlIHtAbGluayBAc21hcnR1dGlscy5zZXJ2aWNlczpIdHRwQmFja2VuZFNlcnZpY2Ujd2hlbiBIdHRwQmFja2VuZFNlcnZpY2Ujd2hlbn0gaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgR0VULCBQT1NULCBQVVQsIG9yIERFTEVURVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBwYXR0ZXJuIHVybCBlbmQgb2YgdGhlIHVybCBwYXR0ZXJuIHRvIG1hdGNoXG4gICAgICogQHBhcmFtIHtDbG9lbmFibGU9fSBtYXRjaGluZ1BheWxvYWQgSFRUUCByZXF1ZXN0IGJvZHkgdG8gYmUgbWF0Y2hlZFxuICAgICAqIEByZXR1cm5zIHtCYWNrZW5kRW50cnl9IHRoZSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QmFja2VuZEVudHJ5IGJhY2tlbkVudHJ5fVxuICAgICAqL1xuICAgIHdoZW5Bc3luYyhcbiAgICAgICAgbWV0aG9kOiBSRVNUTUVUSE9ELFxuICAgICAgICBwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHAsXG4gICAgICAgIG1hdGNoaW5nUGF5bG9hZD86IENsb25lYWJsZVxuICAgICk6IEJhY2tlbmRFbnRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuTWV0aG9kKG1ldGhvZCwgcGF0dGVybiwgbWF0Y2hpbmdQYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlI21hdGNoTGF0ZXN0RGVmaW5pdGlvbkVuYWJsZWRcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6SHR0cEJhY2tlbmRTZXJ2aWNlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogbWV0aG9kIHNpbWlsYXIgdG8ge0BsaW5rIGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZ01vY2tFMkUvc2VydmljZS8kaHR0cEJhY2tlbmQjbWF0Y2hMYXRlc3REZWZpbml0aW9uRW5hYmxlZCAkaHR0cEJhY2tlbmQjbWF0Y2hMYXRlc3REZWZpbml0aW9uRW5hYmxlZH1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49ZmFsc2V9IG1hdGNoTGF0ZXN0RGVmaW5pdGlvbkVuYWJsZWQgaWYgdHJ1ZSwgdGhlIGxhc3QgbWF0Y2hpbmcgcGF0dGVybiB3aWxsIGJlIHBpY2tlZC4gT3RoZXJ3aXNlIHRoZSBmaXJzdCBpcyBwaWNrZWRcbiAgICAgKi9cbiAgICBtYXRjaExhdGVzdERlZmluaXRpb25FbmFibGVkKG1hdGNoTGF0ZXN0RGVmaW5pdGlvbkVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5tYXRjaExhdGVzdERlZmluaXRpb24gPSBtYXRjaExhdGVzdERlZmluaXRpb25FbmFibGVkO1xuICAgIH1cblxuICAgIC8vIHdoZW5Bc3luY1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgZmluZE1hdGNoaW5nTW9jayhyZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+KTogQmFja2VuZFJlc3BvbmQgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBiYWNrZW5kRW50cnkgPSAodGhpcy5tYXRjaExhdGVzdERlZmluaXRpb25cbiAgICAgICAgICAgID8gdGhpcy5iYWNrZW5kc1tyZXF1ZXN0Lm1ldGhvZF0uc2xpY2UoKS5yZXZlcnNlKClcbiAgICAgICAgICAgIDogdGhpcy5iYWNrZW5kc1tyZXF1ZXN0Lm1ldGhvZF1cbiAgICAgICAgKS5maW5kKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeS5wYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QudXJsV2l0aFBhcmFtcy5lbmRzV2l0aChlbnRyeS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoaW5nUGF5bG9hZFJlc3RyaWN0aW9uKGVudHJ5LCByZXF1ZXN0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPVxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wYXR0ZXJuLnRlc3QocmVxdWVzdC51cmxXaXRoUGFyYW1zKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoaW5nUGF5bG9hZFJlc3RyaWN0aW9uKGVudHJ5LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBlbnRyeS5wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBiYWNrZW5kRW50cnkgPyBiYWNrZW5kRW50cnkubW9jayA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF93aGVuTWV0aG9kKFxuICAgICAgICBtZXRob2Q6IFJFU1RNRVRIT0QsXG4gICAgICAgIHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCxcbiAgICAgICAgbWF0Y2hpbmdQYXlsb2FkPzogQ2xvbmVhYmxlXG4gICAgKTogQmFja2VuZEVudHJ5IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgQmFja2VuZEVudHJ5KHBhdHRlcm4sIG1hdGNoaW5nUGF5bG9hZCk7XG4gICAgICAgIHRoaXMuYmFja2VuZHNbbWV0aG9kXS5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cblxuICAgIHByaXZhdGUgbWF0Y2hpbmdQYXlsb2FkUmVzdHJpY3Rpb24oZW50cnk6IEJhY2tlbmRFbnRyeSwgcmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZW50cnkubWF0Y2hpbmdQYXlsb2FkID8gbG9kYXNoLmlzRXF1YWwoZW50cnkubWF0Y2hpbmdQYXlsb2FkLCByZXF1ZXN0LmJvZHkpIDogdHJ1ZTtcbiAgICB9XG59XG4iXX0=