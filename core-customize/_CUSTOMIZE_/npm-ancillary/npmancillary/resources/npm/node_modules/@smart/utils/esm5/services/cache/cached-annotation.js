/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import { annotationService } from '../annotation.service';
import * as lo from 'lodash';
import { functionsUtils } from '../../utils';
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// CACHE CONFIG ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
var cacheConfigAnnotationName = 'CacheConfig';
/**
 * @ngdoc object
 * @name @smartutils.object:@CacheConfig
 * @description
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for setting
 *  class level cache configuration to be merged into method specific {@link @smartutils.object:@Cached @Cached} and
 *  {@link @smartutils.object:@InvalidateCache @InvalidateCache} configurations.
 * @param {object} cacheConfig the configuration fo this cache
 * @param {cacheAction} cacheConfig.actions the list of {@link @smartutils.object:CacheAction CacheAction} characterizing this cache.
 * @param {EvictionTag[]} cacheConfig.tags a list of {@link @smartutils.object:EvictionTag EvictionTag} to control the eviction behaviour of this cache.
 */
export var CacheConfig = annotationService.getClassAnnotationFactory(cacheConfigAnnotationName);
export function CacheConfigAnnotationFactory(logService) {
    'ngInject';
    return annotationService.setClassAnnotationFactory(cacheConfigAnnotationName, function (factoryArguments) {
        return function (instance, originalConstructor, invocationArguments) {
            originalConstructor.call.apply(originalConstructor, tslib_1.__spread([instance], invocationArguments));
            instance.cacheConfig = factoryArguments[0];
            logService.debug("adding cache config " + JSON.stringify(instance.cacheConfig) + " to class " + functionsUtils.getInstanceConstructorName(instance), instance);
        };
    });
}
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// CACHE ////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
var CachedAnnotationName = 'Cached';
/**
 * @ngdoc object
 * @name @smartutils.object:@Cached
 * @description
 * Method level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for performing
 * invocation arguments sensitive method caching.
 * <br/> This annotation must only be used on methods returning promises.
 * @param {object} cacheConfig the configuration fo this cache
 * <br/> This configuration will be merged with a class level {@link @smartutils.object:@CacheConfig @acheConfig} if any.
 * @throws if no {@link @smartutils.object:CacheAction CacheAction} is found in the resulting merge
 * @param {cacheAction} cacheConfig.actions the list of {@link @smartutils.object:CacheAction CacheAction} characterizing this cache.
 * @param {EvictionTag[]} cacheConfig.tags a list of {@link @smartutils.object:EvictionTag EvictionTag} to control the eviction behaviour of this cache.
 */
export var Cached = annotationService.getMethodAnnotationFactory(CachedAnnotationName);
export function CachedAnnotationFactory(cacheService) {
    'ngInject';
    var result = annotationService.setMethodAnnotationFactory(CachedAnnotationName, function (factoryArguments) {
        return function (target, propertyName, originalMethod, invocationArguments) {
            var actions = [];
            var tags = [];
            if (factoryArguments[0]) {
                actions = factoryArguments[0].actions;
                tags = factoryArguments[0].tags;
            }
            if (target.cacheConfig) {
                if (target.cacheConfig.actions) {
                    actions = lo.uniq(actions.concat(target.cacheConfig.actions));
                }
                if (target.cacheConfig.tags) {
                    tags = lo.uniq(tags.concat(target.cacheConfig.tags));
                }
            }
            if (!actions.length) {
                var constructorName = functionsUtils.getInstanceConstructorName(target);
                throw new Error("method " + propertyName + " of " + constructorName + " is @Cached annotated but no CacheAction is specified either through @Cached or through class level @CacheConfig annotation");
            }
            return cacheService.handle(target, propertyName, originalMethod, Array.prototype.slice.apply(invocationArguments), actions, tags);
        };
    });
    return result;
}
///////////////////////////////////////////////////////////////////////////////
////////////////////////////// INVALIDATE CACHE ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////
var InvalidateCacheName = 'InvalidateCache';
/**
 * @ngdoc object
 * @name @smartutils.object:@InvalidateCache
 * @description
 * Method level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for
 * invalidating all caches either directly or indirectly declaring the {@link @smartutils.object:EvictionTag eviction tag} passed as argument.
 * if no eviction tag is passed as argument, defaults to the optional eviction tags passed to the class through {@link @smartutils.object:@CacheConfig @CacheConfig}.
 *
 * @param {EvictionTag} evictionTag the {@link @smartutils.object:EvictionTag eviction tag}.
 */
export var InvalidateCache = function (tag) {
    return annotationService.getMethodAnnotationFactory(InvalidateCacheName)(tag);
};
export function InvalidateCacheAnnotationFactory(cacheService) {
    'ngInject';
    return annotationService.setMethodAnnotationFactory(InvalidateCacheName, function (factoryArguments) {
        return function (target, propertyName, originalMethod, invocationArguments) {
            var tags = [];
            var tag = factoryArguments[0];
            if (!tag) {
                if (target.cacheConfig && target.cacheConfig.tags) {
                    tags = target.cacheConfig.tags;
                }
            }
            else {
                tags = [tag];
            }
            if (!tags.length) {
                throw new Error("method " + propertyName + " of " + target.constructor.name + " is @InvalidateCache annotated but no EvictionTag is specified either through @InvalidateCache or through class level @CacheConfig annotation");
            }
            var returnedObject = originalMethod.apply(undefined, Array.prototype.slice.call(invocationArguments));
            if (returnedObject && returnedObject.then) {
                return returnedObject.then(function (value) {
                    cacheService.evict.apply(cacheService, tslib_1.__spread(tags));
                    return value;
                });
            }
            else {
                cacheService.evict.apply(cacheService, tslib_1.__spread(tags));
                return returnedObject;
            }
        };
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGVkLWFubm90YXRpb24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac21hcnQvdXRpbHMvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9jYWNoZS9jYWNoZWQtYW5ub3RhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHO0FBQ0gsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFJMUQsT0FBTyxLQUFLLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDN0IsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUc3QywrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLCtFQUErRTtBQUUvRSxJQUFNLHlCQUF5QixHQUFHLGFBQWEsQ0FBQztBQUVoRDs7Ozs7Ozs7OztHQVVHO0FBRUgsTUFBTSxDQUFDLElBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLHlCQUF5QixDQUNsRSx5QkFBeUIsQ0FDbUQsQ0FBQztBQUVqRixNQUFNLFVBQVUsNEJBQTRCLENBQUMsVUFBc0I7SUFDL0QsVUFBVSxDQUFDO0lBQ1gsT0FBTyxpQkFBaUIsQ0FBQyx5QkFBeUIsQ0FDOUMseUJBQXlCLEVBQ3pCLFVBQUMsZ0JBQW9FO1FBQ2pFLE9BQU8sVUFDSCxRQUFhLEVBQ2IsbUJBQXlDLEVBQ3pDLG1CQUEwQjtZQUUxQixtQkFBbUIsQ0FBQyxJQUFJLE9BQXhCLG1CQUFtQixvQkFBTSxRQUFRLEdBQUssbUJBQW1CLEdBQUU7WUFFM0QsUUFBUSxDQUFDLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUUzQyxVQUFVLENBQUMsS0FBSyxDQUNaLHlCQUF1QixJQUFJLENBQUMsU0FBUyxDQUNqQyxRQUFRLENBQUMsV0FBVyxDQUN2QixrQkFBYSxjQUFjLENBQUMsMEJBQTBCLENBQUMsUUFBUSxDQUFHLEVBQ25FLFFBQVEsQ0FDWCxDQUFDO1FBQ04sQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUNKLENBQUM7QUFDTixDQUFD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SUFBSSxFQUFFO29CQUMvQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7aUJBQ2xDO2FBQ0o7aUJBQU07Z0JBQ0gsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDaEI7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZCxNQUFNLElBQUksS0FBSyxDQUNYLFlBQVUsWUFBWSxZQUNsQixNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksa0pBQ29ILENBQ2xKLENBQUM7YUFDTDtZQUVELElBQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQ3ZDLFNBQVMsRUFDVCxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FDbEQsQ0FBQztZQUNGLElBQUksY0FBYyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEVBQUU7Z0JBQ3ZDLE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxVQUFDLEtBQVU7b0JBQ2xDLFlBQVksQ0FBQyxLQUFLLE9BQWxCLFlBQVksbUJBQVUsSUFBSSxHQUFFO29CQUM1QixPQUFPLEtBQUssQ0FBQztnQkFDakIsQ0FBQyxDQUFDLENBQUM7YUFDTjtpQkFBTTtnQkFDSCxZQUFZLENBQUMsS0FBSyxPQUFsQixZQUFZLG1CQUFVLElBQUksR0FBRTtnQkFDNUIsT0FBTyxjQUFjLENBQUM7YUFDekI7UUFDTCxDQUFDLENBQUM7SUFDTixDQUFDLENBQ0osQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCB7IGFubm90YXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vYW5ub3RhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENhY2hlQWN0aW9uIH0gZnJvbSAnLi9jYWNoZS1hY3Rpb24nO1xuaW1wb3J0IHsgRXZpY3Rpb25UYWcgfSBmcm9tICcuL2V2aWN0aW9uLXRhZyc7XG5pbXBvcnQgeyBDYWNoZVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlLnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgbG8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZ1bmN0aW9uc1V0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENBQ0hFIENPTkZJRyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBjYWNoZUNvbmZpZ0Fubm90YXRpb25OYW1lID0gJ0NhY2hlQ29uZmlnJztcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlQ29uZmlnXG4gKiBAZGVzY3JpcHRpb25cbiAqIENsYXNzIGxldmVsIHR5cGVzY3JpcHQge0BsaW5rIGh0dHA6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1sIGRlY29yYXRvciBmYWN0b3J5fSByZXNwb25zaWJsZSBmb3Igc2V0dGluZ1xuICogIGNsYXNzIGxldmVsIGNhY2hlIGNvbmZpZ3VyYXRpb24gdG8gYmUgbWVyZ2VkIGludG8gbWV0aG9kIHNwZWNpZmljIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlZCBAQ2FjaGVkfSBhbmRcbiAqICB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkBJbnZhbGlkYXRlQ2FjaGUgQEludmFsaWRhdGVDYWNoZX0gY29uZmlndXJhdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVDb25maWcgdGhlIGNvbmZpZ3VyYXRpb24gZm8gdGhpcyBjYWNoZVxuICogQHBhcmFtIHtjYWNoZUFjdGlvbn0gY2FjaGVDb25maWcuYWN0aW9ucyB0aGUgbGlzdCBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNhY2hlQWN0aW9uIENhY2hlQWN0aW9ufSBjaGFyYWN0ZXJpemluZyB0aGlzIGNhY2hlLlxuICogQHBhcmFtIHtFdmljdGlvblRhZ1tdfSBjYWNoZUNvbmZpZy50YWdzIGEgbGlzdCBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkV2aWN0aW9uVGFnIEV2aWN0aW9uVGFnfSB0byBjb250cm9sIHRoZSBldmljdGlvbiBiZWhhdmlvdXIgb2YgdGhpcyBjYWNoZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgQ2FjaGVDb25maWcgPSBhbm5vdGF0aW9uU2VydmljZS5nZXRDbGFzc0Fubm90YXRpb25GYWN0b3J5KFxuICAgIGNhY2hlQ29uZmlnQW5ub3RhdGlvbk5hbWVcbikgYXMgKGFyZ3M6IHsgYWN0aW9ucz86IENhY2hlQWN0aW9uW107IHRhZ3M/OiBFdmljdGlvblRhZ1tdIH0pID0+IENsYXNzRGVjb3JhdG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FjaGVDb25maWdBbm5vdGF0aW9uRmFjdG9yeShsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgJ25nSW5qZWN0JztcbiAgICByZXR1cm4gYW5ub3RhdGlvblNlcnZpY2Uuc2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeShcbiAgICAgICAgY2FjaGVDb25maWdBbm5vdGF0aW9uTmFtZSxcbiAgICAgICAgKGZhY3RvcnlBcmd1bWVudHM6IFt7IGFjdGlvbnM6IENhY2hlQWN0aW9uW107IHRhZ3M/OiBFdmljdGlvblRhZ1tdIH1dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGFueSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnN0cnVjdG9yOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uQXJndW1lbnRzOiBhbnlbXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCAuLi5pbnZvY2F0aW9uQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNhY2hlQ29uZmlnID0gZmFjdG9yeUFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgICAgIGxvZ1NlcnZpY2UuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIGBhZGRpbmcgY2FjaGUgY29uZmlnICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jYWNoZUNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICApfSB0byBjbGFzcyAke2Z1bmN0aW9uc1V0aWxzLmdldEluc3RhbmNlQ29uc3RydWN0b3JOYW1lKGluc3RhbmNlKX1gLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENBQ0hFIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBDYWNoZWRBbm5vdGF0aW9uTmFtZSA9ICdDYWNoZWQnO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpAQ2FjaGVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1ldGhvZCBsZXZlbCB0eXBlc2NyaXB0IHtAbGluayBodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBkZWNvcmF0b3IgZmFjdG9yeX0gcmVzcG9uc2libGUgZm9yIHBlcmZvcm1pbmdcbiAqIGludm9jYXRpb24gYXJndW1lbnRzIHNlbnNpdGl2ZSBtZXRob2QgY2FjaGluZy5cbiAqIDxici8+IFRoaXMgYW5ub3RhdGlvbiBtdXN0IG9ubHkgYmUgdXNlZCBvbiBtZXRob2RzIHJldHVybmluZyBwcm9taXNlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZUNvbmZpZyB0aGUgY29uZmlndXJhdGlvbiBmbyB0aGlzIGNhY2hlXG4gKiA8YnIvPiBUaGlzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBhIGNsYXNzIGxldmVsIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlQ29uZmlnIEBhY2hlQ29uZmlnfSBpZiBhbnkuXG4gKiBAdGhyb3dzIGlmIG5vIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2FjaGVBY3Rpb24gQ2FjaGVBY3Rpb259IGlzIGZvdW5kIGluIHRoZSByZXN1bHRpbmcgbWVyZ2VcbiAqIEBwYXJhbSB7Y2FjaGVBY3Rpb259IGNhY2hlQ29uZmlnLmFjdGlvbnMgdGhlIGxpc3Qgb2Yge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDYWNoZUFjdGlvbiBDYWNoZUFjdGlvbn0gY2hhcmFjdGVyaXppbmcgdGhpcyBjYWNoZS5cbiAqIEBwYXJhbSB7RXZpY3Rpb25UYWdbXX0gY2FjaGVDb25maWcudGFncyBhIGxpc3Qgb2Yge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpFdmljdGlvblRhZyBFdmljdGlvblRhZ30gdG8gY29udHJvbCB0aGUgZXZpY3Rpb24gYmVoYXZpb3VyIG9mIHRoaXMgY2FjaGUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IENhY2hlZCA9IGFubm90YXRpb25TZXJ2aWNlLmdldE1ldGhvZEFubm90YXRpb25GYWN0b3J5KFxuICAgIENhY2hlZEFubm90YXRpb25OYW1lXG4pIGFzIChhcmdzPzogeyBhY3Rpb25zOiBDYWNoZUFjdGlvbltdOyB0YWdzPzogRXZpY3Rpb25UYWdbXSB9KSA9PiBNZXRob2REZWNvcmF0b3I7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYWNoZWRBbm5vdGF0aW9uRmFjdG9yeShjYWNoZVNlcnZpY2U6IENhY2hlU2VydmljZSkge1xuICAgICduZ0luamVjdCc7XG4gICAgY29uc3QgcmVzdWx0ID0gYW5ub3RhdGlvblNlcnZpY2Uuc2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkoXG4gICAgICAgIENhY2hlZEFubm90YXRpb25OYW1lLFxuICAgICAgICAoZmFjdG9yeUFyZ3VtZW50czogW3sgYWN0aW9uczogQ2FjaGVBY3Rpb25bXTsgdGFnczogRXZpY3Rpb25UYWdbXSB9XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHRhcmdldDogYW55LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uQXJndW1lbnRzOiBJQXJndW1lbnRzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aW9uczogQ2FjaGVBY3Rpb25bXSA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB0YWdzOiBFdmljdGlvblRhZ1tdID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoZmFjdG9yeUFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gZmFjdG9yeUFyZ3VtZW50c1swXS5hY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gZmFjdG9yeUFyZ3VtZW50c1swXS50YWdzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FjaGVDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jYWNoZUNvbmZpZy5hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gbG8udW5pcShhY3Rpb25zLmNvbmNhdCh0YXJnZXQuY2FjaGVDb25maWcuYWN0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FjaGVDb25maWcudGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncyA9IGxvLnVuaXEodGFncy5jb25jYXQodGFyZ2V0LmNhY2hlQ29uZmlnLnRhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gZnVuY3Rpb25zVXRpbHMuZ2V0SW5zdGFuY2VDb25zdHJ1Y3Rvck5hbWUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYG1ldGhvZCAke3Byb3BlcnR5TmFtZX0gb2YgJHtjb25zdHJ1Y3Rvck5hbWV9IGlzIEBDYWNoZWQgYW5ub3RhdGVkIGJ1dCBubyBDYWNoZUFjdGlvbiBpcyBzcGVjaWZpZWQgZWl0aGVyIHRocm91Z2ggQENhY2hlZCBvciB0aHJvdWdoIGNsYXNzIGxldmVsIEBDYWNoZUNvbmZpZyBhbm5vdGF0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVTZXJ2aWNlLmhhbmRsZShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoaW52b2NhdGlvbkFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIElOVkFMSURBVEUgQ0FDSEUgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBJbnZhbGlkYXRlQ2FjaGVOYW1lID0gJ0ludmFsaWRhdGVDYWNoZSc7XG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpASW52YWxpZGF0ZUNhY2hlXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1ldGhvZCBsZXZlbCB0eXBlc2NyaXB0IHtAbGluayBodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBkZWNvcmF0b3IgZmFjdG9yeX0gcmVzcG9uc2libGUgZm9yXG4gKiBpbnZhbGlkYXRpbmcgYWxsIGNhY2hlcyBlaXRoZXIgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBkZWNsYXJpbmcgdGhlIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6RXZpY3Rpb25UYWcgZXZpY3Rpb24gdGFnfSBwYXNzZWQgYXMgYXJndW1lbnQuXG4gKiBpZiBubyBldmljdGlvbiB0YWcgaXMgcGFzc2VkIGFzIGFyZ3VtZW50LCBkZWZhdWx0cyB0byB0aGUgb3B0aW9uYWwgZXZpY3Rpb24gdGFncyBwYXNzZWQgdG8gdGhlIGNsYXNzIHRocm91Z2gge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpAQ2FjaGVDb25maWcgQENhY2hlQ29uZmlnfS5cbiAqXG4gKiBAcGFyYW0ge0V2aWN0aW9uVGFnfSBldmljdGlvblRhZyB0aGUge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpFdmljdGlvblRhZyBldmljdGlvbiB0YWd9LlxuICovXG5cbmV4cG9ydCBjb25zdCBJbnZhbGlkYXRlQ2FjaGUgPSBmdW5jdGlvbih0YWc/OiBFdmljdGlvblRhZykge1xuICAgIHJldHVybiBhbm5vdGF0aW9uU2VydmljZS5nZXRNZXRob2RBbm5vdGF0aW9uRmFjdG9yeShJbnZhbGlkYXRlQ2FjaGVOYW1lKSh0YWcpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludmFsaWRhdGVDYWNoZUFubm90YXRpb25GYWN0b3J5KGNhY2hlU2VydmljZTogQ2FjaGVTZXJ2aWNlKSB7XG4gICAgJ25nSW5qZWN0JztcbiAgICByZXR1cm4gYW5ub3RhdGlvblNlcnZpY2Uuc2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkoXG4gICAgICAgIEludmFsaWRhdGVDYWNoZU5hbWUsXG4gICAgICAgIChmYWN0b3J5QXJndW1lbnRzOiBbRXZpY3Rpb25UYWddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2Q6ICguLi54OiBhbnlbXSkgPT4gYW55LFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25Bcmd1bWVudHM6IElBcmd1bWVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCB0YWdzOiBFdmljdGlvblRhZ1tdID0gW107XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YWc6IEV2aWN0aW9uVGFnID0gZmFjdG9yeUFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNhY2hlQ29uZmlnICYmIHRhcmdldC5jYWNoZUNvbmZpZy50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzID0gdGFyZ2V0LmNhY2hlQ29uZmlnLnRhZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gW3RhZ107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgbWV0aG9kICR7cHJvcGVydHlOYW1lfSBvZiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGlzIEBJbnZhbGlkYXRlQ2FjaGUgYW5ub3RhdGVkIGJ1dCBubyBFdmljdGlvblRhZyBpcyBzcGVjaWZpZWQgZWl0aGVyIHRocm91Z2ggQEludmFsaWRhdGVDYWNoZSBvciB0aHJvdWdoIGNsYXNzIGxldmVsIEBDYWNoZUNvbmZpZyBhbm5vdGF0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkT2JqZWN0ID0gb3JpZ2luYWxNZXRob2QuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW52b2NhdGlvbkFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZE9iamVjdCAmJiByZXR1cm5lZE9iamVjdC50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZE9iamVjdC50aGVuKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVNlcnZpY2UuZXZpY3QoLi4udGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlU2VydmljZS5ldmljdCguLi50YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICApO1xufVxuIl19