/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as lo from 'lodash';
/**
 * @ngdoc service
 * @name @smartutils.services:FunctionsUtils
 *
 * @description
 * utility service around Functions.
 */
var FunctionsUtils = /** @class */ (function () {
    function FunctionsUtils() {
        /*
         * regexp matching function(a, $b){} and function MyFunction(a, $b){}
         */
        this.signatureArgsRegexp = /function[\s\w]*\(([\w\s\$,]*)\)[\s]*{/;
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#isEmpty
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Will determine whether a function body is empty or should be considered empty for proxying purposes
     *
     * @param {Function} func, the function to evaluate
     * @returns {Boolean} a boolean.
     */
    FunctionsUtils.prototype.isEmpty = function (func) {
        var match = func.toString().match(/\{([\s\S]*)\}/m);
        return (!match ||
            match[1].trim() === '' ||
            /(proxyFunction)/g.test(func.toString().replace(/\s/g, '')));
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#getArguments
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Returns the array of string arguments of the given function signature
     *
     * @param {Function} func the function to analyze
     * @returns {string[]} an array of string arguments
     */
    FunctionsUtils.prototype.getArguments = function (func) {
        var exec = this.signatureArgsRegexp.exec(func.toString());
        if (exec) {
            return exec[1].replace(/\s/g, '').split(',');
        }
        else {
            throw new Error("failed to retrieve arguments list of " + func);
        }
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#hasArguments
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Determines whether a given function (anonymous or not) has arguments in it signature
     *
     * @param {Function} func the function to analyze
     * @returns {boolean} true if the function has signature arguments
     */
    FunctionsUtils.prototype.hasArguments = function (func) {
        var exec = this.signatureArgsRegexp.exec(func.toString());
        if (exec) {
            return !lo.isEmpty(exec[1]);
        }
        else {
            throw new Error("failed to retrieve arguments list of " + func);
        }
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#getConstructorName
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Returns the constructor name in a cross browser fashion
     *
     * @param {Function} func the function to analyze
     * @returns {string} the constructor name
     */
    FunctionsUtils.prototype.getConstructorName = function (func) {
        var name = func.name;
        if (!name) {
            // IE does not support constructor.name
            var exec = /function (\$?\w+)\s*\(/.exec(func.toString());
            if (exec) {
                name = exec[1];
            }
            else {
                throw new Error('[FunctionsUtils] - Cannot get name from invalid constructor.');
            }
        }
        return name;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#getInstanceConstructorName
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Returns the constructor name in a cross browser fashion of a class instance
     *
     * @param {Object} instance instance class to analyze
     * @returns {string} the constructor name of the instance
     */
    FunctionsUtils.prototype.getInstanceConstructorName = function (instance) {
        return this.getConstructorName(Object.getPrototypeOf(instance).constructor);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:FunctionsUtils#extendsConstructor
     * @methodOf @smartutils.services:FunctionsUtils
     *
     * @description
     * Overrides a given constructor with a new constructor body. The resulting constructor will share the same prototype as the original one.
     *
     * @param {(...args:any[]) => T} originalConstructor the original constructor to override
     * @returns {(...args:any[]) => T} newConstructorBody the new constructor body to execute in the override. It may or may not return an instance. Should it return an instance, the latter will be returned by the override.
     */
    FunctionsUtils.prototype.extendsConstructor = function (originalConstructor, newConstructorBody) {
        // the new constructor behaviour
        var newConstructor = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = newConstructorBody.apply(this, args);
            if (result) {
                return result;
            }
        };
        // copy prototype so intanceof operator still works
        newConstructor.prototype = originalConstructor.prototype;
        return newConstructor;
    };
    /** @internal */
    FunctionsUtils.prototype.isUnitTestMode = function () {
        /* forbiddenNameSpaces window._:false */
        return typeof window.__karma__ !== 'undefined';
    };
    FunctionsUtils.prototype.convertToArray = function (obj) {
        return Object.keys(obj).reduce(function (acc, key) { return tslib_1.__spread((acc || []), [
            { key: key, value: obj[key] }
        ]); }, []);
    };
    return FunctionsUtils;
}());
export { FunctionsUtils };
export var functionsUtils = new FunctionsUtils();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25zLXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsidXRpbHMvZnVuY3Rpb25zLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7QUFDSCxPQUFPLEtBQUssRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUc3Qjs7Ozs7O0dBTUc7QUFDSDtJQUFBO1FBQ0k7O1dBRUc7UUFDSyx3QkFBbUIsR0FBVyx1Q0FBdUMsQ0FBQztJQWlKbEYsQ0FBQztJQS9JRzs7Ozs7Ozs7OztPQVVHO0lBQ0gsZ0NBQU8sR0FBUCxVQUFRLElBQTZCO1FBQ2pDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN0RCxPQUFPLENBQ0gsQ0FBQyxLQUFLO1lBQ04sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7WUFDdEIsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQzlELENBQUM7SUFDTixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILHFDQUFZLEdBQVosVUFBYSxJQUE2QjtRQUN0QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzVELElBQUksSUFBSSxFQUFFO1lBQ04sT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDaEQ7YUFBTTtZQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQXdDLElBQU0sQ0FBQyxDQUFDO1NBQ25FO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxxQ0FBWSxHQUFaLFVBQWEsSUFBNkI7UUFDdEMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM1RCxJQUFJLElBQUksRUFBRTtZQUNOLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDSCxNQUFNLElBQUksS0FBSyxDQUFDLDBDQUF3QyxJQUFNLENBQUMsQ0FBQztTQUNuRTtJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsMkNBQWtCLEdBQWxCLFVBQW1CLElBQWlDO1FBQ2hELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNQLHVDQUF1QztZQUN2QyxJQUFNLElBQUksR0FBRyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDNUQsSUFBSSxJQUFJLEVBQUU7Z0JBQ04sSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNsQjtpQkFBTTtnQkFDSCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7YUFDbkY7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsbURBQTBCLEdBQTFCLFVBQTJCLFFBQWdCO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCwyQ0FBa0IsR0FBbEIsVUFDSSxtQkFBMEMsRUFDMUMsa0JBQXlDO1FBRXpDLGdDQUFnQztRQUNoQyxJQUFNLGNBQWMsR0FBUTtZQUFTLGNBQWM7aUJBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztnQkFBZCx5QkFBYzs7WUFDL0MsSUFBTSxNQUFNLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNwRCxJQUFJLE1BQU0sRUFBRTtnQkFDUixPQUFPLE1BQU0sQ0FBQzthQUNqQjtRQUNMLENBQUMsQ0FBQztRQUNGLG1EQUFtRDtRQUNuRCxjQUFjLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFNBQVMsQ0FBQztRQUV6RCxPQUFPLGNBQWMsQ0FBQztJQUMxQixDQUFDO0lBRUQsZ0JBQWdCO0lBQ2hCLHVDQUFjLEdBQWQ7UUFDSSx3Q0FBd0M7UUFDeEMsT0FBTyxPQUFPLE1BQU0sQ0FBQyxTQUFTLEtBQUssV0FBVyxDQUFDO0lBQ25ELENBQUM7SUFFRCx1Q0FBYyxHQUFkLFVBQTJCLEdBQWdCO1FBQ3ZDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQzFCLFVBQUMsR0FBZ0MsRUFBRSxHQUFXLElBQUssd0JBQzVDLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQztZQUNkLEVBQUUsR0FBRyxLQUFBLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUZ1QixDQUdsRCxFQUNELEVBQUUsQ0FDTCxDQUFDO0lBQ04sQ0FBQztJQUNMLHFCQUFDO0FBQUQsQ0FBQyxBQXJKRCxJQXFKQzs7QUFFRCxNQUFNLENBQUMsSUFBTSxjQUFjLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IFNBUCBTRSBvciBhbiBTQVAgYWZmaWxpYXRlIGNvbXBhbnkuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAbW9kdWxlIHNtYXJ0dXRpbHNcbiAqL1xuaW1wb3J0ICogYXMgbG8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFR5cGVkTWFwIH0gZnJvbSAnLi4vZHRvcyc7XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOkZ1bmN0aW9uc1V0aWxzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiB1dGlsaXR5IHNlcnZpY2UgYXJvdW5kIEZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1V0aWxzIHtcbiAgICAvKlxuICAgICAqIHJlZ2V4cCBtYXRjaGluZyBmdW5jdGlvbihhLCAkYil7fSBhbmQgZnVuY3Rpb24gTXlGdW5jdGlvbihhLCAkYil7fVxuICAgICAqL1xuICAgIHByaXZhdGUgc2lnbmF0dXJlQXJnc1JlZ2V4cDogUmVnRXhwID0gL2Z1bmN0aW9uW1xcc1xcd10qXFwoKFtcXHdcXHNcXCQsXSopXFwpW1xcc10qey87XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHMjaXNFbXB0eVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpGdW5jdGlvbnNVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogV2lsbCBkZXRlcm1pbmUgd2hldGhlciBhIGZ1bmN0aW9uIGJvZHkgaXMgZW1wdHkgb3Igc2hvdWxkIGJlIGNvbnNpZGVyZWQgZW1wdHkgZm9yIHByb3h5aW5nIHB1cnBvc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jLCB0aGUgZnVuY3Rpb24gdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYSBib29sZWFuLlxuICAgICAqL1xuICAgIGlzRW1wdHkoZnVuYzogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL1xceyhbXFxzXFxTXSopXFx9L20pO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIW1hdGNoIHx8XG4gICAgICAgICAgICBtYXRjaFsxXS50cmltKCkgPT09ICcnIHx8XG4gICAgICAgICAgICAvKHByb3h5RnVuY3Rpb24pL2cudGVzdChmdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzL2csICcnKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHMjZ2V0QXJndW1lbnRzXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkZ1bmN0aW9uc1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBzdHJpbmcgYXJndW1lbnRzIG9mIHRoZSBnaXZlbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgdGhlIGZ1bmN0aW9uIHRvIGFuYWx5emVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGFuIGFycmF5IG9mIHN0cmluZyBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBnZXRBcmd1bWVudHMoZnVuYzogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpIHtcbiAgICAgICAgY29uc3QgZXhlYyA9IHRoaXMuc2lnbmF0dXJlQXJnc1JlZ2V4cC5leGVjKGZ1bmMudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChleGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY1sxXS5yZXBsYWNlKC9cXHMvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byByZXRyaWV2ZSBhcmd1bWVudHMgbGlzdCBvZiAke2Z1bmN9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHMjaGFzQXJndW1lbnRzXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkZ1bmN0aW9uc1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBmdW5jdGlvbiAoYW5vbnltb3VzIG9yIG5vdCkgaGFzIGFyZ3VtZW50cyBpbiBpdCBzaWduYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgdGhlIGZ1bmN0aW9uIHRvIGFuYWx5emVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZnVuY3Rpb24gaGFzIHNpZ25hdHVyZSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBoYXNBcmd1bWVudHMoZnVuYzogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpIHtcbiAgICAgICAgY29uc3QgZXhlYyA9IHRoaXMuc2lnbmF0dXJlQXJnc1JlZ2V4cC5leGVjKGZ1bmMudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChleGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxvLmlzRW1wdHkoZXhlY1sxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byByZXRyaWV2ZSBhcmd1bWVudHMgbGlzdCBvZiAke2Z1bmN9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHMjZ2V0Q29uc3RydWN0b3JOYW1lXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkZ1bmN0aW9uc1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBuYW1lIGluIGEgY3Jvc3MgYnJvd3NlciBmYXNoaW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRoZSBmdW5jdGlvbiB0byBhbmFseXplXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGNvbnN0cnVjdG9yIG5hbWVcbiAgICAgKi9cbiAgICBnZXRDb25zdHJ1Y3Rvck5hbWUoZnVuYzogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSB7XG4gICAgICAgIGxldCBuYW1lID0gZnVuYy5uYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IHN1cHBvcnQgY29uc3RydWN0b3IubmFtZVxuICAgICAgICAgICAgY29uc3QgZXhlYyA9IC9mdW5jdGlvbiAoXFwkP1xcdyspXFxzKlxcKC8uZXhlYyhmdW5jLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKGV4ZWMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gZXhlY1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbRnVuY3Rpb25zVXRpbHNdIC0gQ2Fubm90IGdldCBuYW1lIGZyb20gaW52YWxpZCBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHMjZ2V0SW5zdGFuY2VDb25zdHJ1Y3Rvck5hbWVcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgdGhlIGNvbnN0cnVjdG9yIG5hbWUgaW4gYSBjcm9zcyBicm93c2VyIGZhc2hpb24gb2YgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlIGluc3RhbmNlIGNsYXNzIHRvIGFuYWx5emVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY29uc3RydWN0b3IgbmFtZSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRJbnN0YW5jZUNvbnN0cnVjdG9yTmFtZShpbnN0YW5jZTogb2JqZWN0KTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RydWN0b3JOYW1lKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSkuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpGdW5jdGlvbnNVdGlscyNleHRlbmRzQ29uc3RydWN0b3JcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6RnVuY3Rpb25zVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE92ZXJyaWRlcyBhIGdpdmVuIGNvbnN0cnVjdG9yIHdpdGggYSBuZXcgY29uc3RydWN0b3IgYm9keS4gVGhlIHJlc3VsdGluZyBjb25zdHJ1Y3RvciB3aWxsIHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZSBhcyB0aGUgb3JpZ2luYWwgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoLi4uYXJnczphbnlbXSkgPT4gVH0gb3JpZ2luYWxDb25zdHJ1Y3RvciB0aGUgb3JpZ2luYWwgY29uc3RydWN0b3IgdG8gb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7KC4uLmFyZ3M6YW55W10pID0+IFR9IG5ld0NvbnN0cnVjdG9yQm9keSB0aGUgbmV3IGNvbnN0cnVjdG9yIGJvZHkgdG8gZXhlY3V0ZSBpbiB0aGUgb3ZlcnJpZGUuIEl0IG1heSBvciBtYXkgbm90IHJldHVybiBhbiBpbnN0YW5jZS4gU2hvdWxkIGl0IHJldHVybiBhbiBpbnN0YW5jZSwgdGhlIGxhdHRlciB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBvdmVycmlkZS5cbiAgICAgKi9cbiAgICBleHRlbmRzQ29uc3RydWN0b3I8VD4oXG4gICAgICAgIG9yaWdpbmFsQ29uc3RydWN0b3I6ICguLi5hcmdzOiBhbnlbXSkgPT4gVCxcbiAgICAgICAgbmV3Q29uc3RydWN0b3JCb2R5OiAoLi4uYXJnczogYW55W10pID0+IFRcbiAgICApOiBhbnkge1xuICAgICAgICAvLyB0aGUgbmV3IGNvbnN0cnVjdG9yIGJlaGF2aW91clxuICAgICAgICBjb25zdCBuZXdDb25zdHJ1Y3RvcjogYW55ID0gZnVuY3Rpb24oLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld0NvbnN0cnVjdG9yQm9keS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBjb3B5IHByb3RvdHlwZSBzbyBpbnRhbmNlb2Ygb3BlcmF0b3Igc3RpbGwgd29ya3NcbiAgICAgICAgbmV3Q29uc3RydWN0b3IucHJvdG90eXBlID0gb3JpZ2luYWxDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgcmV0dXJuIG5ld0NvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBpc1VuaXRUZXN0TW9kZSgpOiBib29sZWFuIHtcbiAgICAgICAgLyogZm9yYmlkZGVuTmFtZVNwYWNlcyB3aW5kb3cuXzpmYWxzZSAqL1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdy5fX2thcm1hX18gIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIGNvbnZlcnRUb0FycmF5PFQgPSBzdHJpbmc+KG9iajogVHlwZWRNYXA8VD4pOiB7IGtleTogc3RyaW5nOyB2YWx1ZTogVCB9W10ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjOiB7IGtleTogc3RyaW5nOyB2YWx1ZTogVCB9W10sIGtleTogc3RyaW5nKSA9PiBbXG4gICAgICAgICAgICAgICAgLi4uKGFjYyB8fCBbXSksXG4gICAgICAgICAgICAgICAgeyBrZXksIHZhbHVlOiBvYmpba2V5XSB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW11cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBmdW5jdGlvbnNVdGlscyA9IG5ldyBGdW5jdGlvbnNVdGlscygpO1xuIl19