/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as lodash from 'lodash';
import { FunctionsUtils } from '../utils';
/** @internal */
var annotationType;
(function (annotationType) {
    annotationType["Class"] = "ClassAnnotation";
    annotationType["Method"] = "MethodAnnotation";
})(annotationType || (annotationType = {}));
/**
 * @ngdoc service
 * @name @smartutils.services:AnnotationService
 *
 * @description
 * Utility service to declare and consume method level and class level {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript decorator factories}.
 * <br/>Since Decorator is a reserved word in Smartedit, Typescript Decorators are called as Annotations.
 */
var AnnotationService = /** @class */ (function () {
    function AnnotationService() {
        this.INJECTABLE_NAME_KEY = 'getInjectableName';
        this.ORIGINAL_CONSTRUCTOR_KEY = 'originalConstructor';
        /**
         * @ngdoc method
         * @name @smartutils.services:AnnotationService#getClassAnnotations
         * @methodOf @smartutils.services:AnnotationService
         *
         * @description
         * Retrieves an object with all the string-indexed annotations defined on the given class target
         * @param {any} target The typescript class on which class annotations are defined
         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
         */
        this.getClassAnnotations = lodash.memoize(this.getClassAnnotationsLogic);
        /**
         * @ngdoc method
         * @name @smartutils.services:AnnotationService#getMethodAnnotations
         * @methodOf @smartutils.services:AnnotationService
         *
         * @description
         * Retrieves an object with all the string indexed annotations defined on the given class method
         * @param {any} target The typescript class to the inspected
         * @param {string} propertyName The name of the method on which annotations are defined
         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
         */
        this.getMethodAnnotations = lodash.memoize(this.getMethodAnnotationsLogic, function (target, propertyName) {
            return JSON.stringify(target.prototype) + propertyName;
        });
        this.functionsUtils = new FunctionsUtils();
        this.annotationFactoryMap = {};
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getClassAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves arguments of class annotation under a given annotation name
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {any} the payload passed to the annotation
     */
    AnnotationService.prototype.getClassAnnotation = function (target, annotation) {
        var annotationMap = this.getClassAnnotations(target);
        var annotationName = annotation.annotationName;
        if (annotationMap) {
            if (annotationName in annotationMap) {
                return annotationMap[annotationName];
            }
        }
        else {
            return null;
        }
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getMethodAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves arguments of method annotation for a given typescript class
     * @param {any} target The typescript class
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator)} annotation The type of the method annotation
     * @returns {any} the payload passed to the annotation
     */
    AnnotationService.prototype.getMethodAnnotation = function (target, propertyName, annotation) {
        var annotationMap = this.getMethodAnnotations(target, propertyName);
        var annotationName = annotation.annotationName;
        if (annotationMap) {
            if (annotationName in annotationMap) {
                return annotationMap[annotationName];
            }
        }
        else {
            return null;
        }
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#hasClassAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Determines whether a given class target has given annotation name defined or not
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {boolean} true if a given target has given annotation name. Otherwise false.
     */
    AnnotationService.prototype.hasClassAnnotation = function (target, annotation) {
        var annotationMap = this.getClassAnnotations(target);
        return annotation.annotationName in annotationMap ? true : false;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#hasMethodAnnotation
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Determines whether a given method name has given annotation name defined or not under a given typescript class
     * @param {any} target The typescript class object
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator} annotation The type of the method annotation
     * @returns {boolean} true if a given method name has given annotation name. Otherwise false.
     */
    AnnotationService.prototype.hasMethodAnnotation = function (target, propertyName, annotation) {
        var annotationMap = this.getMethodAnnotations(target, propertyName);
        return annotation.annotationName in annotationMap ? true : false;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#setClassAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Registers a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory} under a given name.
     * <br/>Typically, in order for the ClassAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name the name of the factory.
     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    AnnotationService.prototype.setClassAnnotationFactory = function (name, annotationFactory) {
        this.annotationFactoryMap[name] = annotationFactory;
        return annotationFactory;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getClassAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const GatewayProxied = annotationService.getClassAnnotationFactory('GatewayProxied');
     * </pre>
     *
     * @param {string} name The name of the factory
     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    AnnotationService.prototype.getClassAnnotationFactory = function (name) {
        var instance = this;
        var classAnnotationFactory = function () {
            var factoryArgument = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                factoryArgument[_i] = arguments[_i];
            }
            return function (originalConstructor) {
                var newConstructor = instance.functionsUtils.extendsConstructor(originalConstructor, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var annotationFactory = instance.annotationFactoryMap[name];
                    if (annotationFactory) {
                        // Note: Before we used to bind originalConstructor.bind(this). However, it had to be left up to the caller
                        // since that causes problems in IE; when a function is bound in IE, the browser wraps it in a function with
                        // native code, making it impossible to retrieve its name.
                        var result = annotationFactory(factoryArgument)(this, originalConstructor, args);
                        if (result) {
                            return result;
                        }
                    }
                    else {
                        throw new Error("annotation '" + name + "' is used on '" + originalConstructor.name + "' but its ClassAnnotationFactory may not have been added to the dependency injection");
                    }
                });
                /*
                 * enable Angular and AngularJS to inject this new constructor even though it has an empty signature
                 * by copying $inject property and DI related Angular metatdata
                 * For idempotency purposes we copy all properties anyways
                 */
                lodash.merge(newConstructor, originalConstructor);
                /*
                 * some properties set by Angular are not enumerable and yet contain
                 * such information as @Inject "metadata" necessary for DI
                 */
                newConstructor.__annotations__ = originalConstructor.__annotations__;
                newConstructor.__parameters__ = originalConstructor.__parameters__;
                newConstructor.__prop__metadata__ = originalConstructor.__prop__metadata__;
                /*
                 * copying such metadata as design:paramtypes necessary for DI
                 */
                Reflect.getMetadataKeys(originalConstructor).forEach(function (key) {
                    Reflect.defineMetadata(key, Reflect.getMetadata(key, originalConstructor), newConstructor);
                });
                var rootOriginalConstructor = instance.getOriginalConstructor(originalConstructor);
                Reflect.defineMetadata(instance.ORIGINAL_CONSTRUCTOR_KEY, rootOriginalConstructor, newConstructor);
                Reflect.defineMetadata(annotationType.Class + ':' + name, factoryArgument, rootOriginalConstructor);
                // override original constructor
                return newConstructor;
            };
        };
        classAnnotationFactory.annotationName = name;
        return classAnnotationFactory;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#setMethodAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Registers a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory} under a given name.
     * <br/>Typically, in order for the MethodAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name The name of the factory.
     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}
     */
    AnnotationService.prototype.setMethodAnnotationFactory = function (name, annotationFactory) {
        this.annotationFactoryMap[name] = annotationFactory;
        return annotationFactory;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getMethodAnnotationFactory
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Retrieves a method level {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const Cached = annotationService.getMethodAnnotationFactory('Cached');
     * </pre>
     *
     * @param {string} name the name of the factory.
     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}.
     */
    AnnotationService.prototype.getMethodAnnotationFactory = function (name) {
        var instance = this;
        var methodAnnotationFactory = function () {
            var factoryArgument = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                factoryArgument[_i] = arguments[_i];
            }
            /*
             * when decorating an abstract class, strangely enough target is an instance of the abstract class
             * we need pass "this" instead to the annotationFactory invocation
             */
            return function (target, propertyName, descriptor) {
                var originalMethod = descriptor.value;
                descriptor.value = function () {
                    var annotationFactory = instance
                        .annotationFactoryMap[name];
                    if (annotationFactory) {
                        return originalMethod
                            ? annotationFactory(factoryArgument)(this, propertyName, originalMethod.bind(this), arguments)
                            : undefined;
                    }
                    else {
                        throw new Error("annotation '" + name + "' is used but its MethodAnnotationFactory may not have been added to the dependency injection");
                    }
                };
                Reflect.defineMetadata(annotationType.Method + ':' + name, factoryArgument, target, propertyName);
            };
        };
        methodAnnotationFactory.annotationName = name;
        return methodAnnotationFactory;
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:AnnotationService#getOriginalConstructor
     * @methodOf @smartutils.services:AnnotationService
     *
     * @description
     * Given a class constructor, returns the original constructor of it prior to any class level
     * proxying by annotations declared through {@link @smartutils.services:AnnotationService AnnotationService}
     *
     * @param {Class} target the constructor
     */
    AnnotationService.prototype.getOriginalConstructor = function (target) {
        return Reflect.getMetadata(this.ORIGINAL_CONSTRUCTOR_KEY, target) || target;
    };
    AnnotationService.prototype.getClassAnnotationsLogic = function (target) {
        var originalConstructor = this.getOriginalConstructor(target);
        var annotationMap = {};
        Reflect.getMetadataKeys(originalConstructor)
            .filter(function (key) { return key.toString().startsWith(annotationType.Class); })
            .map(function (key) {
            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, originalConstructor);
        });
        return annotationMap;
    };
    AnnotationService.prototype.getMethodAnnotationsLogic = function (target, propertyName) {
        var annotationMap = {};
        Reflect.getMetadataKeys(target.prototype, propertyName)
            .filter(function (key) { return key.toString().startsWith(annotationType.Method); })
            .map(function (key) {
            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, target.prototype, propertyName);
        });
        return annotationMap;
    };
    return AnnotationService;
}());
export { AnnotationService };
export var annotationService = new AnnotationService();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsic2VydmljZXMvYW5ub3RhdGlvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUNILE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFpRTFDLGdCQUFnQjtBQUNoQixJQUFLLGNBR0o7QUFIRCxXQUFLLGNBQWM7SUFDZiwyQ0FBeUIsQ0FBQTtJQUN6Qiw2Q0FBMkIsQ0FBQTtBQUMvQixDQUFDLEVBSEksY0FBYyxLQUFkLGNBQWMsUUFHbEI7QUFFRDs7Ozs7OztHQU9HO0FBQ0g7SUFBQTtRQUNvQix3QkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztRQUMxQyw2QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQztRQUVqRTs7Ozs7Ozs7O1dBU0c7UUFDSCx3QkFBbUIsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBRXBFOzs7Ozs7Ozs7O1dBVUc7UUFDSCx5QkFBb0IsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxVQUNsRSxNQUFXLEVBQ1gsWUFBb0I7WUFFcEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxZQUFZLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUM7UUFFSyxtQkFBYyxHQUFtQixJQUFJLGNBQWMsRUFBRSxDQUFDO1FBRXRELHlCQUFvQixHQUFHLEVBRTlCLENBQUM7SUE0VU4sQ0FBQztJQTFVRzs7Ozs7Ozs7OztPQVVHO0lBQ0gsOENBQWtCLEdBQWxCLFVBQW1CLE1BQVcsRUFBRSxVQUEwQztRQUN0RSxJQUFNLGFBQWEsR0FBa0IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxD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LENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FDbEQsR0FBRyxFQUNILE1BQU0sQ0FBQyxTQUFTLEVBQ2hCLFlBQVksQ0FDZixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7UUFFUCxPQUFPLGFBQWEsQ0FBQztJQUN6QixDQUFDO0lBQ0wsd0JBQUM7QUFBRCxDQUFDLEFBbFhELElBa1hDOztBQUVELE1BQU0sQ0FBQyxJQUFNLGlCQUFpQixHQUFzQixJQUFJLGlCQUFpQixFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCAqIGFzIGxvZGFzaCBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgRnVuY3Rpb25zVXRpbHMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBDbGFzcyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFR5cGVkTWFwIH0gZnJvbSAnLi4vZHRvcyc7XG5pbXBvcnQge30gZnJvbSAncmVmbGVjdC1tZXRhZGF0YSc7XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNob3J0aGFuZCBzaWduYXR1cmUgb2YgYSB7QGxpbmsgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1sIFR5cGVzY3JpcHQgRGVjb3JhdG9yfSBmdW5jdGlvbiBmb3IgbWV0aG9kc1xuICogdXNlZCBieSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UgQW5ub3RhdGlvblNlcnZpY2V9LlxuICogQHBhcmFtIHthbnl9IHRhcmdldCB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBvZiB3aGljaCBpcyBhbm5vdGF0ZWRcbiAqIEBwYXJhbSB7YW55fSBwcm9wZXJ0eU5hbWUgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IGlzIGFubm90YXRlZFxuICogQHBhcmFtIHthbnl9IG9yaWdpbmFsTWV0aG9kIHRoZSBvcmlnaW5hbCBtZXRob2QgYmVpbmcgYW5ub3RhdGVkLCBpdCBpcyBwcmVib3VuZCB0byB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHthbnl9IHRoZSBmaW5hbCByZXR1cm4gdmFsdWUgb2YgdGhlIHByb3hpZWQgbWV0aG9kLlxuICogSXQgaXMgbGVmdCB0byBpbXBsZW1lbnRlcnMgdG8gZGlzY2FyZCwgbW9kaWZ5LCByZXVzZSB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICovXG5leHBvcnQgdHlwZSBNZXRob2RBbm5vdGF0aW9uID0gKFxuICAgIHRhcmdldDogYW55LFxuICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgIG9yaWdpbmFsTWV0aG9kOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAuLi5pbnZvY2F0aW9uQXJndW1lbnRzOiBhbnlbXVxuKSA9PiBhbnk7XG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uRmFjdG9yeVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb24gTWV0aG9kQW5ub3RhdGlvbn0gZmFjdG9yeVxuICogdXNlZCBieSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UgQW5ub3RhdGlvblNlcnZpY2V9LlxuICogQHBhcmFtIHsuLi5hbnlbXX0gZmFjdG9yeUFyZ3VtZW50cyB0aGUgZmFjdG9yeSBhcmd1bWVudHNcbiAqIEByZXR1cm5zIHtNZXRob2RBbm5vdGF0aW9ufSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb24gTWV0aG9kQW5ub3RhdGlvbn1cbiAqL1xuZXhwb3J0IHR5cGUgTWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgPSAoLi4uZmFjdG9yeUFyZ3VtZW50czogYW55W10pID0+IE1ldGhvZEFubm90YXRpb247XG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNob3J0aGFuZCBzaWduYXR1cmUgb2YgYSB7QGxpbmsgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1sIFR5cGVzY3JpcHQgRGVjb3JhdG9yfSBmdW5jdGlvbiBmb3IgY2xhc3Nlc1xuICogdXNlZCBieSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UgQW5ub3RhdGlvblNlcnZpY2V9LlxuICogQHBhcmFtIHthbnl9IGluc3RhbmNlIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcyB3aGljaCBpcyBhbm5vdGF0ZWRcbiAqIEBwYXJhbSB7KC4uLng6IGFueVtdKSA9PiBhbnl9IG9yaWdpbmFsQ29uc3RydWN0b3IgdGhlIHByZWJvdW5kIG9yaWdpbmFsIGNvbnN0cnVjdG9yIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHsuLi5hbnlbXX0gaW52b2NhdGlvbkFyZ3VtZW50cyB0aGUgYXJndW1lbnRzIHdpdGggd2hpY2ggdGhlIGNvbnN0cnVjdG9yIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHthbnl9IHZvaWQgb3IgYSBuZXcgaW5zdGFuY2UuXG4gKiBJdCBpcyBsZWZ0IHRvIGltcGxlbWVudGVycyB0byBkaXNjYXJkLCBtb2RpZnksIG9yIHJldXNlIHRoZSBvcmlnaW5hbCBjb25zdHJ1Y3RvciB0aGVuIG5vdCB0byByZXR1cm4gb3IgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxuICovXG5leHBvcnQgdHlwZSBDbGFzc0Fubm90YXRpb24gPSAoXG4gICAgaW5zdGFuY2U6IGFueSxcbiAgICBvcmlnaW5hbENvbnN0cnVjdG9yOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAuLi5pbnZvY2F0aW9uQXJndW1lbnRzOiBhbnlbXVxuKSA9PiBhbnk7XG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25GYWN0b3J5XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uIENsYXNzQW5ub3RhdGlvbn0gZmFjdG9yeVxuICogdXNlZCBieSB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UgQW5ub3RhdGlvblNlcnZpY2V9LlxuICogQHBhcmFtIHsuLi5hbnlbXX0gZmFjdG9yeUFyZ3VtZW50cyB0aGUgZmFjdG9yeSBhcmd1bWVudHNcbiAqIEByZXR1cm5zIHtDbGFzc0Fubm90YXRpb259IHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2xhc3NBbm5vdGF0aW9uIENsYXNzQW5ub3RhdGlvbn1cbiAqL1xuZXhwb3J0IHR5cGUgQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeSA9ICguLi54OiBhbnlbXSkgPT4gQ2xhc3NBbm5vdGF0aW9uO1xuXG4vKiogQGludGVybmFsICovXG5lbnVtIGFubm90YXRpb25UeXBlIHtcbiAgICBDbGFzcyA9ICdDbGFzc0Fubm90YXRpb24nLFxuICAgIE1ldGhvZCA9ICdNZXRob2RBbm5vdGF0aW9uJ1xufVxuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVXRpbGl0eSBzZXJ2aWNlIHRvIGRlY2xhcmUgYW5kIGNvbnN1bWUgbWV0aG9kIGxldmVsIGFuZCBjbGFzcyBsZXZlbCB7QGxpbmsgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1sIFR5cGVzY3JpcHQgZGVjb3JhdG9yIGZhY3Rvcmllc30uXG4gKiA8YnIvPlNpbmNlIERlY29yYXRvciBpcyBhIHJlc2VydmVkIHdvcmQgaW4gU21hcnRlZGl0LCBUeXBlc2NyaXB0IERlY29yYXRvcnMgYXJlIGNhbGxlZCBhcyBBbm5vdGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFubm90YXRpb25TZXJ2aWNlIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgSU5KRUNUQUJMRV9OQU1FX0tFWSA9ICdnZXRJbmplY3RhYmxlTmFtZSc7XG4gICAgcHVibGljIHJlYWRvbmx5IE9SSUdJTkFMX0NPTlNUUlVDVE9SX0tFWSA9ICdvcmlnaW5hbENvbnN0cnVjdG9yJztcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNnZXRDbGFzc0Fubm90YXRpb25zXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgYW4gb2JqZWN0IHdpdGggYWxsIHRoZSBzdHJpbmctaW5kZXhlZCBhbm5vdGF0aW9ucyBkZWZpbmVkIG9uIHRoZSBnaXZlbiBjbGFzcyB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0eXBlc2NyaXB0IGNsYXNzIG9uIHdoaWNoIGNsYXNzIGFubm90YXRpb25zIGFyZSBkZWZpbmVkXG4gICAgICogQHJldHVybnMge1tpbmRleDogc3RyaW5nXTogYW55fSBhbiBvYmplY3QgY29udGFpbnMgc3RyaW5nLWluZGV4ZWQgYW5ub3RhdGlvbiBuYW1lIGFuZCBwYXlsb2FkXG4gICAgICovXG4gICAgZ2V0Q2xhc3NBbm5vdGF0aW9ucyA9IGxvZGFzaC5tZW1vaXplKHRoaXMuZ2V0Q2xhc3NBbm5vdGF0aW9uc0xvZ2ljKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNnZXRNZXRob2RBbm5vdGF0aW9uc1xuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0cmlldmVzIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgc3RyaW5nIGluZGV4ZWQgYW5ub3RhdGlvbnMgZGVmaW5lZCBvbiB0aGUgZ2l2ZW4gY2xhc3MgbWV0aG9kXG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBUaGUgdHlwZXNjcmlwdCBjbGFzcyB0byB0aGUgaW5zcGVjdGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIG9uIHdoaWNoIGFubm90YXRpb25zIGFyZSBkZWZpbmVkXG4gICAgICogQHJldHVybnMge1tpbmRleDogc3RyaW5nXTogYW55fSBhbiBvYmplY3QgY29udGFpbnMgc3RyaW5nLWluZGV4ZWQgYW5ub3RhdGlvbiBuYW1lIGFuZCBwYXlsb2FkXG4gICAgICovXG4gICAgZ2V0TWV0aG9kQW5ub3RhdGlvbnMgPSBsb2Rhc2gubWVtb2l6ZSh0aGlzLmdldE1ldGhvZEFubm90YXRpb25zTG9naWMsIGZ1bmN0aW9uKFxuICAgICAgICB0YXJnZXQ6IGFueSxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRhcmdldC5wcm90b3R5cGUpICsgcHJvcGVydHlOYW1lO1xuICAgIH0pO1xuXG4gICAgcHJpdmF0ZSBmdW5jdGlvbnNVdGlsczogRnVuY3Rpb25zVXRpbHMgPSBuZXcgRnVuY3Rpb25zVXRpbHMoKTtcblxuICAgIHByaXZhdGUgYW5ub3RhdGlvbkZhY3RvcnlNYXAgPSB7fSBhcyBUeXBlZE1hcDxcbiAgICAgICAgTWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgfCBDbGFzc0Fubm90YXRpb25GYWN0b3J5IHwgbnVsbFxuICAgID47XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0Q2xhc3NBbm5vdGF0aW9uXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgYXJndW1lbnRzIG9mIGNsYXNzIGFubm90YXRpb24gdW5kZXIgYSBnaXZlbiBhbm5vdGF0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0eXBlc2NyaXB0IGNsYXNzIG9uIHdoaWNoIGNsYXNzIGFubm90YXRpb24gaXMgZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7KGFyZ3M/OiBhbnkpID0+IENsYXNzRGVjb3JhdG9yfSBhbm5vdGF0aW9uIFRoZSB0eXBlIG9mIHRoZSBjbGFzcyBhbm5vdGF0aW9uXG4gICAgICogQHJldHVybnMge2FueX0gdGhlIHBheWxvYWQgcGFzc2VkIHRvIHRoZSBhbm5vdGF0aW9uXG4gICAgICovXG4gICAgZ2V0Q2xhc3NBbm5vdGF0aW9uKHRhcmdldDogYW55LCBhbm5vdGF0aW9uOiAoYXJncz86IGFueSkgPT4gQ2xhc3NEZWNvcmF0b3IpOiBhbnkge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTWFwOiBUeXBlZE1hcDxhbnk+ID0gdGhpcy5nZXRDbGFzc0Fubm90YXRpb25zKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25OYW1lOiBzdHJpbmcgPSAoYW5ub3RhdGlvbiBhcyBhbnkpLmFubm90YXRpb25OYW1lO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbk1hcCkge1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25OYW1lIGluIGFubm90YXRpb25NYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbk1hcFthbm5vdGF0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNnZXRNZXRob2RBbm5vdGF0aW9uXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgYXJndW1lbnRzIG9mIG1ldGhvZCBhbm5vdGF0aW9uIGZvciBhIGdpdmVuIHR5cGVzY3JpcHQgY2xhc3NcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0eXBlc2NyaXB0IGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIG9uIHdoaWNoIGFubm90YXRpb24gaXMgZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7KGFyZ3M/OiBhbnkpID0+IE1ldGhvZERlY29yYXRvcil9IGFubm90YXRpb24gVGhlIHR5cGUgb2YgdGhlIG1ldGhvZCBhbm5vdGF0aW9uXG4gICAgICogQHJldHVybnMge2FueX0gdGhlIHBheWxvYWQgcGFzc2VkIHRvIHRoZSBhbm5vdGF0aW9uXG4gICAgICovXG4gICAgZ2V0TWV0aG9kQW5ub3RhdGlvbihcbiAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgICAgICBhbm5vdGF0aW9uOiAoYXJncz86IGFueSkgPT4gTWV0aG9kRGVjb3JhdG9yXG4gICAgKTogYW55IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbk1hcDogVHlwZWRNYXA8YW55PiA9IHRoaXMuZ2V0TWV0aG9kQW5ub3RhdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uTmFtZTogc3RyaW5nID0gKGFubm90YXRpb24gYXMgYW55KS5hbm5vdGF0aW9uTmFtZTtcbiAgICAgICAgaWYgKGFubm90YXRpb25NYXApIHtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uTmFtZSBpbiBhbm5vdGF0aW9uTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25NYXBbYW5ub3RhdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjaGFzQ2xhc3NBbm5vdGF0aW9uXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBjbGFzcyB0YXJnZXQgaGFzIGdpdmVuIGFubm90YXRpb24gbmFtZSBkZWZpbmVkIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7YW55fSB0YXJnZXQgVGhlIHR5cGVzY3JpcHQgY2xhc3Mgb24gd2hpY2ggY2xhc3MgYW5ub3RhdGlvbiBpcyBkZWZpbmVkXG4gICAgICogQHBhcmFtIHsoYXJncz86IGFueSkgPT4gQ2xhc3NEZWNvcmF0b3J9IGFubm90YXRpb24gVGhlIHR5cGUgb2YgdGhlIGNsYXNzIGFubm90YXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIGdpdmVuIHRhcmdldCBoYXMgZ2l2ZW4gYW5ub3RhdGlvbiBuYW1lLiBPdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgaGFzQ2xhc3NBbm5vdGF0aW9uKHRhcmdldDogYW55LCBhbm5vdGF0aW9uOiAoYXJncz86IGFueSkgPT4gQ2xhc3NEZWNvcmF0b3IpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbk1hcDogVHlwZWRNYXA8YW55PiA9IHRoaXMuZ2V0Q2xhc3NBbm5vdGF0aW9ucyh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gKGFubm90YXRpb24gYXMgYW55KS5hbm5vdGF0aW9uTmFtZSBpbiBhbm5vdGF0aW9uTWFwID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNoYXNNZXRob2RBbm5vdGF0aW9uXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBtZXRob2QgbmFtZSBoYXMgZ2l2ZW4gYW5ub3RhdGlvbiBuYW1lIGRlZmluZWQgb3Igbm90IHVuZGVyIGEgZ2l2ZW4gdHlwZXNjcmlwdCBjbGFzc1xuICAgICAqIEBwYXJhbSB7YW55fSB0YXJnZXQgVGhlIHR5cGVzY3JpcHQgY2xhc3Mgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIG9uIHdoaWNoIGFubm90YXRpb24gaXMgZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7KGFyZ3M/OiBhbnkpID0+IE1ldGhvZERlY29yYXRvcn0gYW5ub3RhdGlvbiBUaGUgdHlwZSBvZiB0aGUgbWV0aG9kIGFubm90YXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIGdpdmVuIG1ldGhvZCBuYW1lIGhhcyBnaXZlbiBhbm5vdGF0aW9uIG5hbWUuIE90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBoYXNNZXRob2RBbm5vdGF0aW9uKFxuICAgICAgICB0YXJnZXQ6IGFueSxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmcsXG4gICAgICAgIGFubm90YXRpb246IChhcmdzPzogYW55KSA9PiBNZXRob2REZWNvcmF0b3JcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbk1hcDogVHlwZWRNYXA8YW55PiA9IHRoaXMuZ2V0TWV0aG9kQW5ub3RhdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICByZXR1cm4gKGFubm90YXRpb24gYXMgYW55KS5hbm5vdGF0aW9uTmFtZSBpbiBhbm5vdGF0aW9uTWFwID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNzZXRDbGFzc0Fubm90YXRpb25GYWN0b3J5XG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZWdpc3RlcnMgYSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNsYXNzQW5ub3RhdGlvbkZhY3RvcnkgQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeX0gdW5kZXIgYSBnaXZlbiBuYW1lLlxuICAgICAqIDxici8+VHlwaWNhbGx5LCBpbiBvcmRlciBmb3IgdGhlIENsYXNzQW5ub3RhdGlvbkZhY3RvcnkgdG8gYmVuZWZpdCBmcm9tIEFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHdpdGhpbiBhbiBBbmd1bGFyIGZhY3RvcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZhY3RvcnkuXG4gICAgICogQHJldHVybnMge0NsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9IGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25GYWN0b3J5IENsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9XG4gICAgICovXG4gICAgc2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeShcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBhbm5vdGF0aW9uRmFjdG9yeTogQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeSB8IG51bGxcbiAgICApOiBDbGFzc0Fubm90YXRpb25GYWN0b3J5IHwgbnVsbCB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZhY3RvcnlNYXBbbmFtZV0gPSBhbm5vdGF0aW9uRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25GYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNnZXRDbGFzc0Fubm90YXRpb25GYWN0b3J5XG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOkFubm90YXRpb25TZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNsYXNzQW5ub3RhdGlvbkZhY3RvcnkgQ2xhc3NBbm5vdGF0aW9uRmFjdG9yeX1cbiAgICAgKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWU6XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqICAgZXhwb3J0IGNvbnN0IEdhdGV3YXlQcm94aWVkID0gYW5ub3RhdGlvblNlcnZpY2UuZ2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeSgnR2F0ZXdheVByb3hpZWQnKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmYWN0b3J5XG4gICAgICogQHJldHVybnMge0NsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9IGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDbGFzc0Fubm90YXRpb25GYWN0b3J5IENsYXNzQW5ub3RhdGlvbkZhY3Rvcnl9XG4gICAgICovXG5cbiAgICBnZXRDbGFzc0Fubm90YXRpb25GYWN0b3J5KG5hbWU6IHN0cmluZyk6ICguLi5hcmdzOiBhbnlbXSkgPT4gQ2xhc3NEZWNvcmF0b3Ige1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgY2xhc3NBbm5vdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKC4uLmZhY3RvcnlBcmd1bWVudDogYW55W10pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvcmlnaW5hbENvbnN0cnVjdG9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb25zdHJ1Y3RvciA9IGluc3RhbmNlLmZ1bmN0aW9uc1V0aWxzLmV4dGVuZHNDb25zdHJ1Y3RvcihcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25GYWN0b3J5ID0gaW5zdGFuY2UuYW5ub3RhdGlvbkZhY3RvcnlNYXBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSBhcyBDbGFzc0Fubm90YXRpb25GYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25GYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQmVmb3JlIHdlIHVzZWQgdG8gYmluZCBvcmlnaW5hbENvbnN0cnVjdG9yLmJpbmQodGhpcykuIEhvd2V2ZXIsIGl0IGhhZCB0byBiZSBsZWZ0IHVwIHRvIHRoZSBjYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGF0IGNhdXNlcyBwcm9ibGVtcyBpbiBJRTsgd2hlbiBhIGZ1bmN0aW9uIGlzIGJvdW5kIGluIElFLCB0aGUgYnJvd3NlciB3cmFwcyBpdCBpbiBhIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgY29kZSwgbWFraW5nIGl0IGltcG9zc2libGUgdG8gcmV0cmlldmUgaXRzIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYW5ub3RhdGlvbkZhY3RvcnkoZmFjdG9yeUFyZ3VtZW50KShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5ub3RhdGlvbiAnJHtuYW1lfScgaXMgdXNlZCBvbiAnJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc3RydWN0b3IubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBidXQgaXRzIENsYXNzQW5ub3RhdGlvbkZhY3RvcnkgbWF5IG5vdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGRlcGVuZGVuY3kgaW5qZWN0aW9uYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBlbmFibGUgQW5ndWxhciBhbmQgQW5ndWxhckpTIHRvIGluamVjdCB0aGlzIG5ldyBjb25zdHJ1Y3RvciBldmVuIHRob3VnaCBpdCBoYXMgYW4gZW1wdHkgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICogYnkgY29weWluZyAkaW5qZWN0IHByb3BlcnR5IGFuZCBESSByZWxhdGVkIEFuZ3VsYXIgbWV0YXRkYXRhXG4gICAgICAgICAgICAgICAgICogRm9yIGlkZW1wb3RlbmN5IHB1cnBvc2VzIHdlIGNvcHkgYWxsIHByb3BlcnRpZXMgYW55d2F5c1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxvZGFzaC5tZXJnZShuZXdDb25zdHJ1Y3Rvciwgb3JpZ2luYWxDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzb21lIHByb3BlcnRpZXMgc2V0IGJ5IEFuZ3VsYXIgYXJlIG5vdCBlbnVtZXJhYmxlIGFuZCB5ZXQgY29udGFpblxuICAgICAgICAgICAgICAgICAqIHN1Y2ggaW5mb3JtYXRpb24gYXMgQEluamVjdCBcIm1ldGFkYXRhXCIgbmVjZXNzYXJ5IGZvciBESVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5ld0NvbnN0cnVjdG9yLl9fYW5ub3RhdGlvbnNfXyA9IG9yaWdpbmFsQ29uc3RydWN0b3IuX19hbm5vdGF0aW9uc19fO1xuICAgICAgICAgICAgICAgIG5ld0NvbnN0cnVjdG9yLl9fcGFyYW1ldGVyc19fID0gb3JpZ2luYWxDb25zdHJ1Y3Rvci5fX3BhcmFtZXRlcnNfXztcbiAgICAgICAgICAgICAgICBuZXdDb25zdHJ1Y3Rvci5fX3Byb3BfX21ldGFkYXRhX18gPSBvcmlnaW5hbENvbnN0cnVjdG9yLl9fcHJvcF9fbWV0YWRhdGFfXztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogY29weWluZyBzdWNoIG1ldGFkYXRhIGFzIGRlc2lnbjpwYXJhbXR5cGVzIG5lY2Vzc2FyeSBmb3IgRElcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhvcmlnaW5hbENvbnN0cnVjdG9yKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGEoa2V5LCBvcmlnaW5hbENvbnN0cnVjdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByb290T3JpZ2luYWxDb25zdHJ1Y3RvciA9IGluc3RhbmNlLmdldE9yaWdpbmFsQ29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuT1JJR0lOQUxfQ09OU1RSVUNUT1JfS0VZLFxuICAgICAgICAgICAgICAgICAgICByb290T3JpZ2luYWxDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvblR5cGUuQ2xhc3MgKyAnOicgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5QXJndW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RPcmlnaW5hbENvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIG9yaWdpbmFsIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgKGNsYXNzQW5ub3RhdGlvbkZhY3RvcnkgYXMgYW55KS5hbm5vdGF0aW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBjbGFzc0Fubm90YXRpb25GYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZSNzZXRNZXRob2RBbm5vdGF0aW9uRmFjdG9yeVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVnaXN0ZXJzIGEge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeX0gdW5kZXIgYSBnaXZlbiBuYW1lLlxuICAgICAqIDxici8+VHlwaWNhbGx5LCBpbiBvcmRlciBmb3IgdGhlIE1ldGhvZEFubm90YXRpb25GYWN0b3J5IHRvIGJlbmVmaXQgZnJvbSBBbmd1bGFyIGRlcGVuZGVuY3kgaW5qZWN0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aXRoaW4gYW4gQW5ndWxhciBmYWN0b3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmYWN0b3J5LlxuICAgICAqIEByZXR1cm5zIHtNZXRob2RBbm5vdGF0aW9uRmFjdG9yeX0gYSB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb25GYWN0b3J5IE1ldGhvZEFubm90YXRpb25GYWN0b3J5fVxuICAgICAqL1xuICAgIHNldE1ldGhvZEFubm90YXRpb25GYWN0b3J5KFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIGFubm90YXRpb25GYWN0b3J5OiBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSB8IG51bGxcbiAgICApOiBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSB8IG51bGwge1xuICAgICAgICB0aGlzLmFubm90YXRpb25GYWN0b3J5TWFwW25hbWVdID0gYW5ub3RhdGlvbkZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnlcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHJpZXZlcyBhIG1ldGhvZCBsZXZlbCB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0Ok1ldGhvZEFubm90YXRpb25GYWN0b3J5IE1ldGhvZEFubm90YXRpb25GYWN0b3J5fVxuICAgICAqIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZTpcbiAgICAgKlxuICAgICAqIDxwcmU+XG4gICAgICogICBleHBvcnQgY29uc3QgQ2FjaGVkID0gYW5ub3RhdGlvblNlcnZpY2UuZ2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkoJ0NhY2hlZCcpO1xuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZhY3RvcnkuXG4gICAgICogQHJldHVybnMge01ldGhvZEFubm90YXRpb25GYWN0b3J5fSBhIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgTWV0aG9kQW5ub3RhdGlvbkZhY3Rvcnl9LlxuICAgICAqL1xuICAgIGdldE1ldGhvZEFubm90YXRpb25GYWN0b3J5KG5hbWU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbiguLi5mYWN0b3J5QXJndW1lbnQ6IGFueVtdKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd2hlbiBkZWNvcmF0aW5nIGFuIGFic3RyYWN0IGNsYXNzLCBzdHJhbmdlbHkgZW5vdWdoIHRhcmdldCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYWJzdHJhY3QgY2xhc3NcbiAgICAgICAgICAgICAqIHdlIG5lZWQgcGFzcyBcInRoaXNcIiBpbnN0ZWFkIHRvIHRoZSBhbm5vdGF0aW9uRmFjdG9yeSBpbnZvY2F0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8KC4uLng6IGFueVtdKSA9PiBhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25GYWN0b3J5OiBNZXRob2RBbm5vdGF0aW9uRmFjdG9yeSA9IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuYW5ub3RhdGlvbkZhY3RvcnlNYXBbbmFtZV0gYXMgTWV0aG9kQW5ub3RhdGlvbkZhY3Rvcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25GYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFubm90YXRpb25GYWN0b3J5KGZhY3RvcnlBcmd1bWVudCkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5ub3RhdGlvbiAnJHtuYW1lfScgaXMgdXNlZCBidXQgaXRzIE1ldGhvZEFubm90YXRpb25GYWN0b3J5IG1heSBub3QgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBkZXBlbmRlbmN5IGluamVjdGlvbmBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvblR5cGUuTWV0aG9kICsgJzonICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAobWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkgYXMgYW55KS5hbm5vdGF0aW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBtZXRob2RBbm5vdGF0aW9uRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UjZ2V0T3JpZ2luYWxDb25zdHJ1Y3RvclxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpBbm5vdGF0aW9uU2VydmljZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2l2ZW4gYSBjbGFzcyBjb25zdHJ1Y3RvciwgcmV0dXJucyB0aGUgb3JpZ2luYWwgY29uc3RydWN0b3Igb2YgaXQgcHJpb3IgdG8gYW55IGNsYXNzIGxldmVsXG4gICAgICogcHJveHlpbmcgYnkgYW5ub3RhdGlvbnMgZGVjbGFyZWQgdGhyb3VnaCB7QGxpbmsgQHNtYXJ0dXRpbHMuc2VydmljZXM6QW5ub3RhdGlvblNlcnZpY2UgQW5ub3RhdGlvblNlcnZpY2V9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSB0YXJnZXQgdGhlIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgcHVibGljIGdldE9yaWdpbmFsQ29uc3RydWN0b3IodGFyZ2V0OiBhbnkpOiBDbGFzcyB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldE1ldGFkYXRhKHRoaXMuT1JJR0lOQUxfQ09OU1RSVUNUT1JfS0VZLCB0YXJnZXQpIHx8IHRhcmdldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENsYXNzQW5ub3RhdGlvbnNMb2dpYyh0YXJnZXQ6IGFueSk6IFR5cGVkTWFwPGFueT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnN0cnVjdG9yID0gdGhpcy5nZXRPcmlnaW5hbENvbnN0cnVjdG9yKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25NYXA6IFR5cGVkTWFwPGFueT4gPSB7fTtcblxuICAgICAgICBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhvcmlnaW5hbENvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5OiBzdHJpbmcpID0+IGtleS50b1N0cmluZygpLnN0YXJ0c1dpdGgoYW5ub3RhdGlvblR5cGUuQ2xhc3MpKVxuICAgICAgICAgICAgLm1hcCgoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uTWFwW2tleS5zcGxpdCgnOicpWzFdXSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoa2V5LCBvcmlnaW5hbENvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbk1hcDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1ldGhvZEFubm90YXRpb25zTG9naWModGFyZ2V0OiBhbnksIHByb3BlcnR5TmFtZTogc3RyaW5nKTogVHlwZWRNYXA8YW55PiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25NYXA6IFR5cGVkTWFwPGFueT4gPSB7fTtcblxuICAgICAgICBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyh0YXJnZXQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAuZmlsdGVyKChrZXk6IHN0cmluZykgPT4ga2V5LnRvU3RyaW5nKCkuc3RhcnRzV2l0aChhbm5vdGF0aW9uVHlwZS5NZXRob2QpKVxuICAgICAgICAgICAgLm1hcCgoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uTWFwW2tleS5zcGxpdCgnOicpWzFdXSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uTWFwO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFubm90YXRpb25TZXJ2aWNlOiBBbm5vdGF0aW9uU2VydmljZSA9IG5ldyBBbm5vdGF0aW9uU2VydmljZSgpO1xuIl19