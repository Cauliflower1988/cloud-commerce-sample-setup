/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector } from '@angular/core';
import * as lodash from 'lodash';
import { from } from 'rxjs';
import { Deferred, PromiseUtils } from '../../utils';
/**
 * @ngdoc service
 * @name @smartutils.services:httpErrorInterceptorService
 *
 * @description
 * The httpErrorInterceptorService provides the functionality to add custom HTTP error interceptors.
 * An interceptor can be an {Object} or an Angular Factory and must be represented by a pair of functions:
 * - predicate(request, response) {Function} that must return true if the response is associated to the interceptor. Important: The predicate must be designed to fulfill a specific function. It must not be defined for generic use.
 * - responseError(request, response) {Function} function called if the current response error matches the predicate. It must return a {Promise} with the resolved or rejected response.
 *
 * Each time an HTTP request fails, the service iterates through all registered interceptors. It sequentially calls the responseError function for all interceptors that have a predicate returning true for the current response error. If an interceptor modifies the response, the next interceptor that is called will have the modified response.
 * The last interceptor added to the service will be the first interceptor called. This makes it possible to override default interceptors.
 * If an interceptor resolves the response, the service service stops the iteration.
 */
var HttpErrorInterceptorService = /** @class */ (function () {
    function HttpErrorInterceptorService(injector, promiseUtils) {
        this.injector = injector;
        this.promiseUtils = promiseUtils;
        this._errorInterceptors = [];
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:httpErrorInterceptorService#addInterceptor
     * @methodOf @smartutils.services:httpErrorInterceptorService
     *
     * @description
     * Add a new error interceptor
     *
     * @param {Object|String} interceptor The interceptor {Object} or angular Factory
     *
     * @returns {Function} Function to call to unregister the interceptor from the service
     *
     * @example
     * ```js
     *      // Add a new interceptor with an instance of IHttpErrorInterceptor:
     *      var unregisterCustomInterceptor = httpErrorInterceptorService.addInterceptor({
     *          predicate: function(request, response) {
     *              return response.status === 400;
     *          },
     *          responseError: function(request, response) {
     *              alertService.showDanger({
     *                  message: response.message
     *              });
     *              return Promise.reject(response);// FIXME: update doc
     *          }
     *      });
     *
     *      // Add an interceptor with a class of IHttpErrorInterceptor:
     *      var unregisterCustomInterceptor = httpErrorInterceptorService.addInterceptor(CustomErrorInterceptor);
     *
     *      // Unregister the interceptor:
     *      unregisterCustomInterceptor();
     * ```
     */
    HttpErrorInterceptorService.prototype.addInterceptors = function (interceptorClasses) {
        var _this = this;
        interceptorClasses.forEach(function (InterceptorClass) {
            _this.addInterceptor(InterceptorClass);
        });
    };
    HttpErrorInterceptorService.prototype.addInterceptor = function (_interceptor) {
        var _this = this;
        var interceptor;
        if (_interceptor.predicate ||
            _interceptor.responseError) {
            interceptor = _interceptor;
        }
        else {
            interceptor = this.injector.get(_interceptor);
        }
        this._validateInterceptor(interceptor);
        this._errorInterceptors.unshift(interceptor);
        return function () {
            _this._errorInterceptors.splice(_this._errorInterceptors.indexOf(interceptor), 1);
        };
    };
    HttpErrorInterceptorService.prototype.responseError = function (request, response) {
        var matchingErrorInterceptors = this._errorInterceptors.filter(function (errorInterceptor) { return errorInterceptor.predicate(request, response) === true; });
        var _interceptorsDeferred = this.promiseUtils.defer();
        if (matchingErrorInterceptors.length) {
            this._iterateErrorInterceptors(request.clone(), lodash.cloneDeep(response), matchingErrorInterceptors, _interceptorsDeferred);
        }
        else {
            _interceptorsDeferred.reject(response);
        }
        return from(_interceptorsDeferred.promise);
    };
    HttpErrorInterceptorService.prototype._iterateErrorInterceptors = function (request, response, interceptors, _interceptorsDeferred, idx) {
        if (idx === void 0) { idx = 0; }
        if (idx === interceptors.length) {
            _interceptorsDeferred.reject(response);
        }
        else {
            var iterateFn_1 = this._iterateErrorInterceptors.bind(this);
            // FIXME: fully convert this part to Observable chaining
            Promise.resolve(interceptors[idx].responseError(request, response)).then(function (interceptedResponse) {
                _interceptorsDeferred.resolve(interceptedResponse);
            }, function (interceptedResponse) {
                iterateFn_1(request, interceptedResponse, interceptors, _interceptorsDeferred, ++idx);
            });
        }
    };
    /**
     * @ignore
     * Validate if the provided interceptor respects the Interface (predicate and responseError functions are mandatory).
     * @param {Object|String} interceptor The interceptor {Object} or angular Factory
     */
    HttpErrorInterceptorService.prototype._validateInterceptor = function (interceptor) {
        if (!interceptor.predicate || typeof interceptor.predicate !== 'function') {
            throw new Error('httpErrorInterceptorService.addInterceptor.error.interceptor.has.no.predicate');
        }
        if (!interceptor.responseError || typeof interceptor.responseError !== 'function') {
            throw new Error('httpErrorInterceptorService.addInterceptor.error.interceptor.has.no.responseError');
        }
    };
    HttpErrorInterceptorService.ctorParameters = function () { return [
        { type: Injector },
        { type: PromiseUtils }
    ]; };
    HttpErrorInterceptorService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [Injector, PromiseUtils])
    ], HttpErrorInterceptorService);
    return HttpErrorInterceptorService;
}());
export { HttpErrorInterceptorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1lcnJvci1pbnRlcmNlcHRvci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsic2VydmljZXMvaW50ZXJjZXB0b3JzL2h0dHAtZXJyb3ItaW50ZXJjZXB0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBS0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxLQUFLLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLElBQUksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUlyRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUg7SUFHSSxxQ0FBb0IsUUFBa0IsRUFBVSxZQUEwQjtRQUF0RCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQVUsaUJBQVksR0FBWixZQUFZLENBQWM7UUFGbEUsdUJBQWtCLEdBQTRCLEVBQUUsQ0FBQztJQUVvQixDQUFDO0lBRTlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQ0c7SUFFSCxxREFBZSxHQUFmLFVBQ0ksa0JBQTRFO1FBRGhGLGlCQU1DO1FBSEcsa0JBQWtCLENBQUMsT0FBTyxDQUFDLFVBQUMsZ0JBQWdCO1lBQ3hDLEtBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxvREFBYyxHQUFkLFVBQWUsWUFBa0U7UUFBakYsaUJBZ0JDO1FBZkcsSUFBSSxXQUFrQyxDQUFDO1FBQ3ZDLElBQ0ssWUFBc0MsQ0FBQyxTQUFTO1lBQ2hELFlBQXNDLENBQUMsYUFBYSxFQUN2RDtZQUNFLFdBQVcsR0FBRyxZQUFxQyxDQUFDO1NBQ3ZEO2FBQU07WUFDSCxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFH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dGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCB7IEh0dHBFcnJvclJlc3BvbnNlLCBIdHRwRXZlbnQsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIGxvZGFzaCBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRGVmZXJyZWQsIFByb21pc2VVdGlscyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IENsYXNzIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgSUh0dHBFcnJvckludGVyY2VwdG9yIH0gZnJvbSAnLi9pLWh0dHAtZXJyb3IuaW50ZXJjZXB0b3InO1xuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2UgcHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gYWRkIGN1c3RvbSBIVFRQIGVycm9yIGludGVyY2VwdG9ycy5cbiAqIEFuIGludGVyY2VwdG9yIGNhbiBiZSBhbiB7T2JqZWN0fSBvciBhbiBBbmd1bGFyIEZhY3RvcnkgYW5kIG11c3QgYmUgcmVwcmVzZW50ZWQgYnkgYSBwYWlyIG9mIGZ1bmN0aW9uczpcbiAqIC0gcHJlZGljYXRlKHJlcXVlc3QsIHJlc3BvbnNlKSB7RnVuY3Rpb259IHRoYXQgbXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgYXNzb2NpYXRlZCB0byB0aGUgaW50ZXJjZXB0b3IuIEltcG9ydGFudDogVGhlIHByZWRpY2F0ZSBtdXN0IGJlIGRlc2lnbmVkIHRvIGZ1bGZpbGwgYSBzcGVjaWZpYyBmdW5jdGlvbi4gSXQgbXVzdCBub3QgYmUgZGVmaW5lZCBmb3IgZ2VuZXJpYyB1c2UuXG4gKiAtIHJlc3BvbnNlRXJyb3IocmVxdWVzdCwgcmVzcG9uc2UpIHtGdW5jdGlvbn0gZnVuY3Rpb24gY2FsbGVkIGlmIHRoZSBjdXJyZW50IHJlc3BvbnNlIGVycm9yIG1hdGNoZXMgdGhlIHByZWRpY2F0ZS4gSXQgbXVzdCByZXR1cm4gYSB7UHJvbWlzZX0gd2l0aCB0aGUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgcmVzcG9uc2UuXG4gKlxuICogRWFjaCB0aW1lIGFuIEhUVFAgcmVxdWVzdCBmYWlscywgdGhlIHNlcnZpY2UgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnMuIEl0IHNlcXVlbnRpYWxseSBjYWxscyB0aGUgcmVzcG9uc2VFcnJvciBmdW5jdGlvbiBmb3IgYWxsIGludGVyY2VwdG9ycyB0aGF0IGhhdmUgYSBwcmVkaWNhdGUgcmV0dXJuaW5nIHRydWUgZm9yIHRoZSBjdXJyZW50IHJlc3BvbnNlIGVycm9yLiBJZiBhbiBpbnRlcmNlcHRvciBtb2RpZmllcyB0aGUgcmVzcG9uc2UsIHRoZSBuZXh0IGludGVyY2VwdG9yIHRoYXQgaXMgY2FsbGVkIHdpbGwgaGF2ZSB0aGUgbW9kaWZpZWQgcmVzcG9uc2UuXG4gKiBUaGUgbGFzdCBpbnRlcmNlcHRvciBhZGRlZCB0byB0aGUgc2VydmljZSB3aWxsIGJlIHRoZSBmaXJzdCBpbnRlcmNlcHRvciBjYWxsZWQuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gb3ZlcnJpZGUgZGVmYXVsdCBpbnRlcmNlcHRvcnMuXG4gKiBJZiBhbiBpbnRlcmNlcHRvciByZXNvbHZlcyB0aGUgcmVzcG9uc2UsIHRoZSBzZXJ2aWNlIHNlcnZpY2Ugc3RvcHMgdGhlIGl0ZXJhdGlvbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEh0dHBFcnJvckludGVyY2VwdG9yU2VydmljZSB7XG4gICAgcHJpdmF0ZSBfZXJyb3JJbnRlcmNlcHRvcnM6IElIdHRwRXJyb3JJbnRlcmNlcHRvcltdID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGluamVjdG9yOiBJbmplY3RvciwgcHJpdmF0ZSBwcm9taXNlVXRpbHM6IFByb21pc2VVdGlscykge31cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2UjYWRkSW50ZXJjZXB0b3JcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6aHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBZGQgYSBuZXcgZXJyb3IgaW50ZXJjZXB0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW50ZXJjZXB0b3IgVGhlIGludGVyY2VwdG9yIHtPYmplY3R9IG9yIGFuZ3VsYXIgRmFjdG9yeVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiB0byBjYWxsIHRvIHVucmVnaXN0ZXIgdGhlIGludGVyY2VwdG9yIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiAgICAgIC8vIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB3aXRoIGFuIGluc3RhbmNlIG9mIElIdHRwRXJyb3JJbnRlcmNlcHRvcjpcbiAgICAgKiAgICAgIHZhciB1bnJlZ2lzdGVyQ3VzdG9tSW50ZXJjZXB0b3IgPSBodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2UuYWRkSW50ZXJjZXB0b3Ioe1xuICAgICAqICAgICAgICAgIHByZWRpY2F0ZTogZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwO1xuICAgICAqICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgKiAgICAgICAgICAgICAgYWxlcnRTZXJ2aWNlLnNob3dEYW5nZXIoe1xuICAgICAqICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZVxuICAgICAqICAgICAgICAgICAgICB9KTtcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlc3BvbnNlKTsvLyBGSVhNRTogdXBkYXRlIGRvY1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogICAgICAvLyBBZGQgYW4gaW50ZXJjZXB0b3Igd2l0aCBhIGNsYXNzIG9mIElIdHRwRXJyb3JJbnRlcmNlcHRvcjpcbiAgICAgKiAgICAgIHZhciB1bnJlZ2lzdGVyQ3VzdG9tSW50ZXJjZXB0b3IgPSBodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2UuYWRkSW50ZXJjZXB0b3IoQ3VzdG9tRXJyb3JJbnRlcmNlcHRvcik7XG4gICAgICpcbiAgICAgKiAgICAgIC8vIFVucmVnaXN0ZXIgdGhlIGludGVyY2VwdG9yOlxuICAgICAqICAgICAgdW5yZWdpc3RlckN1c3RvbUludGVyY2VwdG9yKCk7XG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICBhZGRJbnRlcmNlcHRvcnMoXG4gICAgICAgIGludGVyY2VwdG9yQ2xhc3NlczogKENsYXNzPElIdHRwRXJyb3JJbnRlcmNlcHRvcj4gfCBJSHR0cEVycm9ySW50ZXJjZXB0b3IpW11cbiAgICApOiB2b2lkIHtcbiAgICAgICAgaW50ZXJjZXB0b3JDbGFzc2VzLmZvckVhY2goKEludGVyY2VwdG9yQ2xhc3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50ZXJjZXB0b3IoSW50ZXJjZXB0b3JDbGFzcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZEludGVyY2VwdG9yKF9pbnRlcmNlcHRvcjogQ2xhc3M8SUh0dHBFcnJvckludGVyY2VwdG9yPiB8IElIdHRwRXJyb3JJbnRlcmNlcHRvcik6ICgpID0+IHZvaWQge1xuICAgICAgICBsZXQgaW50ZXJjZXB0b3I6IElIdHRwRXJyb3JJbnRlcmNlcHRvcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKF9pbnRlcmNlcHRvciBhcyBJSHR0cEVycm9ySW50ZXJjZXB0b3IpLnByZWRpY2F0ZSB8fFxuICAgICAgICAgICAgKF9pbnRlcmNlcHRvciBhcyBJSHR0cEVycm9ySW50ZXJjZXB0b3IpLnJlc3BvbnNlRXJyb3JcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRvciA9IF9pbnRlcmNlcHRvciBhcyBJSHR0cEVycm9ySW50ZXJjZXB0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRvciA9IHRoaXMuaW5qZWN0b3IuZ2V0KF9pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbnRlcmNlcHRvcihpbnRlcmNlcHRvcik7XG4gICAgICAgIHRoaXMuX2Vycm9ySW50ZXJjZXB0b3JzLnVuc2hpZnQoaW50ZXJjZXB0b3IpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckludGVyY2VwdG9ycy5zcGxpY2UodGhpcy5fZXJyb3JJbnRlcmNlcHRvcnMuaW5kZXhPZihpbnRlcmNlcHRvciksIDEpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlc3BvbnNlRXJyb3I8VD4oXG4gICAgICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PFQ+LFxuICAgICAgICByZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2VcbiAgICApOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxUPj4ge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0Vycm9ySW50ZXJjZXB0b3JzID0gdGhpcy5fZXJyb3JJbnRlcmNlcHRvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGVycm9ySW50ZXJjZXB0b3IpID0+IGVycm9ySW50ZXJjZXB0b3IucHJlZGljYXRlKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBfaW50ZXJjZXB0b3JzRGVmZXJyZWQ6IERlZmVycmVkPGFueT4gPSB0aGlzLnByb21pc2VVdGlscy5kZWZlcjxhbnk+KCk7XG4gICAgICAgIGlmIChtYXRjaGluZ0Vycm9ySW50ZXJjZXB0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faXRlcmF0ZUVycm9ySW50ZXJjZXB0b3JzPFQ+KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBsb2Rhc2guY2xvbmVEZWVwKHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0Vycm9ySW50ZXJjZXB0b3JzLFxuICAgICAgICAgICAgICAgIF9pbnRlcmNlcHRvcnNEZWZlcnJlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pbnRlcmNlcHRvcnNEZWZlcnJlZC5yZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tKF9pbnRlcmNlcHRvcnNEZWZlcnJlZC5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pdGVyYXRlRXJyb3JJbnRlcmNlcHRvcnM8VD4oXG4gICAgICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PFQ+LFxuICAgICAgICByZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2UsXG4gICAgICAgIGludGVyY2VwdG9yczogSUh0dHBFcnJvckludGVyY2VwdG9yW10sXG4gICAgICAgIF9pbnRlcmNlcHRvcnNEZWZlcnJlZDogRGVmZXJyZWQ8YW55PixcbiAgICAgICAgaWR4OiBudW1iZXIgPSAwXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmIChpZHggPT09IGludGVyY2VwdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIF9pbnRlcmNlcHRvcnNEZWZlcnJlZC5yZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0ZUZuID0gdGhpcy5faXRlcmF0ZUVycm9ySW50ZXJjZXB0b3JzLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAvLyBGSVhNRTogZnVsbHkgY29udmVydCB0aGlzIHBhcnQgdG8gT2JzZXJ2YWJsZSBjaGFpbmluZ1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGludGVyY2VwdG9yc1tpZHhdLnJlc3BvbnNlRXJyb3IocmVxdWVzdCwgcmVzcG9uc2UpKS50aGVuKFxuICAgICAgICAgICAgICAgIChpbnRlcmNlcHRlZFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcmNlcHRvcnNEZWZlcnJlZC5yZXNvbHZlKGludGVyY2VwdGVkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGludGVyY2VwdGVkUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUZuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyY2VwdGVkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW50ZXJjZXB0b3JzRGVmZXJyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICArK2lkeFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICogVmFsaWRhdGUgaWYgdGhlIHByb3ZpZGVkIGludGVyY2VwdG9yIHJlc3BlY3RzIHRoZSBJbnRlcmZhY2UgKHByZWRpY2F0ZSBhbmQgcmVzcG9uc2VFcnJvciBmdW5jdGlvbnMgYXJlIG1hbmRhdG9yeSkuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnRlcmNlcHRvciBUaGUgaW50ZXJjZXB0b3Ige09iamVjdH0gb3IgYW5ndWxhciBGYWN0b3J5XG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVJbnRlcmNlcHRvcihpbnRlcmNlcHRvcjogSUh0dHBFcnJvckludGVyY2VwdG9yKSB7XG4gICAgICAgIGlmICghaW50ZXJjZXB0b3IucHJlZGljYXRlIHx8IHR5cGVvZiBpbnRlcmNlcHRvci5wcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnaHR0cEVycm9ySW50ZXJjZXB0b3JTZXJ2aWNlLmFkZEludGVyY2VwdG9yLmVycm9yLmludGVyY2VwdG9yLmhhcy5uby5wcmVkaWNhdGUnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW50ZXJjZXB0b3IucmVzcG9uc2VFcnJvciB8fCB0eXBlb2YgaW50ZXJjZXB0b3IucmVzcG9uc2VFcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdodHRwRXJyb3JJbnRlcmNlcHRvclNlcnZpY2UuYWRkSW50ZXJjZXB0b3IuZXJyb3IuaW50ZXJjZXB0b3IuaGFzLm5vLnJlc3BvbnNlRXJyb3InXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19