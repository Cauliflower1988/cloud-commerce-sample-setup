/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ContentChildren, Directive, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { DndContainerDirective } from '../dnd-container/dnd-container.directive';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/**
 * @record
 */
export function ElementChord() { }
if (false) {
    /** @type {?} */
    ElementChord.prototype.x;
    /** @type {?} */
    ElementChord.prototype.y;
    /** @type {?} */
    ElementChord.prototype.position;
}
var DndListDirective = /** @class */ (function () {
    function DndListDirective() {
        /**
         * Defines if the distance between elements should be counted only by vertical distance
         */
        this.listMode = false;
        /**
         * Event that is thrown, when the item is dropped
         */
        this.itemsChange = new EventEmitter();
        /**
         * @hidden
         */
        this.draggedItemIndex = 1000000;
        /**
         * @hidden
         */
        this.closestLinkIndex = null;
        /**
         * @hidden
         */
        this.closestLinkPosition = null;
        /**
         * An RxJS Subject that will kill the current data stream (for unsubscribing)
         */
        this.refresh$ = new Subject();
    }
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    DndListDirective.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.refreshQueryList();
        this.dndContainerItems.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this.refreshQueryList(); }));
    };
    /** Method called, when the item is being moved by 1 px */
    /**
     * Method called, when the item is being moved by 1 px
     * @param {?} event
     * @return {?}
     */
    DndListDirective.prototype.onMove = /**
     * Method called, when the item is being moved by 1 px
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var distances = [];
        /**
         * Taking mouse position
         * @type {?}
         */
        var mousePosition = event.pointerPosition;
        /** Counting the distances by the mileage of the corner of element and cursor position */
        this.elementChords.forEach((/**
         * @param {?} linkChord
         * @return {?}
         */
        function (linkChord) {
            /** @type {?} */
            var distance = Math.hypot(linkChord.x - mousePosition.x, linkChord.y - mousePosition.y);
            distances.push(distance);
        }));
        /**
         * Checking closest element
         * @type {?}
         */
        var closeLinkIndex = distances.indexOf(Math.min.apply(Math, tslib_1.__spread(distances)));
        /** If the closest element is different than the old one, new one is picked. It prevents from performance issues */
        if (closeLinkIndex !== this.closestLinkIndex) {
            this.closestLinkIndex = closeLinkIndex;
            this.closestLinkPosition = this.elementChords[closeLinkIndex].position;
            /** Generating line, that shows where the element will be placed, on drop */
            this.generateLine(this.closestLinkIndex, this.closestLinkPosition);
        }
    };
    /** Method called, when element is started to be dragged */
    /**
     * Method called, when element is started to be dragged
     * @param {?} ind
     * @return {?}
     */
    DndListDirective.prototype.dragStart = /**
     * Method called, when element is started to be dragged
     * @param {?} ind
     * @return {?}
     */
    function (ind) {
        var _this = this;
        this.draggedItemIndex = ind;
        /** @type {?} */
        var draggedItemElement = this.dndContainerItems.toArray()[ind].element;
        /** Counting all of the elements's chords */
        this.elementChords = this.dndContainerItems.toArray().map((/**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            return link.getElementChord(_this.isBefore(draggedItemElement, link.element), _this.listMode);
        }));
    };
    /** Method called, when element is released */
    /**
     * Method called, when element is released
     * @return {?}
     */
    DndListDirective.prototype.dragEnd = /**
     * Method called, when element is released
     * @return {?}
     */
    function () {
        /** @type {?} */
        var draggedItemIndex = this.draggedItemIndex;
        /** @type {?} */
        var replacedItemIndex = this.closestLinkIndex;
        /** @type {?} */
        var draggedItem = this.items[draggedItemIndex];
        if (draggedItemIndex < replacedItemIndex) {
            for (var i = draggedItemIndex; i < replacedItemIndex; i++) {
                this.items[i] = this.items[i + 1];
            }
        }
        else {
            for (var i = draggedItemIndex; i > replacedItemIndex; i--) {
                this.items[i] = this.items[i - 1];
            }
        }
        /** Replacing items */
        this.items[replacedItemIndex] = draggedItem;
        this.itemsChange.emit(this.items);
        this.removeAllLines();
        /** Reset */
        this.elementChords = [];
        this.closestLinkIndex = null;
        this.closestLinkPosition = null;
    };
    /** @hidden */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    DndListDirective.prototype.removeAllLines = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        this.dndContainerItems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item.removeLine(); }));
    };
    /** @hidden */
    /**
     * @hidden
     * @private
     * @param {?} closestLinkIndex
     * @param {?} linkPosition
     * @return {?}
     */
    DndListDirective.prototype.generateLine = /**
     * @hidden
     * @private
     * @param {?} closestLinkIndex
     * @param {?} linkPosition
     * @return {?}
     */
    function (closestLinkIndex, linkPosition) {
        this.removeAllLines();
        this.dndContainerItems.toArray()[closestLinkIndex].createLine(linkPosition, this.listMode);
    };
    /** @hidden */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    DndListDirective.prototype.refreshQueryList = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.refresh$.next();
        this.dndContainerItems.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        function (item, index) {
            item.moved.pipe(takeUntil(_this.refresh$)).subscribe((/**
             * @param {?} eventMove
             * @return {?}
             */
            function (eventMove) { return _this.onMove(eventMove); }));
            item.started.pipe(takeUntil(_this.refresh$)).subscribe((/**
             * @return {?}
             */
            function () { return _this.dragStart(index); }));
            item.released.pipe(takeUntil(_this.refresh$)).subscribe((/**
             * @return {?}
             */
            function () { return _this.dragEnd(); }));
        }));
    };
    /**
     *  @hidden
     * Return information if element is placed before the dragged element
     */
    /**
     * @hidden
     * Return information if element is placed before the dragged element
     * @private
     * @param {?} draggedElement
     * @param {?} targetElement
     * @return {?}
     */
    DndListDirective.prototype.isBefore = /**
     * @hidden
     * Return information if element is placed before the dragged element
     * @private
     * @param {?} draggedElement
     * @param {?} targetElement
     * @return {?}
     */
    function (draggedElement, targetElement) {
        /**
         * Sometimes the element are not straight in one column, that's why offset is needed
         * @type {?}
         */
        var VERTICAL_OFFSET = 20;
        /**
         * Distances from the top of screen
         * @type {?}
         */
        var draggedElementBound = (/** @type {?} */ (draggedElement.nativeElement.getBoundingClientRect()));
        /** @type {?} */
        var targetElementBound = (/** @type {?} */ (targetElement.nativeElement.getBoundingClientRect()));
        if (draggedElementBound.y - targetElementBound.y > VERTICAL_OFFSET) {
            /** If element is higher than the dragged element, it's for sure before */
            return true;
        }
        else if (targetElementBound.y - draggedElementBound.y > VERTICAL_OFFSET) {
            /** If element is lower than the dragged element, it's for sure after */
            return false;
        }
        else {
            /** If elements are in same level, the horizontal position decides if it's before/after */
            return draggedElementBound.x - targetElementBound.x > 0;
        }
    };
    DndListDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: '[fd-dnd-list]',
                },] }
    ];
    DndListDirective.propDecorators = {
        dndContainerItems: [{ type: ContentChildren, args: [DndContainerDirective,] }],
        listMode: [{ type: Input }],
        items: [{ type: Input }],
        itemsChange: [{ type: Output }]
    };
    return DndListDirective;
}());
export { DndListDirective };
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    DndListDirective.prototype.dndContainerItems;
    /**
     * Defines if the distance between elements should be counted only by vertical distance
     * @type {?}
     */
    DndListDirective.prototype.listMode;
    /**
     * Array of items, that will be sorted
     * @type {?}
     */
    DndListDirective.prototype.items;
    /**
     * Event that is thrown, when the item is dropped
     * @type {?}
     */
    DndListDirective.prototype.itemsChange;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.elementChords;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.draggedItemIndex;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.closestLinkIndex;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    DndListDirective.prototype.closestLinkPosition;
    /**
     * An RxJS Subject that will kill the current data stream (for unsubscribing)
     * @type {?}
     * @private
     */
    DndListDirective.prototype.refresh$;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG5kLWxpc3QuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL2RyYWctYW5kLWRyb3AvZG5kLWxpc3QvZG5kLWxpc3QuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFvQixlQUFlLEVBQUUsU0FBUyxFQUFjLFlBQVksRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6SSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUNqRixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUszQyxrQ0FJQzs7O0lBSEcseUJBQVU7O0lBQ1YseUJBQVU7O0lBQ1YsZ0NBQXVCOztBQUczQjtJQUFBOzs7O1FBWUksYUFBUSxHQUFZLEtBQUssQ0FBQzs7OztRQVFqQixnQkFBVyxHQUE2QixJQUFJLFlBQVksRUFBTyxDQUFDOzs7O1FBTWpFLHFCQUFnQixHQUFXLE9BQU8sQ0FBQzs7OztRQUduQyxxQkFBZ0IsR0FBVyxJQUFJLENBQUM7Ozs7UUFHaEMsd0JBQW1CLEdBQXVCLElBQUksQ0FBQzs7OztRQUd0QyxhQUFRLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUM7SUF5SG5FLENBQUM7SUF2SEcsY0FBYzs7Ozs7SUFDUCw2Q0FBa0I7Ozs7SUFBekI7UUFBQSxpQkFHQztRQUZHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsU0FBUzs7O1FBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUF2QixDQUF1QixFQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVELDBEQUEwRDs7Ozs7O0lBQzFELGlDQUFNOzs7OztJQUFOLFVBQU8sS0FBa0I7O1lBQ2YsU0FBUyxHQUFrQixFQUFFOzs7OztZQUc3QixhQUFhLEdBR2YsS0FBSyxDQUFDLGVBQWU7UUFFekIseUZBQXlGO1FBQ3pGLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTzs7OztRQUFDLFVBQUEsU0FBUzs7Z0JBQzFCLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDekYsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QixDQUFDLEVBQUMsQ0FBQzs7Ozs7WUFHRyxjQUFjLEdBQVcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFSLElBQUksbUJBQVEsU0FBUyxHQUFFO1FBRXhFLG1IQUFtSDtRQUNuSCxJQUFJLGNBQWMsS0FBSyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGNBQWMsQ0FBQztZQUN2QyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDdkUsNEVBQTRFO1lBQzVFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RFO0lBQ0wsQ0FBQztJQUVELDJEQUEyRDs7Ozs7O0lBQzNELG9DQUFTOzs7OztJQUFULFVBQVUsR0FBVztRQUFyQixpQkFPQztRQU5HLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLENBQUM7O1lBQ3RCLGtCQUFrQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPO1FBQ3hFLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHOzs7O1FBQUMsVUFBQyxJQUFJO1lBQzNELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEcsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsOENBQThDOzs7OztJQUM5QyxrQ0FBTzs7OztJQUFQOztZQUVVLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQkFBZ0I7O1lBQ3hDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxnQkFBZ0I7O1lBQ3pDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDO1FBRWhELElBQUksZ0JBQWdCLEdBQUcsaUJBQWlCLEVBQUU7WUFDdEMsS0FBSyxJQUFJLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDckM7U0FDSjthQUFNO1lBQ0gsS0FBSyxJQUFJLENBQUMsR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDckM7U0FDSjtRQUVELHNCQUFzQjtRQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsV0FBVyxDQUFDO1FBRTVDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFdEIsWUFBWTtRQUNaLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBRUQsY0FBYzs7Ozs7O0lBQ04seUNBQWM7Ozs7O0lBQXRCO1FBQ0ksSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU87Ozs7UUFBQyxVQUFBLElBQUksSUFBSSxPQUFBLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBakIsQ0FBaUIsRUFBQyxDQUFDO0lBQzlELENBQUM7SUFFRCxjQUFjOzs7Ozs7OztJQUNOLHVDQUFZOzs7Ozs7O0lBQXBCLFVBQXFCLGdCQUF3QixFQUFFLFlBQTBCO1FBQ3JFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvRixDQUFDO0lBRUQsY0FBYzs7Ozs7O0lBQ04sMkNBQWdCOzs7OztJQUF4QjtRQUFBLGlCQU9DO1FBTkcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTzs7Ozs7UUFBQyxVQUFDLElBQUksRUFBRSxLQUFLO1lBQ3ZDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTOzs7O1lBQUMsVUFBQSxTQUFTLElBQUksT0FBQSxLQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUF0QixDQUFzQixFQUFDLENBQUM7WUFDekYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVM7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFyQixDQUFxQixFQUFDLENBQUM7WUFDbkYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVM7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsT0FBTyxFQUFFLEVBQWQsQ0FBYyxFQUFDLENBQUM7UUFDakYsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHOzs7Ozs7Ozs7SUFDSyxtQ0FBUTs7Ozs7Ozs7SUFBaEIsVUFBaUIsY0FBMEIsRUFBRSxhQUF5Qjs7Ozs7WUFHNUQsZUFBZSxHQUFXLEVBQUU7Ozs7O1lBRzVCLG1CQUFtQixHQUFHLG1CQUFTLGNBQWMsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsRUFBQTs7WUFDbkYsa0JBQWtCLEdBQUcsbUJBQVMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxFQUFBO1FBRXZGLElBQUksbUJBQW1CLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsR0FBRyxlQUFlLEVBQUU7WUFDaEUsMEVBQTBFO1lBQzFFLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7YUFBTSxJQUFJLGtCQUFrQixDQUFDLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcsZUFBZSxFQUFFO1lBQ3ZFLHdFQUF3RTtZQUN4RSxPQUFPLEtBQUssQ0FBQztTQUNoQjthQUFNO1lBQ0gsMEZBQTBGO1lBQzFGLE9BQU8sbUJBQW1CLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0Q7SUFDTCxDQUFDOztnQkEzSkosU0FBUyxTQUFDOztvQkFFVCxRQUFRLEVBQUUsZUFBZTtpQkFDMUI7OztvQ0FJSSxlQUFlLFNBQUMscUJBQXFCOzJCQUlyQyxLQUFLO3dCQUlMLEtBQUs7OEJBSUwsTUFBTTs7SUF5SVgsdUJBQUM7Q0FBQSxBQTVKRCxJQTRKQztTQXhKWSxnQkFBZ0I7Ozs7OztJQUd6Qiw2Q0FDb0Q7Ozs7O0lBR3BELG9DQUMwQjs7Ozs7SUFHMUIsaUNBQ3lCOzs7OztJQUd6Qix1Q0FDeUU7Ozs7OztJQUd6RSx5Q0FBc0M7Ozs7OztJQUd0Qyw0Q0FBMkM7Ozs7OztJQUczQyw0Q0FBd0M7Ozs7OztJQUd4QywrQ0FBdUQ7Ozs7OztJQUd2RCxvQ0FBK0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrRHJhZywgQ2RrRHJhZ01vdmUgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7IERuZENvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4uL2RuZC1jb250YWluZXIvZG5kLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5cbmV4cG9ydCB0eXBlIExpbmtQb3NpdGlvbiA9ICdhZnRlcicgfCAnYmVmb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50Q2hvcmQge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgcG9zaXRpb246IExpbmtQb3NpdGlvbjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICBzZWxlY3RvcjogJ1tmZC1kbmQtbGlzdF0nLFxufSlcbmV4cG9ydCBjbGFzcyBEbmRMaXN0RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oRG5kQ29udGFpbmVyRGlyZWN0aXZlKVxuICAgIGRuZENvbnRhaW5lckl0ZW1zOiBRdWVyeUxpc3Q8RG5kQ29udGFpbmVyRGlyZWN0aXZlPjtcblxuICAgIC8qKiBEZWZpbmVzIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVsZW1lbnRzIHNob3VsZCBiZSBjb3VudGVkIG9ubHkgYnkgdmVydGljYWwgZGlzdGFuY2UgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3RNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQXJyYXkgb2YgaXRlbXMsIHRoYXQgd2lsbCBiZSBzb3J0ZWQgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpdGVtczogQXJyYXk8YW55PjtcblxuICAgIC8qKiBFdmVudCB0aGF0IGlzIHRocm93biwgd2hlbiB0aGUgaXRlbSBpcyBkcm9wcGVkICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgaXRlbXNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxBcnJheTxhbnk+PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIGVsZW1lbnRDaG9yZHM6IEVsZW1lbnRDaG9yZFtdO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIGRyYWdnZWRJdGVtSW5kZXg6IG51bWJlciA9IDEwMDAwMDA7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgY2xvc2VzdExpbmtJbmRleDogbnVtYmVyID0gbnVsbDtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJpdmF0ZSBjbG9zZXN0TGlua1Bvc2l0aW9uOiAnYmVmb3JlJyB8ICdhZnRlcicgPSBudWxsO1xuXG4gICAgLyoqIEFuIFJ4SlMgU3ViamVjdCB0aGF0IHdpbGwga2lsbCB0aGUgY3VycmVudCBkYXRhIHN0cmVhbSAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVmcmVzaCQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlZnJlc2hRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5kbmRDb250YWluZXJJdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlZnJlc2hRdWVyeUxpc3QoKSk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCBjYWxsZWQsIHdoZW4gdGhlIGl0ZW0gaXMgYmVpbmcgbW92ZWQgYnkgMSBweCAqL1xuICAgIG9uTW92ZShldmVudDogQ2RrRHJhZ01vdmUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VzOiBBcnJheTxudW1iZXI+ID0gW107XG5cbiAgICAgICAgLyoqIFRha2luZyBtb3VzZSBwb3NpdGlvbiAqL1xuICAgICAgICBjb25zdCBtb3VzZVBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgICAgICB5OiBudW1iZXI7XG4gICAgICAgIH0gPSBldmVudC5wb2ludGVyUG9zaXRpb247XG5cbiAgICAgICAgLyoqIENvdW50aW5nIHRoZSBkaXN0YW5jZXMgYnkgdGhlIG1pbGVhZ2Ugb2YgdGhlIGNvcm5lciBvZiBlbGVtZW50IGFuZCBjdXJzb3IgcG9zaXRpb24gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50Q2hvcmRzLmZvckVhY2gobGlua0Nob3JkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChsaW5rQ2hvcmQueCAtIG1vdXNlUG9zaXRpb24ueCwgbGlua0Nob3JkLnkgLSBtb3VzZVBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goZGlzdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiogQ2hlY2tpbmcgY2xvc2VzdCBlbGVtZW50ICovXG4gICAgICAgIGNvbnN0IGNsb3NlTGlua0luZGV4OiBudW1iZXIgPSBkaXN0YW5jZXMuaW5kZXhPZihNYXRoLm1pbiguLi5kaXN0YW5jZXMpKTtcblxuICAgICAgICAvKiogSWYgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkIG9uZSwgbmV3IG9uZSBpcyBwaWNrZWQuIEl0IHByZXZlbnRzIGZyb20gcGVyZm9ybWFuY2UgaXNzdWVzICovXG4gICAgICAgIGlmIChjbG9zZUxpbmtJbmRleCAhPT0gdGhpcy5jbG9zZXN0TGlua0luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3Nlc3RMaW5rSW5kZXggPSBjbG9zZUxpbmtJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VzdExpbmtQb3NpdGlvbiA9IHRoaXMuZWxlbWVudENob3Jkc1tjbG9zZUxpbmtJbmRleF0ucG9zaXRpb247XG4gICAgICAgICAgICAvKiogR2VuZXJhdGluZyBsaW5lLCB0aGF0IHNob3dzIHdoZXJlIHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkLCBvbiBkcm9wICovXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlTGluZSh0aGlzLmNsb3Nlc3RMaW5rSW5kZXgsIHRoaXMuY2xvc2VzdExpbmtQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGNhbGxlZCwgd2hlbiBlbGVtZW50IGlzIHN0YXJ0ZWQgdG8gYmUgZHJhZ2dlZCAqL1xuICAgIGRyYWdTdGFydChpbmQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtSW5kZXggPSBpbmQ7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtRWxlbWVudCA9IHRoaXMuZG5kQ29udGFpbmVySXRlbXMudG9BcnJheSgpW2luZF0uZWxlbWVudDtcbiAgICAgICAgLyoqIENvdW50aW5nIGFsbCBvZiB0aGUgZWxlbWVudHMncyBjaG9yZHMgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50Q2hvcmRzID0gdGhpcy5kbmRDb250YWluZXJJdGVtcy50b0FycmF5KCkubWFwKChsaW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluay5nZXRFbGVtZW50Q2hvcmQodGhpcy5pc0JlZm9yZShkcmFnZ2VkSXRlbUVsZW1lbnQsIGxpbmsuZWxlbWVudCksIHRoaXMubGlzdE1vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGNhbGxlZCwgd2hlbiBlbGVtZW50IGlzIHJlbGVhc2VkICovXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbUluZGV4ID0gdGhpcy5kcmFnZ2VkSXRlbUluZGV4O1xuICAgICAgICBjb25zdCByZXBsYWNlZEl0ZW1JbmRleCA9IHRoaXMuY2xvc2VzdExpbmtJbmRleDtcbiAgICAgICAgY29uc3QgZHJhZ2dlZEl0ZW0gPSB0aGlzLml0ZW1zW2RyYWdnZWRJdGVtSW5kZXhdO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkSXRlbUluZGV4IDwgcmVwbGFjZWRJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkcmFnZ2VkSXRlbUluZGV4OyBpIDwgcmVwbGFjZWRJdGVtSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0gPSB0aGlzLml0ZW1zW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkcmFnZ2VkSXRlbUluZGV4OyBpID4gcmVwbGFjZWRJdGVtSW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0gPSB0aGlzLml0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBSZXBsYWNpbmcgaXRlbXMgKi9cbiAgICAgICAgdGhpcy5pdGVtc1tyZXBsYWNlZEl0ZW1JbmRleF0gPSBkcmFnZ2VkSXRlbTtcblxuICAgICAgICB0aGlzLml0ZW1zQ2hhbmdlLmVtaXQodGhpcy5pdGVtcyk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaW5lcygpO1xuXG4gICAgICAgIC8qKiBSZXNldCAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRDaG9yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZXN0TGlua0luZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9zZXN0TGlua1Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgcmVtb3ZlQWxsTGluZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZG5kQ29udGFpbmVySXRlbXMuZm9yRWFjaChpdGVtID0+IGl0ZW0ucmVtb3ZlTGluZSgpKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVMaW5lKGNsb3Nlc3RMaW5rSW5kZXg6IG51bWJlciwgbGlua1Bvc2l0aW9uOiBMaW5rUG9zaXRpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaW5lcygpO1xuICAgICAgICB0aGlzLmRuZENvbnRhaW5lckl0ZW1zLnRvQXJyYXkoKVtjbG9zZXN0TGlua0luZGV4XS5jcmVhdGVMaW5lKGxpbmtQb3NpdGlvbiwgdGhpcy5saXN0TW9kZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIHJlZnJlc2hRdWVyeUxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVmcmVzaCQubmV4dCgpO1xuICAgICAgICB0aGlzLmRuZENvbnRhaW5lckl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtLm1vdmVkLnBpcGUodGFrZVVudGlsKHRoaXMucmVmcmVzaCQpKS5zdWJzY3JpYmUoZXZlbnRNb3ZlID0+IHRoaXMub25Nb3ZlKGV2ZW50TW92ZSkpO1xuICAgICAgICAgICAgaXRlbS5zdGFydGVkLnBpcGUodGFrZVVudGlsKHRoaXMucmVmcmVzaCQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcmFnU3RhcnQoaW5kZXgpKTtcbiAgICAgICAgICAgIGl0ZW0ucmVsZWFzZWQucGlwZSh0YWtlVW50aWwodGhpcy5yZWZyZXNoJCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyYWdFbmQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBAaGlkZGVuXG4gICAgICogUmV0dXJuIGluZm9ybWF0aW9uIGlmIGVsZW1lbnQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgZHJhZ2dlZCBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0JlZm9yZShkcmFnZ2VkRWxlbWVudDogRWxlbWVudFJlZiwgdGFyZ2V0RWxlbWVudDogRWxlbWVudFJlZik6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8qKiBTb21ldGltZXMgdGhlIGVsZW1lbnQgYXJlIG5vdCBzdHJhaWdodCBpbiBvbmUgY29sdW1uLCB0aGF0J3Mgd2h5IG9mZnNldCBpcyBuZWVkZWQgKi9cbiAgICAgICAgY29uc3QgVkVSVElDQUxfT0ZGU0VUOiBudW1iZXIgPSAyMDtcblxuICAgICAgICAvKiogRGlzdGFuY2VzIGZyb20gdGhlIHRvcCBvZiBzY3JlZW4gKi9cbiAgICAgICAgY29uc3QgZHJhZ2dlZEVsZW1lbnRCb3VuZCA9IDxET01SZWN0PmRyYWdnZWRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRCb3VuZCA9IDxET01SZWN0PnRhcmdldEVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRCb3VuZC55IC0gdGFyZ2V0RWxlbWVudEJvdW5kLnkgPiBWRVJUSUNBTF9PRkZTRVQpIHtcbiAgICAgICAgICAgIC8qKiBJZiBlbGVtZW50IGlzIGhpZ2hlciB0aGFuIHRoZSBkcmFnZ2VkIGVsZW1lbnQsIGl0J3MgZm9yIHN1cmUgYmVmb3JlICovXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRFbGVtZW50Qm91bmQueSAtIGRyYWdnZWRFbGVtZW50Qm91bmQueSA+IFZFUlRJQ0FMX09GRlNFVCkge1xuICAgICAgICAgICAgLyoqIElmIGVsZW1lbnQgaXMgbG93ZXIgdGhhbiB0aGUgZHJhZ2dlZCBlbGVtZW50LCBpdCdzIGZvciBzdXJlIGFmdGVyICovXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiogSWYgZWxlbWVudHMgYXJlIGluIHNhbWUgbGV2ZWwsIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIGRlY2lkZXMgaWYgaXQncyBiZWZvcmUvYWZ0ZXIgKi9cbiAgICAgICAgICAgIHJldHVybiBkcmFnZ2VkRWxlbWVudEJvdW5kLnggLSB0YXJnZXRFbGVtZW50Qm91bmQueCA+IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=