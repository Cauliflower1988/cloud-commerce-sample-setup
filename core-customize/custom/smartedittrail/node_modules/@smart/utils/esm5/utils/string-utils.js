/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * @ngdoc service
 * @name @smartutils.services:StringUtils
 *
 * @description
 * utility service around Strings.
 */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
        var _this = this;
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#sanitize
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * <b>escapes any harmful scripting from a string, leaves innocuous HTML untouched/b>
         * @param {String} a string that needs to be sanitized.
         *
         * @returns {String} the sanitized string.
         *
         */
        this.sanitize = function (str) {
            /* The correct solution for this is to use Negative Lookbehind Regex expression which is available as part of ES2018. // str.replace(/(?:(?<!\\)([()]))/g, '\\$1')
            But in order to support cross browser compatibility, the string is reversed and negative lookahead is used instead. */
            return !_this.isBlank(str)
                ? str
                    .split('')
                    .reverse()
                    .join('')
                    .replace(/(?:(([()])(?!\\)))/g, '$1\\')
                    .split('')
                    .reverse()
                    .join('')
                : str;
        };
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#encode
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * will return a encoded value for any JSON object passed as argument
         * @param {object} JSON object to be encoded
         */
        this.encode = function (object) {
            /* first we use encodeURIComponent to get percent-encoded UTF-8,
             * then we convert the percent encodings into raw bytes which
             * can be fed into btoa.
             * from https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
             */
            return btoa(encodeURIComponent(JSON.stringify(object)).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            }));
        };
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#replaceAll
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * will return a string where all matches for the string regexps keys passed in the substitutionMap will have been substituted by correspoing values in the substitutionMap
         * @param {string} string the string to substitute keys in object to be encoded
         * @param {TypedMap<string>} substitutionMap the map of string regexp to string substitution values
         * @returns {string} the substituted string
         */
        this.replaceAll = function (str, substitutionMap) {
            var regex = new RegExp(Object.keys(substitutionMap).join('|'), 'g');
            return str.replace(regex, function (matched) {
                return substitutionMap[matched];
            });
        };
    }
    /**
     * @ngdoc service
     * @name @smartutils.services:StringUtils#isBlank
     * @methodOf @smartutils.services:StringUtils
     *
     * @description
     * <b>isBlank</b> will check if a given string is undefined or null or empty.
     * - returns TRUE for undefined / null/ empty string
     * - returns FALSE otherwise
     *
     * @param {String} inputString any input string.
     *
     * @returns {boolean} true if the string is null else false
     */
    StringUtils.prototype.isBlank = function (value) {
        return (typeof value === 'undefined' ||
            value === null ||
            value === 'null' ||
            value.toString().trim().length === 0);
    };
    /**
     * @ngdoc method
     * @name @smartutils.services:StringUtils#regExpFactory
     * @methodOf @smartutils.services:StringUtils
     *
     * @description
     * <b>regExpFactory</b> will convert a given pattern into a regular expression.
     * This method will prepend and append a string with ^ and $ respectively replaces
     * and wildcards (*) by proper regex wildcards.
     *
     * @param {String} pattern any string that needs to be converted to a regular expression.
     *
     * @returns {RegExp} a regular expression generated from the given string.
     *
     */
    StringUtils.prototype.regExpFactory = function (pattern) {
        var onlyAlphanumericsRegex = new RegExp(/^[a-zA-Z\d]+$/i);
        var antRegex = new RegExp(/^[a-zA-Z\d\*]+$/i);
        var regexpKey;
        if (onlyAlphanumericsRegex.test(pattern)) {
            regexpKey = ['^', '$'].join(pattern);
        }
        else if (antRegex.test(pattern)) {
            regexpKey = ['^', '$'].join(pattern.replace(/\*/g, '.*'));
        }
        else {
            regexpKey = pattern;
        }
        return new RegExp(regexpKey, 'g');
    };
    /*
     * formats HTML outputs typically from Node.outerHTML to easy string comparison by:
     * - remove empty lines
     * - remove spaces between tags
     * - normalize remainign spaces to a single one
     *
     */
    StringUtils.prototype.formatHTML = function (rawHTML) {
        return rawHTML
            .replace(/^\s*\n/gm, '')
            .replace(/\>[\t\s]+\</g, '><')
            .replace(/[\r\n\t\s]+/g, ' ');
    };
    return StringUtils;
}());
export { StringUtils };
export var stringUtils = new StringUtils();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nLXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsidXRpbHMvc3RyaW5nLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBOzs7Ozs7R0FNRztBQUNIO0lBQUE7UUFBQSxpQkEySUM7UUFyRUc7Ozs7Ozs7Ozs7O1dBV0c7UUFDSCxhQUFRLEdBQUcsVUFBQyxHQUFXO1lBQ25CO2tJQUNzSDtZQUN0SCxPQUFPLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7Z0JBQ3JCLENBQUMsQ0FBQyxHQUFHO3FCQUNFLEtBQUssQ0FBQyxFQUFFLENBQUM7cUJBQ1QsT0FBTyxFQUFFO3FCQUNULElBQUksQ0FBQyxFQUFFLENBQUM7cUJBQ1IsT0FBTyxDQUFDLHFCQUFxQixFQUFFLE1BQU0sQ0FBQztxQkFDdEMsS0FBSyxDQUFDLEVBQUUsQ0FBQztxQkFDVCxPQUFPLEVBQUU7cUJBQ1QsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDZixDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2QsQ0FBQyxDQUFDO1FBRUY7Ozs7Ozs7O1dBUUc7UUFDSCxXQUFNLEdBQUcsVUFBQyxNQUFXO1lBQ2pCOzs7O2VBSUc7WUFDSCxPQUFPLElBQUksQ0FDUCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUM5QyxpQkFBaUIsRUFDakIsU0FBUyxZQUFZLENBQUMsS0FBVSxFQUFFLEVBQVU7Z0JBQ3hDLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDakQsQ0FBQyxDQUNKLENBQ0osQ0FBQztRQUNOLENBQUMsQ0FBQztRQUVGOzs7Ozs7Ozs7O1dBVUc7UUFDSCxlQUFVLEdBQUcsVUFBQyxHQUFXLEVBQUUsZUFBaUM7WUFDeEQsSUFBTSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdEUsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxVQUFTLE9BQU87Z0JBQ3RDLE9BQU8sZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQTFJRzs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsNkJBQU8sR0FBUCxVQUFRLEtBQVU7UUFDZCxPQUFPLENBQ0gsT0FBTyxLQUFLLEtBQUssV0FBVztZQUM1QixLQUFLLEtBQUssSUFBSTtZQUNkLEtBQUssS0FBSyxNQUFNO1lBQ2hCLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUN2QyxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBRUgsbUNBQWEsR0FBYixVQUFjLE9BQWU7UUFDekIsSUFBTSxzQkFBc0IsR0FBRyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzVELElBQU0sUUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFFaEQsSUFBSSxTQUFTLENBQUM7UUFDZCxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0QyxTQUFTLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3hDO2FBQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQy9CLFNBQVMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUM3RDthQUFNO1lBQ0gsU0FBUyxHQUFHLE9BQU8sQ0FBQztTQUN2QjtRQUVELE9BQU8sSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxnQ0FBVSxHQUFWLFVBQVcsT0FBZTtRQUN0QixPQUFPLE9BQU87YUFDVCxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQzthQUN2QixPQUFPLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQzthQUM3QixPQUFPLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUF1RUwsa0JBQUM7QUFBRCxDQUFDLEFBM0lELElBMklDOztBQUVELE1BQU0sQ0FBQyxJQUFNLFdBQVcsR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgU0FQIFNFIG9yIGFuIFNBUCBhZmZpbGlhdGUgY29tcGFueS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBtb2R1bGUgc21hcnR1dGlsc1xuICovXG5pbXBvcnQgeyBUeXBlZE1hcCB9IGZyb20gJy4uL2R0b3MnO1xuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIHV0aWxpdHkgc2VydmljZSBhcm91bmQgU3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ1V0aWxzIHtcbiAgICAvKipcbiAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzI2lzQmxhbmtcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxiPmlzQmxhbms8L2I+IHdpbGwgY2hlY2sgaWYgYSBnaXZlbiBzdHJpbmcgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgZW1wdHkuXG4gICAgICogLSByZXR1cm5zIFRSVUUgZm9yIHVuZGVmaW5lZCAvIG51bGwvIGVtcHR5IHN0cmluZ1xuICAgICAqIC0gcmV0dXJucyBGQUxTRSBvdGhlcndpc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFN0cmluZyBhbnkgaW5wdXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0cmluZyBpcyBudWxsIGVsc2UgZmFsc2VcbiAgICAgKi9cbiAgICBpc0JsYW5rKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gJ251bGwnIHx8XG4gICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHMjcmVnRXhwRmFjdG9yeVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPGI+cmVnRXhwRmFjdG9yeTwvYj4gd2lsbCBjb252ZXJ0IGEgZ2l2ZW4gcGF0dGVybiBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcHJlcGVuZCBhbmQgYXBwZW5kIGEgc3RyaW5nIHdpdGggXiBhbmQgJCByZXNwZWN0aXZlbHkgcmVwbGFjZXNcbiAgICAgKiBhbmQgd2lsZGNhcmRzICgqKSBieSBwcm9wZXIgcmVnZXggd2lsZGNhcmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gYW55IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9IGEgcmVndWxhciBleHByZXNzaW9uIGdlbmVyYXRlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKi9cblxuICAgIHJlZ0V4cEZhY3RvcnkocGF0dGVybjogc3RyaW5nKTogUmVnRXhwIHtcbiAgICAgICAgY29uc3Qgb25seUFscGhhbnVtZXJpY3NSZWdleCA9IG5ldyBSZWdFeHAoL15bYS16QS1aXFxkXSskL2kpO1xuICAgICAgICBjb25zdCBhbnRSZWdleCA9IG5ldyBSZWdFeHAoL15bYS16QS1aXFxkXFwqXSskL2kpO1xuXG4gICAgICAgIGxldCByZWdleHBLZXk7XG4gICAgICAgIGlmIChvbmx5QWxwaGFudW1lcmljc1JlZ2V4LnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJlZ2V4cEtleSA9IFsnXicsICckJ10uam9pbihwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbnRSZWdleC50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZWdleHBLZXkgPSBbJ14nLCAnJCddLmpvaW4ocGF0dGVybi5yZXBsYWNlKC9cXCovZywgJy4qJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVnZXhwS2V5ID0gcGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cEtleSwgJ2cnKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIGZvcm1hdHMgSFRNTCBvdXRwdXRzIHR5cGljYWxseSBmcm9tIE5vZGUub3V0ZXJIVE1MIHRvIGVhc3kgc3RyaW5nIGNvbXBhcmlzb24gYnk6XG4gICAgICogLSByZW1vdmUgZW1wdHkgbGluZXNcbiAgICAgKiAtIHJlbW92ZSBzcGFjZXMgYmV0d2VlbiB0YWdzXG4gICAgICogLSBub3JtYWxpemUgcmVtYWluaWduIHNwYWNlcyB0byBhIHNpbmdsZSBvbmVcbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1hdEhUTUwocmF3SFRNTDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHJhd0hUTUxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKlxcbi9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw+W1xcdFxcc10rXFw8L2csICc+PCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcblxcdFxcc10rL2csICcgJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIHNlcnZpY2VcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlscyNzYW5pdGl6ZVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPGI+ZXNjYXBlcyBhbnkgaGFybWZ1bCBzY3JpcHRpbmcgZnJvbSBhIHN0cmluZywgbGVhdmVzIGlubm9jdW91cyBIVE1MIHVudG91Y2hlZC9iPlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBzYW5pdGl6ZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgc2FuaXRpemUgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAvKiBUaGUgY29ycmVjdCBzb2x1dGlvbiBmb3IgdGhpcyBpcyB0byB1c2UgTmVnYXRpdmUgTG9va2JlaGluZCBSZWdleCBleHByZXNzaW9uIHdoaWNoIGlzIGF2YWlsYWJsZSBhcyBwYXJ0IG9mIEVTMjAxOC4gLy8gc3RyLnJlcGxhY2UoLyg/Oig/PCFcXFxcKShbKCldKSkvZywgJ1xcXFwkMScpXG4gICAgICAgIEJ1dCBpbiBvcmRlciB0byBzdXBwb3J0IGNyb3NzIGJyb3dzZXIgY29tcGF0aWJpbGl0eSwgdGhlIHN0cmluZyBpcyByZXZlcnNlZCBhbmQgbmVnYXRpdmUgbG9va2FoZWFkIGlzIHVzZWQgaW5zdGVhZC4gKi9cbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQmxhbmsoc3RyKVxuICAgICAgICAgICAgPyBzdHJcbiAgICAgICAgICAgICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg/OigoWygpXSkoPyFcXFxcKSkpL2csICckMVxcXFwnKVxuICAgICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICAgICA6IHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIHNlcnZpY2VcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlscyNlbmNvZGVcbiAgICAgKiBAbWV0aG9kT2YgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIHdpbGwgcmV0dXJuIGEgZW5jb2RlZCB2YWx1ZSBmb3IgYW55IEpTT04gb2JqZWN0IHBhc3NlZCBhcyBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBKU09OIG9iamVjdCB0byBiZSBlbmNvZGVkXG4gICAgICovXG4gICAgZW5jb2RlID0gKG9iamVjdDogYW55KTogYW55ID0+IHtcbiAgICAgICAgLyogZmlyc3Qgd2UgdXNlIGVuY29kZVVSSUNvbXBvbmVudCB0byBnZXQgcGVyY2VudC1lbmNvZGVkIFVURi04LFxuICAgICAgICAgKiB0aGVuIHdlIGNvbnZlcnQgdGhlIHBlcmNlbnQgZW5jb2RpbmdzIGludG8gcmF3IGJ5dGVzIHdoaWNoXG4gICAgICAgICAqIGNhbiBiZSBmZWQgaW50byBidG9hLlxuICAgICAgICAgKiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dCYXNlNjQvQmFzZTY0X2VuY29kaW5nX2FuZF9kZWNvZGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGJ0b2EoXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvJShbMC05QS1GXXsyfSkvZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b1NvbGlkQnl0ZXMobWF0Y2g6IGFueSwgcDE6IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHMjcmVwbGFjZUFsbFxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogd2lsbCByZXR1cm4gYSBzdHJpbmcgd2hlcmUgYWxsIG1hdGNoZXMgZm9yIHRoZSBzdHJpbmcgcmVnZXhwcyBrZXlzIHBhc3NlZCBpbiB0aGUgc3Vic3RpdHV0aW9uTWFwIHdpbGwgaGF2ZSBiZWVuIHN1YnN0aXR1dGVkIGJ5IGNvcnJlc3BvaW5nIHZhbHVlcyBpbiB0aGUgc3Vic3RpdHV0aW9uTWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0aGUgc3RyaW5nIHRvIHN1YnN0aXR1dGUga2V5cyBpbiBvYmplY3QgdG8gYmUgZW5jb2RlZFxuICAgICAqIEBwYXJhbSB7VHlwZWRNYXA8c3RyaW5nPn0gc3Vic3RpdHV0aW9uTWFwIHRoZSBtYXAgb2Ygc3RyaW5nIHJlZ2V4cCB0byBzdHJpbmcgc3Vic3RpdHV0aW9uIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzdWJzdGl0dXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICByZXBsYWNlQWxsID0gKHN0cjogc3RyaW5nLCBzdWJzdGl0dXRpb25NYXA6IFR5cGVkTWFwPHN0cmluZz4pID0+IHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKHN1YnN0aXR1dGlvbk1hcCkuam9pbignfCcpLCAnZycpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb25NYXBbbWF0Y2hlZF07XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdVdGlscyA9IG5ldyBTdHJpbmdVdGlscygpO1xuIl19