/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import * as tslib_1 from "tslib";
import { AbstractForm } from './abstract-form';
/**
 * A FormGrouping is used to encapsulate form data
 * of objects.
 */
var FormGrouping = /** @class */ (function (_super) {
    tslib_1.__extends(FormGrouping, _super);
    function FormGrouping(component, control, inputs, persist, parent, forms) {
        if (forms === void 0) { forms = {}; }
        var _this = _super.call(this, component, control, inputs, persist, parent) || this;
        _this.forms = forms;
        Object.keys(_this.forms).forEach(function (key) {
            _this.forms[key].parent = _this;
        });
        return _this;
    }
    /**
     * Adds a form element to the group.
     *
     * @param name
     * @param form
     */
    FormGrouping.prototype.addFormElement = function (name, form) {
        var _a;
        this.forms = tslib_1.__assign({}, this.forms, (_a = {}, _a[name] = form, _a));
        this.control.addControl(name, form.control);
        form.parent = this;
    };
    /**
     * Removes a form element from the group.
     *
     * @param {string} name
     */
    FormGrouping.prototype.removeFormElement = function (name) {
        if (!this.forms[name]) {
            return;
        }
        var _a = this.forms, _b = name, deleted = _a[_b], forms = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
        this.forms = forms;
        deleted.parent = null;
        this.control.removeControl(name);
    };
    /**
     * Get form element based on the string path.
     *
     * @param paths A dot notation path to the nested abstract form.
     * @returns Returns the AbstractForm based on the path. null if the child does not exists.
     */
    FormGrouping.prototype.getFormElement = function (paths) {
        return (Array.isArray(paths) ? paths : paths.split('.')).reduce(function (acc, path) {
            if (!acc || !acc.forms) {
                return null;
            }
            return acc.forms[path];
        }, this);
    };
    /**
     * Manually sets nested errors to each FormControl.
     *
     * Note: Method should be called on the next rendering cycle and not on the initialization of the form. Should be
     * used to enforce backend validation.
     *
     * @param errors
     */
    FormGrouping.prototype.setNestedErrors = function (errors) {
        var _this = this;
        if (errors === void 0) { errors = []; }
        errors.forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), path = _b[0], validationErrors = _b[1];
            var form = _this.getFormElement(path);
            /**
             * Fail if the form does not exist.
             */
            if (!form) {
                throw new Error("FormGrouping - Path not found when setting nested error: " + path);
            }
            form.control.setErrors(validationErrors);
        });
    };
    /**
     * Returns value of persistable nodes.
     * @return any
     */
    FormGrouping.prototype.getPersistedValue = function () {
        var _this = this;
        return Object.keys(this.forms).reduce(function (acc, key) {
            var child = _this.forms[key];
            /**
             * Look ahead and if nested does not want to be mapped, merge the nested object with
             * the current object.
             *
             * If it's a field, then it's undefined.
             *
             * If it's a group, then it will be merged.
             */
            if (!child.persist) {
                return tslib_1.__assign({}, acc, child.getPersistedValue());
            }
            acc[key] = child.getPersistedValue();
            return acc;
        }, {});
    };
    return FormGrouping;
}(AbstractForm));
export { FormGrouping };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1ncm91cGluZy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzbWFydC91dGlscy8iLCJzb3VyY2VzIjpbIm1vZHVsZXMvZm9ybS1idWlsZGVyL21vZGVscy9mb3JtLWdyb3VwaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFNQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFJL0M7OztHQUdHO0FBQ0g7SUFBa0Msd0NBQVk7SUFNMUMsc0JBQ0ksU0FBd0IsRUFDeEIsT0FBa0IsRUFDbEIsTUFBdUIsRUFDdkIsT0FBZ0IsRUFDaEIsTUFBMkIsRUFDcEIsS0FBeUI7UUFBekIsc0JBQUEsRUFBQSxVQUF5QjtRQU5wQyxZQVFJLGtCQUFNLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsU0FLckQ7UUFQVSxXQUFLLEdBQUwsS0FBSyxDQUFvQjtRQUloQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHO1lBQ2hDLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLEtBQUksQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQzs7SUFDUCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQ0FBYyxHQUFkLFVBQWUsSUFBWSxFQUFFLElBQWtCOztRQUMzQyxJQUFJLENBQUMsS0FBSyx3QkFBUSxJQUFJLENBQUMsS0FBSyxlQUFHLElBQUksSUFBRyxJQUFJLE1BQUUsQ0FBQztRQUM3QyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTVDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsd0NBQWlCLEdBQWpCLFVBQWtCLElBQVk7UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbkIsT0FBTztTQUNWO1FBRUQsSUFBTSxlQUEwQyxFQUF4QyxTQUFNLEVBQU4sZ0JBQWUsRUFBRSxtRUFBdUIsQ0FBQztRQUNqRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUV0QixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQ0FBYyxHQUFkLFVBQWUsS0FBd0I7UUFDbkMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FDM0QsVUFBQyxHQUFHLEVBQUUsSUFBSTtZQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFO2dCQUNwQixPQUFPLElBQUksQ0FBQzthQUNmO1lBQ0QsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNCLENBQUMsRUFDRCxJQUFXLENBQ2QsQ0FBQztJQUNOLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsc0NBQWUsR0FBZixVQUFnQixNQUFvRDtRQUFwRSxpQkFhQztRQWJlLHVCQUFBLEVBQUEsV0FBb0Q7UUFDaEUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQXdCO2dCQUF4QiwwQkFBd0IsRUFBdkIsWUFBSSxFQUFFLHdCQUFnQjtZQUNuQyxJQUFNLElBQUksR0FBRyxLQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXZDOztlQUVHO1lBQ0gsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDUCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE0RCxJQUFNLENBQUMsQ0FBQzthQUN2RjtZQUVELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0NBQWlCLEdBQWpCO1FBQUEsaUJBc0JDO1FBckJHLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUNqQyxVQUFDLEdBQUcsRUFBRSxHQUFHO1lBQ0wsSUFBTSxLQUFLLEdBQUcsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUU5Qjs7Ozs7OztlQU9HO1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7Z0JBQ2hCLDRCQUFZLEdBQUcsRUFBSyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsRUFBRzthQUNuRDtZQUVELEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUNyQyxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUMsRUFDRCxFQUFTLENBQ1osQ0FBQztJQUNOLENBQUM7SUFDTCxtQkFBQztBQUFELENBQUMsQUF2SEQsQ0FBa0MsWUFBWSxHQXVIN0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCB7IEZvcm1Hcm91cCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQWJzdHJhY3RGb3JtIH0gZnJvbSAnLi9hYnN0cmFjdC1mb3JtJztcbmltcG9ydCB7IEFic3RyYWN0Rm9ybXMsIENvbXBvbmVudFR5cGUgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgSW5wdXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnB1dC1wcm9wZXJ0aWVzJztcblxuLyoqXG4gKiBBIEZvcm1Hcm91cGluZyBpcyB1c2VkIHRvIGVuY2Fwc3VsYXRlIGZvcm0gZGF0YVxuICogb2Ygb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZvcm1Hcm91cGluZyBleHRlbmRzIEFic3RyYWN0Rm9ybSB7XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udHJvbCE6IEZvcm1Hcm91cDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgICAgIGNvbnRyb2w6IEZvcm1Hcm91cCxcbiAgICAgICAgaW5wdXRzOiBJbnB1dFByb3BlcnRpZXMsXG4gICAgICAgIHBlcnNpc3Q6IGJvb2xlYW4sXG4gICAgICAgIHBhcmVudDogQWJzdHJhY3RGb3JtIHwgbnVsbCxcbiAgICAgICAgcHVibGljIGZvcm1zOiBBYnN0cmFjdEZvcm1zID0ge31cbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29tcG9uZW50LCBjb250cm9sLCBpbnB1dHMsIHBlcnNpc3QsIHBhcmVudCk7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5mb3JtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvcm1zW2tleV0ucGFyZW50ID0gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZvcm0gZWxlbWVudCB0byB0aGUgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSBmb3JtXG4gICAgICovXG4gICAgYWRkRm9ybUVsZW1lbnQobmFtZTogc3RyaW5nLCBmb3JtOiBBYnN0cmFjdEZvcm0pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb3JtcyA9IHsgLi4udGhpcy5mb3JtcywgW25hbWVdOiBmb3JtIH07XG4gICAgICAgIHRoaXMuY29udHJvbC5hZGRDb250cm9sKG5hbWUsIGZvcm0uY29udHJvbCk7XG5cbiAgICAgICAgZm9ybS5wYXJlbnQgPSB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBmb3JtIGVsZW1lbnQgZnJvbSB0aGUgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUZvcm1FbGVtZW50KG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgW25hbWVdOiBkZWxldGVkLCAuLi5mb3JtcyB9ID0gdGhpcy5mb3JtcztcbiAgICAgICAgdGhpcy5mb3JtcyA9IGZvcm1zO1xuICAgICAgICBkZWxldGVkLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jb250cm9sLnJlbW92ZUNvbnRyb2wobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm0gZWxlbWVudCBiYXNlZCBvbiB0aGUgc3RyaW5nIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgQSBkb3Qgbm90YXRpb24gcGF0aCB0byB0aGUgbmVzdGVkIGFic3RyYWN0IGZvcm0uXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgQWJzdHJhY3RGb3JtIGJhc2VkIG9uIHRoZSBwYXRoLiBudWxsIGlmIHRoZSBjaGlsZCBkb2VzIG5vdCBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0Rm9ybUVsZW1lbnQocGF0aHM6IHN0cmluZyB8IHN0cmluZ1tdKTogQWJzdHJhY3RGb3JtIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwYXRocykgPyBwYXRocyA6IHBhdGhzLnNwbGl0KCcuJykpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjYyB8fCAhYWNjLmZvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjLmZvcm1zW3BhdGhdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMgYXMgYW55XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgc2V0cyBuZXN0ZWQgZXJyb3JzIHRvIGVhY2ggRm9ybUNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBOb3RlOiBNZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYW5kIG5vdCBvbiB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGZvcm0uIFNob3VsZCBiZVxuICAgICAqIHVzZWQgdG8gZW5mb3JjZSBiYWNrZW5kIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JzXG4gICAgICovXG4gICAgc2V0TmVzdGVkRXJyb3JzKGVycm9yczogW3N0cmluZ1tdIHwgc3RyaW5nLCBWYWxpZGF0aW9uRXJyb3JzXVtdID0gW10pOiB2b2lkIHtcbiAgICAgICAgZXJyb3JzLmZvckVhY2goKFtwYXRoLCB2YWxpZGF0aW9uRXJyb3JzXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9ybSA9IHRoaXMuZ2V0Rm9ybUVsZW1lbnQocGF0aCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFpbCBpZiB0aGUgZm9ybSBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFmb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtR3JvdXBpbmcgLSBQYXRoIG5vdCBmb3VuZCB3aGVuIHNldHRpbmcgbmVzdGVkIGVycm9yOiAke3BhdGh9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm0uY29udHJvbC5zZXRFcnJvcnModmFsaWRhdGlvbkVycm9ycyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmFsdWUgb2YgcGVyc2lzdGFibGUgbm9kZXMuXG4gICAgICogQHJldHVybiBhbnlcbiAgICAgKi9cbiAgICBnZXRQZXJzaXN0ZWRWYWx1ZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5mb3JtcykucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmZvcm1zW2tleV07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBMb29rIGFoZWFkIGFuZCBpZiBuZXN0ZWQgZG9lcyBub3Qgd2FudCB0byBiZSBtYXBwZWQsIG1lcmdlIHRoZSBuZXN0ZWQgb2JqZWN0IHdpdGhcbiAgICAgICAgICAgICAgICAgKiB0aGUgY3VycmVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBJZiBpdCdzIGEgZmllbGQsIHRoZW4gaXQncyB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBJZiBpdCdzIGEgZ3JvdXAsIHRoZW4gaXQgd2lsbCBiZSBtZXJnZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5wZXJzaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgLi4uY2hpbGQuZ2V0UGVyc2lzdGVkVmFsdWUoKSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFjY1trZXldID0gY2hpbGQuZ2V0UGVyc2lzdGVkVmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHt9IGFzIGFueVxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==