/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * @ngdoc service
 * @name @smartutils.services:StringUtils
 *
 * @description
 * utility service around Strings.
 */
export class StringUtils {
    constructor() {
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#sanitize
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * <b>escapes any harmful scripting from a string, leaves innocuous HTML untouched/b>
         * @param {String} a string that needs to be sanitized.
         *
         * @returns {String} the sanitized string.
         *
         */
        this.sanitize = (str) => {
            /* The correct solution for this is to use Negative Lookbehind Regex expression which is available as part of ES2018. // str.replace(/(?:(?<!\\)([()]))/g, '\\$1')
            But in order to support cross browser compatibility, the string is reversed and negative lookahead is used instead. */
            return !this.isBlank(str)
                ? str
                    .split('')
                    .reverse()
                    .join('')
                    .replace(/(?:(([()])(?!\\)))/g, '$1\\')
                    .split('')
                    .reverse()
                    .join('')
                : str;
        };
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#encode
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * will return a encoded value for any JSON object passed as argument
         * @param {object} JSON object to be encoded
         */
        this.encode = (object) => {
            /* first we use encodeURIComponent to get percent-encoded UTF-8,
             * then we convert the percent encodings into raw bytes which
             * can be fed into btoa.
             * from https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
             */
            return btoa(encodeURIComponent(JSON.stringify(object)).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            }));
        };
        /**
         * @ngdoc service
         * @name @smartutils.services:StringUtils#replaceAll
         * @methodOf @smartutils.services:StringUtils
         *
         * @description
         * will return a string where all matches for the string regexps keys passed in the substitutionMap will have been substituted by correspoing values in the substitutionMap
         * @param {string} string the string to substitute keys in object to be encoded
         * @param {TypedMap<string>} substitutionMap the map of string regexp to string substitution values
         * @returns {string} the substituted string
         */
        this.replaceAll = (str, substitutionMap) => {
            const regex = new RegExp(Object.keys(substitutionMap).join('|'), 'g');
            return str.replace(regex, function (matched) {
                return substitutionMap[matched];
            });
        };
    }
    /**
     * @ngdoc service
     * @name @smartutils.services:StringUtils#isBlank
     * @methodOf @smartutils.services:StringUtils
     *
     * @description
     * <b>isBlank</b> will check if a given string is undefined or null or empty.
     * - returns TRUE for undefined / null/ empty string
     * - returns FALSE otherwise
     *
     * @param {String} inputString any input string.
     *
     * @returns {boolean} true if the string is null else false
     */
    isBlank(value) {
        return (typeof value === 'undefined' ||
            value === null ||
            value === 'null' ||
            value.toString().trim().length === 0);
    }
    /**
     * @ngdoc method
     * @name @smartutils.services:StringUtils#regExpFactory
     * @methodOf @smartutils.services:StringUtils
     *
     * @description
     * <b>regExpFactory</b> will convert a given pattern into a regular expression.
     * This method will prepend and append a string with ^ and $ respectively replaces
     * and wildcards (*) by proper regex wildcards.
     *
     * @param {String} pattern any string that needs to be converted to a regular expression.
     *
     * @returns {RegExp} a regular expression generated from the given string.
     *
     */
    regExpFactory(pattern) {
        const onlyAlphanumericsRegex = new RegExp(/^[a-zA-Z\d]+$/i);
        const antRegex = new RegExp(/^[a-zA-Z\d\*]+$/i);
        let regexpKey;
        if (onlyAlphanumericsRegex.test(pattern)) {
            regexpKey = ['^', '$'].join(pattern);
        }
        else if (antRegex.test(pattern)) {
            regexpKey = ['^', '$'].join(pattern.replace(/\*/g, '.*'));
        }
        else {
            regexpKey = pattern;
        }
        return new RegExp(regexpKey, 'g');
    }
    /*
     * formats HTML outputs typically from Node.outerHTML to easy string comparison by:
     * - remove empty lines
     * - remove spaces between tags
     * - normalize remainign spaces to a single one
     *
     */
    formatHTML(rawHTML) {
        return rawHTML
            .replace(/^\s*\n/gm, '')
            .replace(/\>[\t\s]+\</g, '><')
            .replace(/[\r\n\t\s]+/g, ' ');
    }
}
export const stringUtils = new StringUtils();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nLXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNtYXJ0L3V0aWxzLyIsInNvdXJjZXMiOlsidXRpbHMvc3RyaW5nLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBOzs7Ozs7R0FNRztBQUNILE1BQU0sT0FBTyxXQUFXO0lBQXhCO1FBc0VJOzs7Ozs7Ozs7OztXQVdHO1FBQ0gsYUFBUSxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7WUFDL0I7a0lBQ3NIO1lBQ3RILE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDckIsQ0FBQyxDQUFDLEdBQUc7cUJBQ0UsS0FBSyxDQUFDLEVBQUUsQ0FBQztxQkFDVCxPQUFPLEVBQUU7cUJBQ1QsSUFBSSxDQUFDLEVBQUUsQ0FBQztxQkFDUixPQUFPLENBQUMscUJBQXFCLEVBQUUsTUFBTSxDQUFDO3FCQUN0QyxLQUFLLENBQUMsRUFBRSxDQUFDO3FCQUNULE9BQU8sRUFBRTtxQkFDVCxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNmLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDZCxDQUFDLENBQUM7UUFFRjs7Ozs7Ozs7V0FRRztRQUNILFdBQU0sR0FBRyxDQUFDLE1BQVcsRUFBTyxFQUFFO1lBQzFCOzs7O2VBSUc7WUFDSCxPQUFPLElBQUksQ0FDUCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUM5QyxpQkFBaUIsRUFDakIsU0FBUyxZQUFZLENBQUMsS0FBVSxFQUFFLEVBQVU7Z0JBQ3hDLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDakQsQ0FBQyxDQUNKLENBQ0osQ0FBQztRQUNOLENBQUMsQ0FBQztRQUVGOzs7Ozs7Ozs7O1dBVUc7UUFDSCxlQUFVLEdBQUcsQ0FBQyxHQUFXLEVBQUUsZUFBaUMsRUFBRSxFQUFFO1lBQzVELE1BQU0sS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3RFLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsVUFBUyxPQUFPO2dCQUN0QyxPQUFPLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNwQyxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQztJQUNOLENBQUM7SUExSUc7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILE9BQU8sQ0FBQyxLQUFVO1FBQ2QsT0FBTyxDQUNILE9BQU8sS0FBSyxLQUFLLFdBQVc7WUFDNUIsS0FBSyxLQUFLLElBQUk7WUFDZCxLQUFLLEtBQUssTUFBTTtZQUNoQixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FDdkMsQ0FBQztJQUNOLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUVILGFBQWEsQ0FBQyxPQUFlO1FBQ3pCLE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUM1RCxNQUFNLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRWhELElBQUksU0FBUyxDQUFDO1FBQ2QsSUFBSSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdEMsU0FBUyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN4QzthQUFNLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMvQixTQUFTLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDN0Q7YUFBTTtZQUNILFNBQVMsR0FBRyxPQUFPLENBQUM7U0FDdkI7UUFFRCxPQUFPLElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsVUFBVSxDQUFDLE9BQWU7UUFDdEIsT0FBTyxPQUFPO2FBQ1QsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUM7YUFDdkIsT0FBTyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUM7YUFDN0IsT0FBTyxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0NBdUVKO0FBRUQsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLElBQUksV0FBVyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCB7IFR5cGVkTWFwIH0gZnJvbSAnLi4vZHRvcyc7XG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogdXRpbGl0eSBzZXJ2aWNlIGFyb3VuZCBTdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nVXRpbHMge1xuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICogQG5hbWUgQHNtYXJ0dXRpbHMuc2VydmljZXM6U3RyaW5nVXRpbHMjaXNCbGFua1xuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPGI+aXNCbGFuazwvYj4gd2lsbCBjaGVjayBpZiBhIGdpdmVuIHN0cmluZyBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciBlbXB0eS5cbiAgICAgKiAtIHJldHVybnMgVFJVRSBmb3IgdW5kZWZpbmVkIC8gbnVsbC8gZW1wdHkgc3RyaW5nXG4gICAgICogLSByZXR1cm5zIEZBTFNFIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0U3RyaW5nIGFueSBpbnB1dCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIG51bGwgZWxzZSBmYWxzZVxuICAgICAqL1xuICAgIGlzQmxhbmsodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAnbnVsbCcgfHxcbiAgICAgICAgICAgIHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlscyNyZWdFeHBGYWN0b3J5XG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8Yj5yZWdFeHBGYWN0b3J5PC9iPiB3aWxsIGNvbnZlcnQgYSBnaXZlbiBwYXR0ZXJuIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBwcmVwZW5kIGFuZCBhcHBlbmQgYSBzdHJpbmcgd2l0aCBeIGFuZCAkIHJlc3BlY3RpdmVseSByZXBsYWNlc1xuICAgICAqIGFuZCB3aWxkY2FyZHMgKCopIGJ5IHByb3BlciByZWdleCB3aWxkY2FyZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBhbnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1JlZ0V4cH0gYSByZWd1bGFyIGV4cHJlc3Npb24gZ2VuZXJhdGVkIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuXG4gICAgcmVnRXhwRmFjdG9yeShwYXR0ZXJuOiBzdHJpbmcpOiBSZWdFeHAge1xuICAgICAgICBjb25zdCBvbmx5QWxwaGFudW1lcmljc1JlZ2V4ID0gbmV3IFJlZ0V4cCgvXlthLXpBLVpcXGRdKyQvaSk7XG4gICAgICAgIGNvbnN0IGFudFJlZ2V4ID0gbmV3IFJlZ0V4cCgvXlthLXpBLVpcXGRcXCpdKyQvaSk7XG5cbiAgICAgICAgbGV0IHJlZ2V4cEtleTtcbiAgICAgICAgaWYgKG9ubHlBbHBoYW51bWVyaWNzUmVnZXgudGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVnZXhwS2V5ID0gWydeJywgJyQnXS5qb2luKHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGFudFJlZ2V4LnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJlZ2V4cEtleSA9IFsnXicsICckJ10uam9pbihwYXR0ZXJuLnJlcGxhY2UoL1xcKi9nLCAnLionKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdleHBLZXkgPSBwYXR0ZXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwS2V5LCAnZycpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogZm9ybWF0cyBIVE1MIG91dHB1dHMgdHlwaWNhbGx5IGZyb20gTm9kZS5vdXRlckhUTUwgdG8gZWFzeSBzdHJpbmcgY29tcGFyaXNvbiBieTpcbiAgICAgKiAtIHJlbW92ZSBlbXB0eSBsaW5lc1xuICAgICAqIC0gcmVtb3ZlIHNwYWNlcyBiZXR3ZWVuIHRhZ3NcbiAgICAgKiAtIG5vcm1hbGl6ZSByZW1haW5pZ24gc3BhY2VzIHRvIGEgc2luZ2xlIG9uZVxuICAgICAqXG4gICAgICovXG4gICAgZm9ybWF0SFRNTChyYXdIVE1MOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gcmF3SFRNTFxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMqXFxuL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXD5bXFx0XFxzXStcXDwvZywgJz48JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxyXFxuXFx0XFxzXSsvZywgJyAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzI3Nhbml0aXplXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8Yj5lc2NhcGVzIGFueSBoYXJtZnVsIHNjcmlwdGluZyBmcm9tIGEgc3RyaW5nLCBsZWF2ZXMgaW5ub2N1b3VzIEhUTUwgdW50b3VjaGVkL2I+XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGEgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHNhbml0aXplZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKi9cbiAgICBzYW5pdGl6ZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAgIC8qIFRoZSBjb3JyZWN0IHNvbHV0aW9uIGZvciB0aGlzIGlzIHRvIHVzZSBOZWdhdGl2ZSBMb29rYmVoaW5kIFJlZ2V4IGV4cHJlc3Npb24gd2hpY2ggaXMgYXZhaWxhYmxlIGFzIHBhcnQgb2YgRVMyMDE4LiAvLyBzdHIucmVwbGFjZSgvKD86KD88IVxcXFwpKFsoKV0pKS9nLCAnXFxcXCQxJylcbiAgICAgICAgQnV0IGluIG9yZGVyIHRvIHN1cHBvcnQgY3Jvc3MgYnJvd3NlciBjb21wYXRpYmlsaXR5LCB0aGUgc3RyaW5nIGlzIHJldmVyc2VkIGFuZCBuZWdhdGl2ZSBsb29rYWhlYWQgaXMgdXNlZCBpbnN0ZWFkLiAqL1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNCbGFuayhzdHIpXG4gICAgICAgICAgICA/IHN0clxuICAgICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKD86KChbKCldKSg/IVxcXFwpKSkvZywgJyQxXFxcXCcpXG4gICAgICAgICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAuam9pbignJylcbiAgICAgICAgICAgIDogc3RyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAqIEBuYW1lIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzI2VuY29kZVxuICAgICAqIEBtZXRob2RPZiBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlsc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogd2lsbCByZXR1cm4gYSBlbmNvZGVkIHZhbHVlIGZvciBhbnkgSlNPTiBvYmplY3QgcGFzc2VkIGFzIGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IEpTT04gb2JqZWN0IHRvIGJlIGVuY29kZWRcbiAgICAgKi9cbiAgICBlbmNvZGUgPSAob2JqZWN0OiBhbnkpOiBhbnkgPT4ge1xuICAgICAgICAvKiBmaXJzdCB3ZSB1c2UgZW5jb2RlVVJJQ29tcG9uZW50IHRvIGdldCBwZXJjZW50LWVuY29kZWQgVVRGLTgsXG4gICAgICAgICAqIHRoZW4gd2UgY29udmVydCB0aGUgcGVyY2VudCBlbmNvZGluZ3MgaW50byByYXcgYnl0ZXMgd2hpY2hcbiAgICAgICAgICogY2FuIGJlIGZlZCBpbnRvIGJ0b2EuXG4gICAgICAgICAqIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYnRvYShcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvYmplY3QpKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8lKFswLTlBLUZdezJ9KS9nLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRvU29saWRCeXRlcyhtYXRjaDogYW55LCBwMTogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHAxLCAxNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIHNlcnZpY2VcbiAgICAgKiBAbmFtZSBAc21hcnR1dGlscy5zZXJ2aWNlczpTdHJpbmdVdGlscyNyZXBsYWNlQWxsXG4gICAgICogQG1ldGhvZE9mIEBzbWFydHV0aWxzLnNlcnZpY2VzOlN0cmluZ1V0aWxzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiB3aWxsIHJldHVybiBhIHN0cmluZyB3aGVyZSBhbGwgbWF0Y2hlcyBmb3IgdGhlIHN0cmluZyByZWdleHBzIGtleXMgcGFzc2VkIGluIHRoZSBzdWJzdGl0dXRpb25NYXAgd2lsbCBoYXZlIGJlZW4gc3Vic3RpdHV0ZWQgYnkgY29ycmVzcG9pbmcgdmFsdWVzIGluIHRoZSBzdWJzdGl0dXRpb25NYXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgdG8gc3Vic3RpdHV0ZSBrZXlzIGluIG9iamVjdCB0byBiZSBlbmNvZGVkXG4gICAgICogQHBhcmFtIHtUeXBlZE1hcDxzdHJpbmc+fSBzdWJzdGl0dXRpb25NYXAgdGhlIG1hcCBvZiBzdHJpbmcgcmVnZXhwIHRvIHN0cmluZyBzdWJzdGl0dXRpb24gdmFsdWVzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHN1YnN0aXR1dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHJlcGxhY2VBbGwgPSAoc3RyOiBzdHJpbmcsIHN1YnN0aXR1dGlvbk1hcDogVHlwZWRNYXA8c3RyaW5nPikgPT4ge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoT2JqZWN0LmtleXMoc3Vic3RpdHV0aW9uTWFwKS5qb2luKCd8JyksICdnJyk7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbk1hcFttYXRjaGVkXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHN0cmluZ1V0aWxzID0gbmV3IFN0cmluZ1V0aWxzKCk7XG4iXX0=