/**
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
/**
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 * @module smartutils
 */
import { annotationService } from '../annotation.service';
import * as lo from 'lodash';
import { functionsUtils } from '../../utils';
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// CACHE CONFIG ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
const cacheConfigAnnotationName = 'CacheConfig';
/**
 * @ngdoc object
 * @name @smartutils.object:@CacheConfig
 * @description
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for setting
 *  class level cache configuration to be merged into method specific {@link @smartutils.object:@Cached @Cached} and
 *  {@link @smartutils.object:@InvalidateCache @InvalidateCache} configurations.
 * @param {object} cacheConfig the configuration fo this cache
 * @param {cacheAction} cacheConfig.actions the list of {@link @smartutils.object:CacheAction CacheAction} characterizing this cache.
 * @param {EvictionTag[]} cacheConfig.tags a list of {@link @smartutils.object:EvictionTag EvictionTag} to control the eviction behaviour of this cache.
 */
export const CacheConfig = annotationService.getClassAnnotationFactory(cacheConfigAnnotationName);
export function CacheConfigAnnotationFactory(logService) {
    'ngInject';
    return annotationService.setClassAnnotationFactory(cacheConfigAnnotationName, (factoryArguments) => {
        return function (instance, originalConstructor, invocationArguments) {
            originalConstructor.call(instance, ...invocationArguments);
            instance.cacheConfig = factoryArguments[0];
            logService.debug(`adding cache config ${JSON.stringify(instance.cacheConfig)} to class ${functionsUtils.getInstanceConstructorName(instance)}`, instance);
        };
    });
}
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// CACHE ////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
const CachedAnnotationName = 'Cached';
/**
 * @ngdoc object
 * @name @smartutils.object:@Cached
 * @description
 * Method level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for performing
 * invocation arguments sensitive method caching.
 * <br/> This annotation must only be used on methods returning promises.
 * @param {object} cacheConfig the configuration fo this cache
 * <br/> This configuration will be merged with a class level {@link @smartutils.object:@CacheConfig @acheConfig} if any.
 * @throws if no {@link @smartutils.object:CacheAction CacheAction} is found in the resulting merge
 * @param {cacheAction} cacheConfig.actions the list of {@link @smartutils.object:CacheAction CacheAction} characterizing this cache.
 * @param {EvictionTag[]} cacheConfig.tags a list of {@link @smartutils.object:EvictionTag EvictionTag} to control the eviction behaviour of this cache.
 */
export const Cached = annotationService.getMethodAnnotationFactory(CachedAnnotationName);
export function CachedAnnotationFactory(cacheService) {
    'ngInject';
    const result = annotationService.setMethodAnnotationFactory(CachedAnnotationName, (factoryArguments) => {
        return function (target, propertyName, originalMethod, invocationArguments) {
            let actions = [];
            let tags = [];
            if (factoryArguments[0]) {
                actions = factoryArguments[0].actions;
                tags = factoryArguments[0].tags;
            }
            if (target.cacheConfig) {
                if (target.cacheConfig.actions) {
                    actions = lo.uniq(actions.concat(target.cacheConfig.actions));
                }
                if (target.cacheConfig.tags) {
                    tags = lo.uniq(tags.concat(target.cacheConfig.tags));
                }
            }
            if (!actions.length) {
                const constructorName = functionsUtils.getInstanceConstructorName(target);
                throw new Error(`method ${propertyName} of ${constructorName} is @Cached annotated but no CacheAction is specified either through @Cached or through class level @CacheConfig annotation`);
            }
            return cacheService.handle(target, propertyName, originalMethod, Array.prototype.slice.apply(invocationArguments), actions, tags);
        };
    });
    return result;
}
///////////////////////////////////////////////////////////////////////////////
////////////////////////////// INVALIDATE CACHE ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////
const InvalidateCacheName = 'InvalidateCache';
/**
 * @ngdoc object
 * @name @smartutils.object:@InvalidateCache
 * @description
 * Method level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory} responsible for
 * invalidating all caches either directly or indirectly declaring the {@link @smartutils.object:EvictionTag eviction tag} passed as argument.
 * if no eviction tag is passed as argument, defaults to the optional eviction tags passed to the class through {@link @smartutils.object:@CacheConfig @CacheConfig}.
 *
 * @param {EvictionTag} evictionTag the {@link @smartutils.object:EvictionTag eviction tag}.
 */
export const InvalidateCache = function (tag) {
    return annotationService.getMethodAnnotationFactory(InvalidateCacheName)(tag);
};
export function InvalidateCacheAnnotationFactory(cacheService) {
    'ngInject';
    return annotationService.setMethodAnnotationFactory(InvalidateCacheName, (factoryArguments) => {
        return function (target, propertyName, originalMethod, invocationArguments) {
            let tags = [];
            const tag = factoryArguments[0];
            if (!tag) {
                if (target.cacheConfig && target.cacheConfig.tags) {
                    tags = target.cacheConfig.tags;
                }
            }
            else {
                tags = [tag];
            }
            if (!tags.length) {
                throw new Error(`method ${propertyName} of ${target.constructor.name} is @InvalidateCache annotated but no EvictionTag is specified either through @InvalidateCache or through class level @CacheConfig annotation`);
            }
            const returnedObject = originalMethod.apply(undefined, Array.prototype.slice.call(invocationArguments));
            if (returnedObject && returnedObject.then) {
                return returnedObject.then((value) => {
                    cacheService.evict(...tags);
                    return value;
                });
            }
            else {
                cacheService.evict(...tags);
                return returnedObject;
            }
        };
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGVkLWFubm90YXRpb24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac21hcnQvdXRpbHMvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9jYWNoZS9jYWNoZWQtYW5ub3RhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFDSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUkxRCxPQUFPLEtBQUssRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM3QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRzdDLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBRS9FLE1BQU0seUJBQXlCLEdBQUcsYUFBYSxDQUFDO0FBRWhEOzs7Ozs7Ozs7O0dBVUc7QUFFSCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMseUJBQXlCLENBQ2xFLHlCQUF5QixDQUNtRCxDQUFDO0FBRWpGLE1BQU0sVUFBVSw0QkFBNEIsQ0FBQyxVQUFzQjtJQUMvRCxVQUFVLENBQUM7SUFDWCxPQUFPLGlCQUFpQixDQUFDLHlCQUF5QixDQUM5Qyx5QkFBeUIsRUFDekIsQ0FBQyxnQkFBb0UsRUFBRSxFQUFFO1FBQ3JFLE9BQU8sVUFDSCxRQUFhLEVBQ2IsbUJBQXlDLEVBQ3pDLG1CQUEwQjtZQUUxQixtQkFBbUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsbUJBQW1CLENBQUMsQ0FBQztZQUUzRCxRQUFRLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTNDLFVBQVUsQ0FBQyxLQUFLLENBQ1osdUJBQXVCLElBQUksQ0FBQyxTQUFTLENBQ2pDLFFBQVEsQ0FBQyxXQUFXLENBQ3ZCLGFBQWEsY0FBYyxDQUFDLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQ25FLFFBQVEsQ0FDWCxDQUFDO1FBQ04sQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUNKLENBQUM7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QUFXLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUU7b0JBQy9DLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztpQkFDbEM7YUFDSjtpQkFBTTtnQkFDSCxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNoQjtZQUVELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNkLE1BQU0sSUFBSSxLQUFLLENBQ1gsVUFBVSxZQUFZLE9BQ2xCLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFDdkIsK0lBQStJLENBQ2xKLENBQUM7YUFDTDtZQUVELE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQ3ZDLFNBQVMsRUFDVCxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FDbEQsQ0FBQztZQUNGLElBQUksY0FBYyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEVBQUU7Z0JBQ3ZDLE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFO29CQUN0QyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7b0JBQzVCLE9BQU8sS0FBSyxDQUFDO2dCQUNqQixDQUFDLENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNILFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztnQkFDNUIsT0FBTyxjQUFjLENBQUM7YUFDekI7UUFDTCxDQUFDLENBQUM7SUFDTixDQUFDLENBQ0osQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBTQVAgU0Ugb3IgYW4gU0FQIGFmZmlsaWF0ZSBjb21wYW55LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQG1vZHVsZSBzbWFydHV0aWxzXG4gKi9cbmltcG9ydCB7IGFubm90YXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vYW5ub3RhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENhY2hlQWN0aW9uIH0gZnJvbSAnLi9jYWNoZS1hY3Rpb24nO1xuaW1wb3J0IHsgRXZpY3Rpb25UYWcgfSBmcm9tICcuL2V2aWN0aW9uLXRhZyc7XG5pbXBvcnQgeyBDYWNoZVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlLnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgbG8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZ1bmN0aW9uc1V0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENBQ0hFIENPTkZJRyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBjYWNoZUNvbmZpZ0Fubm90YXRpb25OYW1lID0gJ0NhY2hlQ29uZmlnJztcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlQ29uZmlnXG4gKiBAZGVzY3JpcHRpb25cbiAqIENsYXNzIGxldmVsIHR5cGVzY3JpcHQge0BsaW5rIGh0dHA6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1sIGRlY29yYXRvciBmYWN0b3J5fSByZXNwb25zaWJsZSBmb3Igc2V0dGluZ1xuICogIGNsYXNzIGxldmVsIGNhY2hlIGNvbmZpZ3VyYXRpb24gdG8gYmUgbWVyZ2VkIGludG8gbWV0aG9kIHNwZWNpZmljIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlZCBAQ2FjaGVkfSBhbmRcbiAqICB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkBJbnZhbGlkYXRlQ2FjaGUgQEludmFsaWRhdGVDYWNoZX0gY29uZmlndXJhdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVDb25maWcgdGhlIGNvbmZpZ3VyYXRpb24gZm8gdGhpcyBjYWNoZVxuICogQHBhcmFtIHtjYWNoZUFjdGlvbn0gY2FjaGVDb25maWcuYWN0aW9ucyB0aGUgbGlzdCBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkNhY2hlQWN0aW9uIENhY2hlQWN0aW9ufSBjaGFyYWN0ZXJpemluZyB0aGlzIGNhY2hlLlxuICogQHBhcmFtIHtFdmljdGlvblRhZ1tdfSBjYWNoZUNvbmZpZy50YWdzIGEgbGlzdCBvZiB7QGxpbmsgQHNtYXJ0dXRpbHMub2JqZWN0OkV2aWN0aW9uVGFnIEV2aWN0aW9uVGFnfSB0byBjb250cm9sIHRoZSBldmljdGlvbiBiZWhhdmlvdXIgb2YgdGhpcyBjYWNoZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgQ2FjaGVDb25maWcgPSBhbm5vdGF0aW9uU2VydmljZS5nZXRDbGFzc0Fubm90YXRpb25GYWN0b3J5KFxuICAgIGNhY2hlQ29uZmlnQW5ub3RhdGlvbk5hbWVcbikgYXMgKGFyZ3M6IHsgYWN0aW9ucz86IENhY2hlQWN0aW9uW107IHRhZ3M/OiBFdmljdGlvblRhZ1tdIH0pID0+IENsYXNzRGVjb3JhdG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FjaGVDb25maWdBbm5vdGF0aW9uRmFjdG9yeShsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgJ25nSW5qZWN0JztcbiAgICByZXR1cm4gYW5ub3RhdGlvblNlcnZpY2Uuc2V0Q2xhc3NBbm5vdGF0aW9uRmFjdG9yeShcbiAgICAgICAgY2FjaGVDb25maWdBbm5vdGF0aW9uTmFtZSxcbiAgICAgICAgKGZhY3RvcnlBcmd1bWVudHM6IFt7IGFjdGlvbnM6IENhY2hlQWN0aW9uW107IHRhZ3M/OiBFdmljdGlvblRhZ1tdIH1dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGFueSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnN0cnVjdG9yOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uQXJndW1lbnRzOiBhbnlbXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCAuLi5pbnZvY2F0aW9uQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNhY2hlQ29uZmlnID0gZmFjdG9yeUFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgICAgIGxvZ1NlcnZpY2UuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIGBhZGRpbmcgY2FjaGUgY29uZmlnICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jYWNoZUNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICApfSB0byBjbGFzcyAke2Z1bmN0aW9uc1V0aWxzLmdldEluc3RhbmNlQ29uc3RydWN0b3JOYW1lKGluc3RhbmNlKX1gLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENBQ0hFIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBDYWNoZWRBbm5vdGF0aW9uTmFtZSA9ICdDYWNoZWQnO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpAQ2FjaGVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1ldGhvZCBsZXZlbCB0eXBlc2NyaXB0IHtAbGluayBodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBkZWNvcmF0b3IgZmFjdG9yeX0gcmVzcG9uc2libGUgZm9yIHBlcmZvcm1pbmdcbiAqIGludm9jYXRpb24gYXJndW1lbnRzIHNlbnNpdGl2ZSBtZXRob2QgY2FjaGluZy5cbiAqIDxici8+IFRoaXMgYW5ub3RhdGlvbiBtdXN0IG9ubHkgYmUgdXNlZCBvbiBtZXRob2RzIHJldHVybmluZyBwcm9taXNlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZUNvbmZpZyB0aGUgY29uZmlndXJhdGlvbiBmbyB0aGlzIGNhY2hlXG4gKiA8YnIvPiBUaGlzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBhIGNsYXNzIGxldmVsIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6QENhY2hlQ29uZmlnIEBhY2hlQ29uZmlnfSBpZiBhbnkuXG4gKiBAdGhyb3dzIGlmIG5vIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6Q2FjaGVBY3Rpb24gQ2FjaGVBY3Rpb259IGlzIGZvdW5kIGluIHRoZSByZXN1bHRpbmcgbWVyZ2VcbiAqIEBwYXJhbSB7Y2FjaGVBY3Rpb259IGNhY2hlQ29uZmlnLmFjdGlvbnMgdGhlIGxpc3Qgb2Yge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpDYWNoZUFjdGlvbiBDYWNoZUFjdGlvbn0gY2hhcmFjdGVyaXppbmcgdGhpcyBjYWNoZS5cbiAqIEBwYXJhbSB7RXZpY3Rpb25UYWdbXX0gY2FjaGVDb25maWcudGFncyBhIGxpc3Qgb2Yge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpFdmljdGlvblRhZyBFdmljdGlvblRhZ30gdG8gY29udHJvbCB0aGUgZXZpY3Rpb24gYmVoYXZpb3VyIG9mIHRoaXMgY2FjaGUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IENhY2hlZCA9IGFubm90YXRpb25TZXJ2aWNlLmdldE1ldGhvZEFubm90YXRpb25GYWN0b3J5KFxuICAgIENhY2hlZEFubm90YXRpb25OYW1lXG4pIGFzIChhcmdzPzogeyBhY3Rpb25zOiBDYWNoZUFjdGlvbltdOyB0YWdzPzogRXZpY3Rpb25UYWdbXSB9KSA9PiBNZXRob2REZWNvcmF0b3I7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYWNoZWRBbm5vdGF0aW9uRmFjdG9yeShjYWNoZVNlcnZpY2U6IENhY2hlU2VydmljZSkge1xuICAgICduZ0luamVjdCc7XG4gICAgY29uc3QgcmVzdWx0ID0gYW5ub3RhdGlvblNlcnZpY2Uuc2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkoXG4gICAgICAgIENhY2hlZEFubm90YXRpb25OYW1lLFxuICAgICAgICAoZmFjdG9yeUFyZ3VtZW50czogW3sgYWN0aW9uczogQ2FjaGVBY3Rpb25bXTsgdGFnczogRXZpY3Rpb25UYWdbXSB9XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHRhcmdldDogYW55LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kOiAoLi4ueDogYW55W10pID0+IGFueSxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uQXJndW1lbnRzOiBJQXJndW1lbnRzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aW9uczogQ2FjaGVBY3Rpb25bXSA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB0YWdzOiBFdmljdGlvblRhZ1tdID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoZmFjdG9yeUFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gZmFjdG9yeUFyZ3VtZW50c1swXS5hY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gZmFjdG9yeUFyZ3VtZW50c1swXS50YWdzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FjaGVDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jYWNoZUNvbmZpZy5hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gbG8udW5pcShhY3Rpb25zLmNvbmNhdCh0YXJnZXQuY2FjaGVDb25maWcuYWN0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FjaGVDb25maWcudGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncyA9IGxvLnVuaXEodGFncy5jb25jYXQodGFyZ2V0LmNhY2hlQ29uZmlnLnRhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gZnVuY3Rpb25zVXRpbHMuZ2V0SW5zdGFuY2VDb25zdHJ1Y3Rvck5hbWUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYG1ldGhvZCAke3Byb3BlcnR5TmFtZX0gb2YgJHtjb25zdHJ1Y3Rvck5hbWV9IGlzIEBDYWNoZWQgYW5ub3RhdGVkIGJ1dCBubyBDYWNoZUFjdGlvbiBpcyBzcGVjaWZpZWQgZWl0aGVyIHRocm91Z2ggQENhY2hlZCBvciB0aHJvdWdoIGNsYXNzIGxldmVsIEBDYWNoZUNvbmZpZyBhbm5vdGF0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVTZXJ2aWNlLmhhbmRsZShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoaW52b2NhdGlvbkFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIElOVkFMSURBVEUgQ0FDSEUgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBJbnZhbGlkYXRlQ2FjaGVOYW1lID0gJ0ludmFsaWRhdGVDYWNoZSc7XG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEBzbWFydHV0aWxzLm9iamVjdDpASW52YWxpZGF0ZUNhY2hlXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1ldGhvZCBsZXZlbCB0eXBlc2NyaXB0IHtAbGluayBodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2RlY29yYXRvcnMuaHRtbCBkZWNvcmF0b3IgZmFjdG9yeX0gcmVzcG9uc2libGUgZm9yXG4gKiBpbnZhbGlkYXRpbmcgYWxsIGNhY2hlcyBlaXRoZXIgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBkZWNsYXJpbmcgdGhlIHtAbGluayBAc21hcnR1dGlscy5vYmplY3Q6RXZpY3Rpb25UYWcgZXZpY3Rpb24gdGFnfSBwYXNzZWQgYXMgYXJndW1lbnQuXG4gKiBpZiBubyBldmljdGlvbiB0YWcgaXMgcGFzc2VkIGFzIGFyZ3VtZW50LCBkZWZhdWx0cyB0byB0aGUgb3B0aW9uYWwgZXZpY3Rpb24gdGFncyBwYXNzZWQgdG8gdGhlIGNsYXNzIHRocm91Z2gge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpAQ2FjaGVDb25maWcgQENhY2hlQ29uZmlnfS5cbiAqXG4gKiBAcGFyYW0ge0V2aWN0aW9uVGFnfSBldmljdGlvblRhZyB0aGUge0BsaW5rIEBzbWFydHV0aWxzLm9iamVjdDpFdmljdGlvblRhZyBldmljdGlvbiB0YWd9LlxuICovXG5cbmV4cG9ydCBjb25zdCBJbnZhbGlkYXRlQ2FjaGUgPSBmdW5jdGlvbih0YWc/OiBFdmljdGlvblRhZykge1xuICAgIHJldHVybiBhbm5vdGF0aW9uU2VydmljZS5nZXRNZXRob2RBbm5vdGF0aW9uRmFjdG9yeShJbnZhbGlkYXRlQ2FjaGVOYW1lKSh0YWcpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludmFsaWRhdGVDYWNoZUFubm90YXRpb25GYWN0b3J5KGNhY2hlU2VydmljZTogQ2FjaGVTZXJ2aWNlKSB7XG4gICAgJ25nSW5qZWN0JztcbiAgICByZXR1cm4gYW5ub3RhdGlvblNlcnZpY2Uuc2V0TWV0aG9kQW5ub3RhdGlvbkZhY3RvcnkoXG4gICAgICAgIEludmFsaWRhdGVDYWNoZU5hbWUsXG4gICAgICAgIChmYWN0b3J5QXJndW1lbnRzOiBbRXZpY3Rpb25UYWddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhbnksXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2Q6ICguLi54OiBhbnlbXSkgPT4gYW55LFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25Bcmd1bWVudHM6IElBcmd1bWVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCB0YWdzOiBFdmljdGlvblRhZ1tdID0gW107XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YWc6IEV2aWN0aW9uVGFnID0gZmFjdG9yeUFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNhY2hlQ29uZmlnICYmIHRhcmdldC5jYWNoZUNvbmZpZy50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzID0gdGFyZ2V0LmNhY2hlQ29uZmlnLnRhZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gW3RhZ107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgbWV0aG9kICR7cHJvcGVydHlOYW1lfSBvZiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGlzIEBJbnZhbGlkYXRlQ2FjaGUgYW5ub3RhdGVkIGJ1dCBubyBFdmljdGlvblRhZyBpcyBzcGVjaWZpZWQgZWl0aGVyIHRocm91Z2ggQEludmFsaWRhdGVDYWNoZSBvciB0aHJvdWdoIGNsYXNzIGxldmVsIEBDYWNoZUNvbmZpZyBhbm5vdGF0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkT2JqZWN0ID0gb3JpZ2luYWxNZXRob2QuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW52b2NhdGlvbkFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZE9iamVjdCAmJiByZXR1cm5lZE9iamVjdC50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZE9iamVjdC50aGVuKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVNlcnZpY2UuZXZpY3QoLi4udGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlU2VydmljZS5ldmljdCguLi50YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICApO1xufVxuIl19